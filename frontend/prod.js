"bundle";
System.registerDynamic("npm:babel-core@5.8.34/external-helpers", [], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {
    "format global";
    (function(global) {
      var babelHelpers = global.babelHelpers = {};
      babelHelpers.inherits = function(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
          }});
        if (superClass)
          Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      };
      babelHelpers.defaults = function(obj, defaults) {
        var keys = Object.getOwnPropertyNames(defaults);
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          var value = Object.getOwnPropertyDescriptor(defaults, key);
          if (value && value.configurable && obj[key] === undefined) {
            Object.defineProperty(obj, key, value);
          }
        }
        return obj;
      };
      babelHelpers.createClass = (function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties(Constructor, staticProps);
          return Constructor;
        };
      })();
      babelHelpers.createDecoratedClass = (function() {
        function defineProperties(target, descriptors, initializers) {
          for (var i = 0; i < descriptors.length; i++) {
            var descriptor = descriptors[i];
            var decorators = descriptor.decorators;
            var key = descriptor.key;
            delete descriptor.key;
            delete descriptor.decorators;
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor || descriptor.initializer)
              descriptor.writable = true;
            if (decorators) {
              for (var f = 0; f < decorators.length; f++) {
                var decorator = decorators[f];
                if (typeof decorator === "function") {
                  descriptor = decorator(target, key, descriptor) || descriptor;
                } else {
                  throw new TypeError("The decorator for method " + descriptor.key + " is of the invalid type " + typeof decorator);
                }
              }
              if (descriptor.initializer !== undefined) {
                initializers[key] = descriptor;
                continue;
              }
            }
            Object.defineProperty(target, key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps, protoInitializers, staticInitializers) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps, protoInitializers);
          if (staticProps)
            defineProperties(Constructor, staticProps, staticInitializers);
          return Constructor;
        };
      })();
      babelHelpers.createDecoratedObject = function(descriptors) {
        var target = {};
        for (var i = 0; i < descriptors.length; i++) {
          var descriptor = descriptors[i];
          var decorators = descriptor.decorators;
          var key = descriptor.key;
          delete descriptor.key;
          delete descriptor.decorators;
          descriptor.enumerable = true;
          descriptor.configurable = true;
          if ("value" in descriptor || descriptor.initializer)
            descriptor.writable = true;
          if (decorators) {
            for (var f = 0; f < decorators.length; f++) {
              var decorator = decorators[f];
              if (typeof decorator === "function") {
                descriptor = decorator(target, key, descriptor) || descriptor;
              } else {
                throw new TypeError("The decorator for method " + descriptor.key + " is of the invalid type " + typeof decorator);
              }
            }
          }
          if (descriptor.initializer) {
            descriptor.value = descriptor.initializer.call(target);
          }
          Object.defineProperty(target, key, descriptor);
        }
        return target;
      };
      babelHelpers.defineDecoratedPropertyDescriptor = function(target, key, descriptors) {
        var _descriptor = descriptors[key];
        if (!_descriptor)
          return;
        var descriptor = {};
        for (var _key in _descriptor)
          descriptor[_key] = _descriptor[_key];
        descriptor.value = descriptor.initializer ? descriptor.initializer.call(target) : undefined;
        Object.defineProperty(target, key, descriptor);
      };
      babelHelpers.taggedTemplateLiteral = function(strings, raw) {
        return Object.freeze(Object.defineProperties(strings, {raw: {value: Object.freeze(raw)}}));
      };
      babelHelpers.taggedTemplateLiteralLoose = function(strings, raw) {
        strings.raw = raw;
        return strings;
      };
      babelHelpers.toArray = function(arr) {
        return Array.isArray(arr) ? arr : Array.from(arr);
      };
      babelHelpers.toConsumableArray = function(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0,
              arr2 = Array(arr.length); i < arr.length; i++)
            arr2[i] = arr[i];
          return arr2;
        } else {
          return Array.from(arr);
        }
      };
      babelHelpers.slicedToArray = (function() {
        function sliceIterator(arr, i) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = undefined;
          try {
            for (var _i = arr[Symbol.iterator](),
                _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i)
                break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"])
                _i["return"]();
            } finally {
              if (_d)
                throw _e;
            }
          }
          return _arr;
        }
        return function(arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      })();
      babelHelpers.slicedToArrayLoose = function(arr, i) {
        if (Array.isArray(arr)) {
          return arr;
        } else if (Symbol.iterator in Object(arr)) {
          var _arr = [];
          for (var _iterator = arr[Symbol.iterator](),
              _step; !(_step = _iterator.next()).done; ) {
            _arr.push(_step.value);
            if (i && _arr.length === i)
              break;
          }
          return _arr;
        } else {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
      };
      babelHelpers.objectWithoutProperties = function(obj, keys) {
        var target = {};
        for (var i in obj) {
          if (keys.indexOf(i) >= 0)
            continue;
          if (!Object.prototype.hasOwnProperty.call(obj, i))
            continue;
          target[i] = obj[i];
        }
        return target;
      };
      babelHelpers.hasOwn = Object.prototype.hasOwnProperty;
      babelHelpers.slice = Array.prototype.slice;
      babelHelpers.bind = Function.prototype.bind;
      babelHelpers.defineProperty = function(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }
        return obj;
      };
      babelHelpers.asyncToGenerator = function(fn) {
        return function() {
          var gen = fn.apply(this, arguments);
          return new Promise(function(resolve, reject) {
            var callNext = step.bind(null, "next");
            var callThrow = step.bind(null, "throw");
            function step(key, arg) {
              try {
                var info = gen[key](arg);
                var value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                Promise.resolve(value).then(callNext, callThrow);
              }
            }
            callNext();
          });
        };
      };
      babelHelpers.interopExportWildcard = function(obj, defaults) {
        var newObj = defaults({}, obj);
        delete newObj["default"];
        return newObj;
      };
      babelHelpers.interopRequireWildcard = function(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};
          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key))
                newObj[key] = obj[key];
            }
          }
          newObj["default"] = obj;
          return newObj;
        }
      };
      babelHelpers.interopRequireDefault = function(obj) {
        return obj && obj.__esModule ? obj : {"default": obj};
      };
      babelHelpers._typeof = function(obj) {
        return obj && obj.constructor === Symbol ? "symbol" : typeof obj;
      };
      babelHelpers._extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      babelHelpers.get = function get(object, property, receiver) {
        if (object === null)
          object = Function.prototype;
        var desc = Object.getOwnPropertyDescriptor(object, property);
        if (desc === undefined) {
          var parent = Object.getPrototypeOf(object);
          if (parent === null) {
            return undefined;
          } else {
            return get(parent, property, receiver);
          }
        } else if ("value" in desc) {
          return desc.value;
        } else {
          var getter = desc.get;
          if (getter === undefined) {
            return undefined;
          }
          return getter.call(receiver);
        }
      };
      babelHelpers.set = function set(object, property, value, receiver) {
        var desc = Object.getOwnPropertyDescriptor(object, property);
        if (desc === undefined) {
          var parent = Object.getPrototypeOf(object);
          if (parent !== null) {
            set(parent, property, value, receiver);
          }
        } else if ("value" in desc && desc.writable) {
          desc.value = value;
        } else {
          var setter = desc.set;
          if (setter !== undefined) {
            setter.call(receiver, value);
          }
        }
        return value;
      };
      babelHelpers.newArrowCheck = function(innerThis, boundThis) {
        if (innerThis !== boundThis) {
          throw new TypeError("Cannot instantiate an arrow function");
        }
      };
      babelHelpers.classCallCheck = function(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      };
      babelHelpers.objectDestructuringEmpty = function(obj) {
        if (obj == null)
          throw new TypeError("Cannot destructure undefined");
      };
      babelHelpers.temporalUndefined = {};
      babelHelpers.temporalAssertDefined = function(val, name, undef) {
        if (val === undef) {
          throw new ReferenceError(name + " is not defined - temporal dead zone");
        }
        return true;
      };
      babelHelpers.selfGlobal = typeof global === "undefined" ? self : global;
      babelHelpers.typeofReactElement = typeof Symbol === "function" && Symbol["for"] && Symbol["for"]("react.element") || 60103;
      babelHelpers.defaultProps = function(defaultProps, props) {
        if (defaultProps) {
          for (var propName in defaultProps) {
            if (typeof props[propName] === "undefined") {
              props[propName] = defaultProps[propName];
            }
          }
        }
        return props;
      };
      babelHelpers._instanceof = function(left, right) {
        if (right != null && right[Symbol.hasInstance]) {
          return right[Symbol.hasInstance](left);
        } else {
          return left instanceof right;
        }
      };
      babelHelpers.interopRequire = function(obj) {
        return obj && obj.__esModule ? obj["default"] : obj;
      };
    })(typeof global === "undefined" ? self : global);
  })();
  return _retrieveGlobal();
});

(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function(global, factory) {
  if (typeof module === "object" && typeof module.exports === "object") {
    module.exports = global.document ? factory(global, true) : function(w) {
      if (!w.document) {
        throw new Error("jQuery requires a window with a document");
      }
      return factory(w);
    };
  } else {
    factory(global);
  }
}(typeof window !== "undefined" ? window : this, function(window, noGlobal) {
  var arr = [];
  var slice = arr.slice;
  var concat = arr.concat;
  var push = arr.push;
  var indexOf = arr.indexOf;
  var class2type = {};
  var toString = class2type.toString;
  var hasOwn = class2type.hasOwnProperty;
  var support = {};
  var document = window.document,
      version = "2.1.4",
      jQuery = function(selector, context) {
        return new jQuery.fn.init(selector, context);
      },
      rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
      rmsPrefix = /^-ms-/,
      rdashAlpha = /-([\da-z])/gi,
      fcamelCase = function(all, letter) {
        return letter.toUpperCase();
      };
  jQuery.fn = jQuery.prototype = {
    jquery: version,
    constructor: jQuery,
    selector: "",
    length: 0,
    toArray: function() {
      return slice.call(this);
    },
    get: function(num) {
      return num != null ? (num < 0 ? this[num + this.length] : this[num]) : slice.call(this);
    },
    pushStack: function(elems) {
      var ret = jQuery.merge(this.constructor(), elems);
      ret.prevObject = this;
      ret.context = this.context;
      return ret;
    },
    each: function(callback, args) {
      return jQuery.each(this, callback, args);
    },
    map: function(callback) {
      return this.pushStack(jQuery.map(this, function(elem, i) {
        return callback.call(elem, i, elem);
      }));
    },
    slice: function() {
      return this.pushStack(slice.apply(this, arguments));
    },
    first: function() {
      return this.eq(0);
    },
    last: function() {
      return this.eq(-1);
    },
    eq: function(i) {
      var len = this.length,
          j = +i + (i < 0 ? len : 0);
      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
    },
    end: function() {
      return this.prevObject || this.constructor(null);
    },
    push: push,
    sort: arr.sort,
    splice: arr.splice
  };
  jQuery.extend = jQuery.fn.extend = function() {
    var options,
        name,
        src,
        copy,
        copyIsArray,
        clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;
    if (typeof target === "boolean") {
      deep = target;
      target = arguments[i] || {};
      i++;
    }
    if (typeof target !== "object" && !jQuery.isFunction(target)) {
      target = {};
    }
    if (i === length) {
      target = this;
      i--;
    }
    for (; i < length; i++) {
      if ((options = arguments[i]) != null) {
        for (name in options) {
          src = target[name];
          copy = options[name];
          if (target === copy) {
            continue;
          }
          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && jQuery.isArray(src) ? src : [];
            } else {
              clone = src && jQuery.isPlainObject(src) ? src : {};
            }
            target[name] = jQuery.extend(deep, clone, copy);
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    }
    return target;
  };
  jQuery.extend({
    expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
    isReady: true,
    error: function(msg) {
      throw new Error(msg);
    },
    noop: function() {},
    isFunction: function(obj) {
      return jQuery.type(obj) === "function";
    },
    isArray: Array.isArray,
    isWindow: function(obj) {
      return obj != null && obj === obj.window;
    },
    isNumeric: function(obj) {
      return !jQuery.isArray(obj) && (obj - parseFloat(obj) + 1) >= 0;
    },
    isPlainObject: function(obj) {
      if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
        return false;
      }
      if (obj.constructor && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
        return false;
      }
      return true;
    },
    isEmptyObject: function(obj) {
      var name;
      for (name in obj) {
        return false;
      }
      return true;
    },
    type: function(obj) {
      if (obj == null) {
        return obj + "";
      }
      return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
    },
    globalEval: function(code) {
      var script,
          indirect = eval;
      code = jQuery.trim(code);
      if (code) {
        if (code.indexOf("use strict") === 1) {
          script = document.createElement("script");
          script.text = code;
          document.head.appendChild(script).parentNode.removeChild(script);
        } else {
          indirect(code);
        }
      }
    },
    camelCase: function(string) {
      return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
    },
    nodeName: function(elem, name) {
      return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    },
    each: function(obj, callback, args) {
      var value,
          i = 0,
          length = obj.length,
          isArray = isArraylike(obj);
      if (args) {
        if (isArray) {
          for (; i < length; i++) {
            value = callback.apply(obj[i], args);
            if (value === false) {
              break;
            }
          }
        } else {
          for (i in obj) {
            value = callback.apply(obj[i], args);
            if (value === false) {
              break;
            }
          }
        }
      } else {
        if (isArray) {
          for (; i < length; i++) {
            value = callback.call(obj[i], i, obj[i]);
            if (value === false) {
              break;
            }
          }
        } else {
          for (i in obj) {
            value = callback.call(obj[i], i, obj[i]);
            if (value === false) {
              break;
            }
          }
        }
      }
      return obj;
    },
    trim: function(text) {
      return text == null ? "" : (text + "").replace(rtrim, "");
    },
    makeArray: function(arr, results) {
      var ret = results || [];
      if (arr != null) {
        if (isArraylike(Object(arr))) {
          jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
        } else {
          push.call(ret, arr);
        }
      }
      return ret;
    },
    inArray: function(elem, arr, i) {
      return arr == null ? -1 : indexOf.call(arr, elem, i);
    },
    merge: function(first, second) {
      var len = +second.length,
          j = 0,
          i = first.length;
      for (; j < len; j++) {
        first[i++] = second[j];
      }
      first.length = i;
      return first;
    },
    grep: function(elems, callback, invert) {
      var callbackInverse,
          matches = [],
          i = 0,
          length = elems.length,
          callbackExpect = !invert;
      for (; i < length; i++) {
        callbackInverse = !callback(elems[i], i);
        if (callbackInverse !== callbackExpect) {
          matches.push(elems[i]);
        }
      }
      return matches;
    },
    map: function(elems, callback, arg) {
      var value,
          i = 0,
          length = elems.length,
          isArray = isArraylike(elems),
          ret = [];
      if (isArray) {
        for (; i < length; i++) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret.push(value);
          }
        }
      } else {
        for (i in elems) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret.push(value);
          }
        }
      }
      return concat.apply([], ret);
    },
    guid: 1,
    proxy: function(fn, context) {
      var tmp,
          args,
          proxy;
      if (typeof context === "string") {
        tmp = fn[context];
        context = fn;
        fn = tmp;
      }
      if (!jQuery.isFunction(fn)) {
        return undefined;
      }
      args = slice.call(arguments, 2);
      proxy = function() {
        return fn.apply(context || this, args.concat(slice.call(arguments)));
      };
      proxy.guid = fn.guid = fn.guid || jQuery.guid++;
      return proxy;
    },
    now: Date.now,
    support: support
  });
  jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
    class2type["[object " + name + "]"] = name.toLowerCase();
  });
  function isArraylike(obj) {
    var length = "length" in obj && obj.length,
        type = jQuery.type(obj);
    if (type === "function" || jQuery.isWindow(obj)) {
      return false;
    }
    if (obj.nodeType === 1 && length) {
      return true;
    }
    return type === "array" || length === 0 || typeof length === "number" && length > 0 && (length - 1) in obj;
  }
  var Sizzle = (function(window) {
    var i,
        support,
        Expr,
        getText,
        isXML,
        tokenize,
        compile,
        select,
        outermostContext,
        sortInput,
        hasDuplicate,
        setDocument,
        document,
        docElem,
        documentIsHTML,
        rbuggyQSA,
        rbuggyMatches,
        matches,
        contains,
        expando = "sizzle" + 1 * new Date(),
        preferredDoc = window.document,
        dirruns = 0,
        done = 0,
        classCache = createCache(),
        tokenCache = createCache(),
        compilerCache = createCache(),
        sortOrder = function(a, b) {
          if (a === b) {
            hasDuplicate = true;
          }
          return 0;
        },
        MAX_NEGATIVE = 1 << 31,
        hasOwn = ({}).hasOwnProperty,
        arr = [],
        pop = arr.pop,
        push_native = arr.push,
        push = arr.push,
        slice = arr.slice,
        indexOf = function(list, elem) {
          var i = 0,
              len = list.length;
          for (; i < len; i++) {
            if (list[i] === elem) {
              return i;
            }
          }
          return -1;
        },
        booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
        whitespace = "[\\x20\\t\\r\\n\\f]",
        characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
        identifier = characterEncoding.replace("w", "w#"),
        attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
        pseudos = ":(" + characterEncoding + ")(?:\\((" + "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + ".*" + ")\\)|)",
        rwhitespace = new RegExp(whitespace + "+", "g"),
        rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
        rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
        rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
        rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
        rpseudo = new RegExp(pseudos),
        ridentifier = new RegExp("^" + identifier + "$"),
        matchExpr = {
          "ID": new RegExp("^#(" + characterEncoding + ")"),
          "CLASS": new RegExp("^\\.(" + characterEncoding + ")"),
          "TAG": new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
          "ATTR": new RegExp("^" + attributes),
          "PSEUDO": new RegExp("^" + pseudos),
          "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
          "bool": new RegExp("^(?:" + booleans + ")$", "i"),
          "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        },
        rinputs = /^(?:input|select|textarea|button)$/i,
        rheader = /^h\d$/i,
        rnative = /^[^{]+\{\s*\[native \w/,
        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
        rsibling = /[+~]/,
        rescape = /'|\\/g,
        runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
        funescape = function(_, escaped, escapedWhitespace) {
          var high = "0x" + escaped - 0x10000;
          return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
        },
        unloadHandler = function() {
          setDocument();
        };
    try {
      push.apply((arr = slice.call(preferredDoc.childNodes)), preferredDoc.childNodes);
      arr[preferredDoc.childNodes.length].nodeType;
    } catch (e) {
      push = {apply: arr.length ? function(target, els) {
          push_native.apply(target, slice.call(els));
        } : function(target, els) {
          var j = target.length,
              i = 0;
          while ((target[j++] = els[i++])) {}
          target.length = j - 1;
        }};
    }
    function Sizzle(selector, context, results, seed) {
      var match,
          elem,
          m,
          nodeType,
          i,
          groups,
          old,
          nid,
          newContext,
          newSelector;
      if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
        setDocument(context);
      }
      context = context || document;
      results = results || [];
      nodeType = context.nodeType;
      if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
        return results;
      }
      if (!seed && documentIsHTML) {
        if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
          if ((m = match[1])) {
            if (nodeType === 9) {
              elem = context.getElementById(m);
              if (elem && elem.parentNode) {
                if (elem.id === m) {
                  results.push(elem);
                  return results;
                }
              } else {
                return results;
              }
            } else {
              if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
                results.push(elem);
                return results;
              }
            }
          } else if (match[2]) {
            push.apply(results, context.getElementsByTagName(selector));
            return results;
          } else if ((m = match[3]) && support.getElementsByClassName) {
            push.apply(results, context.getElementsByClassName(m));
            return results;
          }
        }
        if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
          nid = old = expando;
          newContext = context;
          newSelector = nodeType !== 1 && selector;
          if (nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
            groups = tokenize(selector);
            if ((old = context.getAttribute("id"))) {
              nid = old.replace(rescape, "\\$&");
            } else {
              context.setAttribute("id", nid);
            }
            nid = "[id='" + nid + "'] ";
            i = groups.length;
            while (i--) {
              groups[i] = nid + toSelector(groups[i]);
            }
            newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
            newSelector = groups.join(",");
          }
          if (newSelector) {
            try {
              push.apply(results, newContext.querySelectorAll(newSelector));
              return results;
            } catch (qsaError) {} finally {
              if (!old) {
                context.removeAttribute("id");
              }
            }
          }
        }
      }
      return select(selector.replace(rtrim, "$1"), context, results, seed);
    }
    function createCache() {
      var keys = [];
      function cache(key, value) {
        if (keys.push(key + " ") > Expr.cacheLength) {
          delete cache[keys.shift()];
        }
        return (cache[key + " "] = value);
      }
      return cache;
    }
    function markFunction(fn) {
      fn[expando] = true;
      return fn;
    }
    function assert(fn) {
      var div = document.createElement("div");
      try {
        return !!fn(div);
      } catch (e) {
        return false;
      } finally {
        if (div.parentNode) {
          div.parentNode.removeChild(div);
        }
        div = null;
      }
    }
    function addHandle(attrs, handler) {
      var arr = attrs.split("|"),
          i = attrs.length;
      while (i--) {
        Expr.attrHandle[arr[i]] = handler;
      }
    }
    function siblingCheck(a, b) {
      var cur = b && a,
          diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
      if (diff) {
        return diff;
      }
      if (cur) {
        while ((cur = cur.nextSibling)) {
          if (cur === b) {
            return -1;
          }
        }
      }
      return a ? 1 : -1;
    }
    function createInputPseudo(type) {
      return function(elem) {
        var name = elem.nodeName.toLowerCase();
        return name === "input" && elem.type === type;
      };
    }
    function createButtonPseudo(type) {
      return function(elem) {
        var name = elem.nodeName.toLowerCase();
        return (name === "input" || name === "button") && elem.type === type;
      };
    }
    function createPositionalPseudo(fn) {
      return markFunction(function(argument) {
        argument = +argument;
        return markFunction(function(seed, matches) {
          var j,
              matchIndexes = fn([], seed.length, argument),
              i = matchIndexes.length;
          while (i--) {
            if (seed[(j = matchIndexes[i])]) {
              seed[j] = !(matches[j] = seed[j]);
            }
          }
        });
      });
    }
    function testContext(context) {
      return context && typeof context.getElementsByTagName !== "undefined" && context;
    }
    support = Sizzle.support = {};
    isXML = Sizzle.isXML = function(elem) {
      var documentElement = elem && (elem.ownerDocument || elem).documentElement;
      return documentElement ? documentElement.nodeName !== "HTML" : false;
    };
    setDocument = Sizzle.setDocument = function(node) {
      var hasCompare,
          parent,
          doc = node ? node.ownerDocument || node : preferredDoc;
      if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
        return document;
      }
      document = doc;
      docElem = doc.documentElement;
      parent = doc.defaultView;
      if (parent && parent !== parent.top) {
        if (parent.addEventListener) {
          parent.addEventListener("unload", unloadHandler, false);
        } else if (parent.attachEvent) {
          parent.attachEvent("onunload", unloadHandler);
        }
      }
      documentIsHTML = !isXML(doc);
      support.attributes = assert(function(div) {
        div.className = "i";
        return !div.getAttribute("className");
      });
      support.getElementsByTagName = assert(function(div) {
        div.appendChild(doc.createComment(""));
        return !div.getElementsByTagName("*").length;
      });
      support.getElementsByClassName = rnative.test(doc.getElementsByClassName);
      support.getById = assert(function(div) {
        docElem.appendChild(div).id = expando;
        return !doc.getElementsByName || !doc.getElementsByName(expando).length;
      });
      if (support.getById) {
        Expr.find["ID"] = function(id, context) {
          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
            var m = context.getElementById(id);
            return m && m.parentNode ? [m] : [];
          }
        };
        Expr.filter["ID"] = function(id) {
          var attrId = id.replace(runescape, funescape);
          return function(elem) {
            return elem.getAttribute("id") === attrId;
          };
        };
      } else {
        delete Expr.find["ID"];
        Expr.filter["ID"] = function(id) {
          var attrId = id.replace(runescape, funescape);
          return function(elem) {
            var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
            return node && node.value === attrId;
          };
        };
      }
      Expr.find["TAG"] = support.getElementsByTagName ? function(tag, context) {
        if (typeof context.getElementsByTagName !== "undefined") {
          return context.getElementsByTagName(tag);
        } else if (support.qsa) {
          return context.querySelectorAll(tag);
        }
      } : function(tag, context) {
        var elem,
            tmp = [],
            i = 0,
            results = context.getElementsByTagName(tag);
        if (tag === "*") {
          while ((elem = results[i++])) {
            if (elem.nodeType === 1) {
              tmp.push(elem);
            }
          }
          return tmp;
        }
        return results;
      };
      Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
        if (documentIsHTML) {
          return context.getElementsByClassName(className);
        }
      };
      rbuggyMatches = [];
      rbuggyQSA = [];
      if ((support.qsa = rnative.test(doc.querySelectorAll))) {
        assert(function(div) {
          docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\f]' msallowcapture=''>" + "<option selected=''></option></select>";
          if (div.querySelectorAll("[msallowcapture^='']").length) {
            rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
          }
          if (!div.querySelectorAll("[selected]").length) {
            rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
          }
          if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
            rbuggyQSA.push("~=");
          }
          if (!div.querySelectorAll(":checked").length) {
            rbuggyQSA.push(":checked");
          }
          if (!div.querySelectorAll("a#" + expando + "+*").length) {
            rbuggyQSA.push(".#.+[+~]");
          }
        });
        assert(function(div) {
          var input = doc.createElement("input");
          input.setAttribute("type", "hidden");
          div.appendChild(input).setAttribute("name", "D");
          if (div.querySelectorAll("[name=d]").length) {
            rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
          }
          if (!div.querySelectorAll(":enabled").length) {
            rbuggyQSA.push(":enabled", ":disabled");
          }
          div.querySelectorAll("*,:x");
          rbuggyQSA.push(",.*:");
        });
      }
      if ((support.matchesSelector = rnative.test((matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)))) {
        assert(function(div) {
          support.disconnectedMatch = matches.call(div, "div");
          matches.call(div, "[s!='']:x");
          rbuggyMatches.push("!=", pseudos);
        });
      }
      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
      hasCompare = rnative.test(docElem.compareDocumentPosition);
      contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
        var adown = a.nodeType === 9 ? a.documentElement : a,
            bup = b && b.parentNode;
        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
      } : function(a, b) {
        if (b) {
          while ((b = b.parentNode)) {
            if (b === a) {
              return true;
            }
          }
        }
        return false;
      };
      sortOrder = hasCompare ? function(a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
        if (compare) {
          return compare;
        }
        compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
        if (compare & 1 || (!support.sortDetached && b.compareDocumentPosition(a) === compare)) {
          if (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
            return -1;
          }
          if (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
            return 1;
          }
          return sortInput ? (indexOf(sortInput, a) - indexOf(sortInput, b)) : 0;
        }
        return compare & 4 ? -1 : 1;
      } : function(a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var cur,
            i = 0,
            aup = a.parentNode,
            bup = b.parentNode,
            ap = [a],
            bp = [b];
        if (!aup || !bup) {
          return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? (indexOf(sortInput, a) - indexOf(sortInput, b)) : 0;
        } else if (aup === bup) {
          return siblingCheck(a, b);
        }
        cur = a;
        while ((cur = cur.parentNode)) {
          ap.unshift(cur);
        }
        cur = b;
        while ((cur = cur.parentNode)) {
          bp.unshift(cur);
        }
        while (ap[i] === bp[i]) {
          i++;
        }
        return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
      };
      return doc;
    };
    Sizzle.matches = function(expr, elements) {
      return Sizzle(expr, null, null, elements);
    };
    Sizzle.matchesSelector = function(elem, expr) {
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      expr = expr.replace(rattributeQuotes, "='$1']");
      if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
        try {
          var ret = matches.call(elem, expr);
          if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
            return ret;
          }
        } catch (e) {}
      }
      return Sizzle(expr, document, null, [elem]).length > 0;
    };
    Sizzle.contains = function(context, elem) {
      if ((context.ownerDocument || context) !== document) {
        setDocument(context);
      }
      return contains(context, elem);
    };
    Sizzle.attr = function(elem, name) {
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      var fn = Expr.attrHandle[name.toLowerCase()],
          val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
      return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
    };
    Sizzle.error = function(msg) {
      throw new Error("Syntax error, unrecognized expression: " + msg);
    };
    Sizzle.uniqueSort = function(results) {
      var elem,
          duplicates = [],
          j = 0,
          i = 0;
      hasDuplicate = !support.detectDuplicates;
      sortInput = !support.sortStable && results.slice(0);
      results.sort(sortOrder);
      if (hasDuplicate) {
        while ((elem = results[i++])) {
          if (elem === results[i]) {
            j = duplicates.push(i);
          }
        }
        while (j--) {
          results.splice(duplicates[j], 1);
        }
      }
      sortInput = null;
      return results;
    };
    getText = Sizzle.getText = function(elem) {
      var node,
          ret = "",
          i = 0,
          nodeType = elem.nodeType;
      if (!nodeType) {
        while ((node = elem[i++])) {
          ret += getText(node);
        }
      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
        if (typeof elem.textContent === "string") {
          return elem.textContent;
        } else {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            ret += getText(elem);
          }
        }
      } else if (nodeType === 3 || nodeType === 4) {
        return elem.nodeValue;
      }
      return ret;
    };
    Expr = Sizzle.selectors = {
      cacheLength: 50,
      createPseudo: markFunction,
      match: matchExpr,
      attrHandle: {},
      find: {},
      relative: {
        ">": {
          dir: "parentNode",
          first: true
        },
        " ": {dir: "parentNode"},
        "+": {
          dir: "previousSibling",
          first: true
        },
        "~": {dir: "previousSibling"}
      },
      preFilter: {
        "ATTR": function(match) {
          match[1] = match[1].replace(runescape, funescape);
          match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
          if (match[2] === "~=") {
            match[3] = " " + match[3] + " ";
          }
          return match.slice(0, 4);
        },
        "CHILD": function(match) {
          match[1] = match[1].toLowerCase();
          if (match[1].slice(0, 3) === "nth") {
            if (!match[3]) {
              Sizzle.error(match[0]);
            }
            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
            match[5] = +((match[7] + match[8]) || match[3] === "odd");
          } else if (match[3]) {
            Sizzle.error(match[0]);
          }
          return match;
        },
        "PSEUDO": function(match) {
          var excess,
              unquoted = !match[6] && match[2];
          if (matchExpr["CHILD"].test(match[0])) {
            return null;
          }
          if (match[3]) {
            match[2] = match[4] || match[5] || "";
          } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
            match[0] = match[0].slice(0, excess);
            match[2] = unquoted.slice(0, excess);
          }
          return match.slice(0, 3);
        }
      },
      filter: {
        "TAG": function(nodeNameSelector) {
          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
          return nodeNameSelector === "*" ? function() {
            return true;
          } : function(elem) {
            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
          };
        },
        "CLASS": function(className) {
          var pattern = classCache[className + " "];
          return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
            return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
          });
        },
        "ATTR": function(name, operator, check) {
          return function(elem) {
            var result = Sizzle.attr(elem, name);
            if (result == null) {
              return operator === "!=";
            }
            if (!operator) {
              return true;
            }
            result += "";
            return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
          };
        },
        "CHILD": function(type, what, argument, first, last) {
          var simple = type.slice(0, 3) !== "nth",
              forward = type.slice(-4) !== "last",
              ofType = what === "of-type";
          return first === 1 && last === 0 ? function(elem) {
            return !!elem.parentNode;
          } : function(elem, context, xml) {
            var cache,
                outerCache,
                node,
                diff,
                nodeIndex,
                start,
                dir = simple !== forward ? "nextSibling" : "previousSibling",
                parent = elem.parentNode,
                name = ofType && elem.nodeName.toLowerCase(),
                useCache = !xml && !ofType;
            if (parent) {
              if (simple) {
                while (dir) {
                  node = elem;
                  while ((node = node[dir])) {
                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                      return false;
                    }
                  }
                  start = dir = type === "only" && !start && "nextSibling";
                }
                return true;
              }
              start = [forward ? parent.firstChild : parent.lastChild];
              if (forward && useCache) {
                outerCache = parent[expando] || (parent[expando] = {});
                cache = outerCache[type] || [];
                nodeIndex = cache[0] === dirruns && cache[1];
                diff = cache[0] === dirruns && cache[2];
                node = nodeIndex && parent.childNodes[nodeIndex];
                while ((node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())) {
                  if (node.nodeType === 1 && ++diff && node === elem) {
                    outerCache[type] = [dirruns, nodeIndex, diff];
                    break;
                  }
                }
              } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                diff = cache[1];
              } else {
                while ((node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())) {
                  if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                    if (useCache) {
                      (node[expando] || (node[expando] = {}))[type] = [dirruns, diff];
                    }
                    if (node === elem) {
                      break;
                    }
                  }
                }
              }
              diff -= last;
              return diff === first || (diff % first === 0 && diff / first >= 0);
            }
          };
        },
        "PSEUDO": function(pseudo, argument) {
          var args,
              fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
          if (fn[expando]) {
            return fn(argument);
          }
          if (fn.length > 1) {
            args = [pseudo, pseudo, "", argument];
            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
              var idx,
                  matched = fn(seed, argument),
                  i = matched.length;
              while (i--) {
                idx = indexOf(seed, matched[i]);
                seed[idx] = !(matches[idx] = matched[i]);
              }
            }) : function(elem) {
              return fn(elem, 0, args);
            };
          }
          return fn;
        }
      },
      pseudos: {
        "not": markFunction(function(selector) {
          var input = [],
              results = [],
              matcher = compile(selector.replace(rtrim, "$1"));
          return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
            var elem,
                unmatched = matcher(seed, null, xml, []),
                i = seed.length;
            while (i--) {
              if ((elem = unmatched[i])) {
                seed[i] = !(matches[i] = elem);
              }
            }
          }) : function(elem, context, xml) {
            input[0] = elem;
            matcher(input, null, xml, results);
            input[0] = null;
            return !results.pop();
          };
        }),
        "has": markFunction(function(selector) {
          return function(elem) {
            return Sizzle(selector, elem).length > 0;
          };
        }),
        "contains": markFunction(function(text) {
          text = text.replace(runescape, funescape);
          return function(elem) {
            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
          };
        }),
        "lang": markFunction(function(lang) {
          if (!ridentifier.test(lang || "")) {
            Sizzle.error("unsupported lang: " + lang);
          }
          lang = lang.replace(runescape, funescape).toLowerCase();
          return function(elem) {
            var elemLang;
            do {
              if ((elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {
                elemLang = elemLang.toLowerCase();
                return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
              }
            } while ((elem = elem.parentNode) && elem.nodeType === 1);
            return false;
          };
        }),
        "target": function(elem) {
          var hash = window.location && window.location.hash;
          return hash && hash.slice(1) === elem.id;
        },
        "root": function(elem) {
          return elem === docElem;
        },
        "focus": function(elem) {
          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
        },
        "enabled": function(elem) {
          return elem.disabled === false;
        },
        "disabled": function(elem) {
          return elem.disabled === true;
        },
        "checked": function(elem) {
          var nodeName = elem.nodeName.toLowerCase();
          return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
        },
        "selected": function(elem) {
          if (elem.parentNode) {
            elem.parentNode.selectedIndex;
          }
          return elem.selected === true;
        },
        "empty": function(elem) {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            if (elem.nodeType < 6) {
              return false;
            }
          }
          return true;
        },
        "parent": function(elem) {
          return !Expr.pseudos["empty"](elem);
        },
        "header": function(elem) {
          return rheader.test(elem.nodeName);
        },
        "input": function(elem) {
          return rinputs.test(elem.nodeName);
        },
        "button": function(elem) {
          var name = elem.nodeName.toLowerCase();
          return name === "input" && elem.type === "button" || name === "button";
        },
        "text": function(elem) {
          var attr;
          return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
        },
        "first": createPositionalPseudo(function() {
          return [0];
        }),
        "last": createPositionalPseudo(function(matchIndexes, length) {
          return [length - 1];
        }),
        "eq": createPositionalPseudo(function(matchIndexes, length, argument) {
          return [argument < 0 ? argument + length : argument];
        }),
        "even": createPositionalPseudo(function(matchIndexes, length) {
          var i = 0;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        "odd": createPositionalPseudo(function(matchIndexes, length) {
          var i = 1;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; --i >= 0; ) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; ++i < length; ) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        })
      }
    };
    Expr.pseudos["nth"] = Expr.pseudos["eq"];
    for (i in {
      radio: true,
      checkbox: true,
      file: true,
      password: true,
      image: true
    }) {
      Expr.pseudos[i] = createInputPseudo(i);
    }
    for (i in {
      submit: true,
      reset: true
    }) {
      Expr.pseudos[i] = createButtonPseudo(i);
    }
    function setFilters() {}
    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = new setFilters();
    tokenize = Sizzle.tokenize = function(selector, parseOnly) {
      var matched,
          match,
          tokens,
          type,
          soFar,
          groups,
          preFilters,
          cached = tokenCache[selector + " "];
      if (cached) {
        return parseOnly ? 0 : cached.slice(0);
      }
      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;
      while (soFar) {
        if (!matched || (match = rcomma.exec(soFar))) {
          if (match) {
            soFar = soFar.slice(match[0].length) || soFar;
          }
          groups.push((tokens = []));
        }
        matched = false;
        if ((match = rcombinators.exec(soFar))) {
          matched = match.shift();
          tokens.push({
            value: matched,
            type: match[0].replace(rtrim, " ")
          });
          soFar = soFar.slice(matched.length);
        }
        for (type in Expr.filter) {
          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type: type,
              matches: match
            });
            soFar = soFar.slice(matched.length);
          }
        }
        if (!matched) {
          break;
        }
      }
      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
    };
    function toSelector(tokens) {
      var i = 0,
          len = tokens.length,
          selector = "";
      for (; i < len; i++) {
        selector += tokens[i].value;
      }
      return selector;
    }
    function addCombinator(matcher, combinator, base) {
      var dir = combinator.dir,
          checkNonElements = base && dir === "parentNode",
          doneName = done++;
      return combinator.first ? function(elem, context, xml) {
        while ((elem = elem[dir])) {
          if (elem.nodeType === 1 || checkNonElements) {
            return matcher(elem, context, xml);
          }
        }
      } : function(elem, context, xml) {
        var oldCache,
            outerCache,
            newCache = [dirruns, doneName];
        if (xml) {
          while ((elem = elem[dir])) {
            if (elem.nodeType === 1 || checkNonElements) {
              if (matcher(elem, context, xml)) {
                return true;
              }
            }
          }
        } else {
          while ((elem = elem[dir])) {
            if (elem.nodeType === 1 || checkNonElements) {
              outerCache = elem[expando] || (elem[expando] = {});
              if ((oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                return (newCache[2] = oldCache[2]);
              } else {
                outerCache[dir] = newCache;
                if ((newCache[2] = matcher(elem, context, xml))) {
                  return true;
                }
              }
            }
          }
        }
      };
    }
    function elementMatcher(matchers) {
      return matchers.length > 1 ? function(elem, context, xml) {
        var i = matchers.length;
        while (i--) {
          if (!matchers[i](elem, context, xml)) {
            return false;
          }
        }
        return true;
      } : matchers[0];
    }
    function multipleContexts(selector, contexts, results) {
      var i = 0,
          len = contexts.length;
      for (; i < len; i++) {
        Sizzle(selector, contexts[i], results);
      }
      return results;
    }
    function condense(unmatched, map, filter, context, xml) {
      var elem,
          newUnmatched = [],
          i = 0,
          len = unmatched.length,
          mapped = map != null;
      for (; i < len; i++) {
        if ((elem = unmatched[i])) {
          if (!filter || filter(elem, context, xml)) {
            newUnmatched.push(elem);
            if (mapped) {
              map.push(i);
            }
          }
        }
      }
      return newUnmatched;
    }
    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
      if (postFilter && !postFilter[expando]) {
        postFilter = setMatcher(postFilter);
      }
      if (postFinder && !postFinder[expando]) {
        postFinder = setMatcher(postFinder, postSelector);
      }
      return markFunction(function(seed, results, context, xml) {
        var temp,
            i,
            elem,
            preMap = [],
            postMap = [],
            preexisting = results.length,
            elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
            matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
            matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
        if (matcher) {
          matcher(matcherIn, matcherOut, context, xml);
        }
        if (postFilter) {
          temp = condense(matcherOut, postMap);
          postFilter(temp, [], context, xml);
          i = temp.length;
          while (i--) {
            if ((elem = temp[i])) {
              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
            }
          }
        }
        if (seed) {
          if (postFinder || preFilter) {
            if (postFinder) {
              temp = [];
              i = matcherOut.length;
              while (i--) {
                if ((elem = matcherOut[i])) {
                  temp.push((matcherIn[i] = elem));
                }
              }
              postFinder(null, (matcherOut = []), temp, xml);
            }
            i = matcherOut.length;
            while (i--) {
              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                seed[temp] = !(results[temp] = elem);
              }
            }
          }
        } else {
          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
          if (postFinder) {
            postFinder(null, results, matcherOut, xml);
          } else {
            push.apply(results, matcherOut);
          }
        }
      });
    }
    function matcherFromTokens(tokens) {
      var checkContext,
          matcher,
          j,
          len = tokens.length,
          leadingRelative = Expr.relative[tokens[0].type],
          implicitRelative = leadingRelative || Expr.relative[" "],
          i = leadingRelative ? 1 : 0,
          matchContext = addCombinator(function(elem) {
            return elem === checkContext;
          }, implicitRelative, true),
          matchAnyContext = addCombinator(function(elem) {
            return indexOf(checkContext, elem) > -1;
          }, implicitRelative, true),
          matchers = [function(elem, context, xml) {
            var ret = (!leadingRelative && (xml || context !== outermostContext)) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
            checkContext = null;
            return ret;
          }];
      for (; i < len; i++) {
        if ((matcher = Expr.relative[tokens[i].type])) {
          matchers = [addCombinator(elementMatcher(matchers), matcher)];
        } else {
          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
          if (matcher[expando]) {
            j = ++i;
            for (; j < len; j++) {
              if (Expr.relative[tokens[j].type]) {
                break;
              }
            }
            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({value: tokens[i - 2].type === " " ? "*" : ""})).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens((tokens = tokens.slice(j))), j < len && toSelector(tokens));
          }
          matchers.push(matcher);
        }
      }
      return elementMatcher(matchers);
    }
    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
      var bySet = setMatchers.length > 0,
          byElement = elementMatchers.length > 0,
          superMatcher = function(seed, context, xml, results, outermost) {
            var elem,
                j,
                matcher,
                matchedCount = 0,
                i = "0",
                unmatched = seed && [],
                setMatched = [],
                contextBackup = outermostContext,
                elems = seed || byElement && Expr.find["TAG"]("*", outermost),
                dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                len = elems.length;
            if (outermost) {
              outermostContext = context !== document && context;
            }
            for (; i !== len && (elem = elems[i]) != null; i++) {
              if (byElement && elem) {
                j = 0;
                while ((matcher = elementMatchers[j++])) {
                  if (matcher(elem, context, xml)) {
                    results.push(elem);
                    break;
                  }
                }
                if (outermost) {
                  dirruns = dirrunsUnique;
                }
              }
              if (bySet) {
                if ((elem = !matcher && elem)) {
                  matchedCount--;
                }
                if (seed) {
                  unmatched.push(elem);
                }
              }
            }
            matchedCount += i;
            if (bySet && i !== matchedCount) {
              j = 0;
              while ((matcher = setMatchers[j++])) {
                matcher(unmatched, setMatched, context, xml);
              }
              if (seed) {
                if (matchedCount > 0) {
                  while (i--) {
                    if (!(unmatched[i] || setMatched[i])) {
                      setMatched[i] = pop.call(results);
                    }
                  }
                }
                setMatched = condense(setMatched);
              }
              push.apply(results, setMatched);
              if (outermost && !seed && setMatched.length > 0 && (matchedCount + setMatchers.length) > 1) {
                Sizzle.uniqueSort(results);
              }
            }
            if (outermost) {
              dirruns = dirrunsUnique;
              outermostContext = contextBackup;
            }
            return unmatched;
          };
      return bySet ? markFunction(superMatcher) : superMatcher;
    }
    compile = Sizzle.compile = function(selector, match) {
      var i,
          setMatchers = [],
          elementMatchers = [],
          cached = compilerCache[selector + " "];
      if (!cached) {
        if (!match) {
          match = tokenize(selector);
        }
        i = match.length;
        while (i--) {
          cached = matcherFromTokens(match[i]);
          if (cached[expando]) {
            setMatchers.push(cached);
          } else {
            elementMatchers.push(cached);
          }
        }
        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
        cached.selector = selector;
      }
      return cached;
    };
    select = Sizzle.select = function(selector, context, results, seed) {
      var i,
          tokens,
          token,
          type,
          find,
          compiled = typeof selector === "function" && selector,
          match = !seed && tokenize((selector = compiled.selector || selector));
      results = results || [];
      if (match.length === 1) {
        tokens = match[0] = match[0].slice(0);
        if (tokens.length > 2 && (token = tokens[0]).type === "ID" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
          context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
          if (!context) {
            return results;
          } else if (compiled) {
            context = context.parentNode;
          }
          selector = selector.slice(tokens.shift().value.length);
        }
        i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
        while (i--) {
          token = tokens[i];
          if (Expr.relative[(type = token.type)]) {
            break;
          }
          if ((find = Expr.find[type])) {
            if ((seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context))) {
              tokens.splice(i, 1);
              selector = seed.length && toSelector(tokens);
              if (!selector) {
                push.apply(results, seed);
                return results;
              }
              break;
            }
          }
        }
      }
      (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context);
      return results;
    };
    support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
    support.detectDuplicates = !!hasDuplicate;
    setDocument();
    support.sortDetached = assert(function(div1) {
      return div1.compareDocumentPosition(document.createElement("div")) & 1;
    });
    if (!assert(function(div) {
      div.innerHTML = "<a href='#'></a>";
      return div.firstChild.getAttribute("href") === "#";
    })) {
      addHandle("type|href|height|width", function(elem, name, isXML) {
        if (!isXML) {
          return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
        }
      });
    }
    if (!support.attributes || !assert(function(div) {
      div.innerHTML = "<input/>";
      div.firstChild.setAttribute("value", "");
      return div.firstChild.getAttribute("value") === "";
    })) {
      addHandle("value", function(elem, name, isXML) {
        if (!isXML && elem.nodeName.toLowerCase() === "input") {
          return elem.defaultValue;
        }
      });
    }
    if (!assert(function(div) {
      return div.getAttribute("disabled") == null;
    })) {
      addHandle(booleans, function(elem, name, isXML) {
        var val;
        if (!isXML) {
          return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        }
      });
    }
    return Sizzle;
  })(window);
  jQuery.find = Sizzle;
  jQuery.expr = Sizzle.selectors;
  jQuery.expr[":"] = jQuery.expr.pseudos;
  jQuery.unique = Sizzle.uniqueSort;
  jQuery.text = Sizzle.getText;
  jQuery.isXMLDoc = Sizzle.isXML;
  jQuery.contains = Sizzle.contains;
  var rneedsContext = jQuery.expr.match.needsContext;
  var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);
  var risSimple = /^.[^:#\[\.,]*$/;
  function winnow(elements, qualifier, not) {
    if (jQuery.isFunction(qualifier)) {
      return jQuery.grep(elements, function(elem, i) {
        return !!qualifier.call(elem, i, elem) !== not;
      });
    }
    if (qualifier.nodeType) {
      return jQuery.grep(elements, function(elem) {
        return (elem === qualifier) !== not;
      });
    }
    if (typeof qualifier === "string") {
      if (risSimple.test(qualifier)) {
        return jQuery.filter(qualifier, elements, not);
      }
      qualifier = jQuery.filter(qualifier, elements);
    }
    return jQuery.grep(elements, function(elem) {
      return (indexOf.call(qualifier, elem) >= 0) !== not;
    });
  }
  jQuery.filter = function(expr, elems, not) {
    var elem = elems[0];
    if (not) {
      expr = ":not(" + expr + ")";
    }
    return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
      return elem.nodeType === 1;
    }));
  };
  jQuery.fn.extend({
    find: function(selector) {
      var i,
          len = this.length,
          ret = [],
          self = this;
      if (typeof selector !== "string") {
        return this.pushStack(jQuery(selector).filter(function() {
          for (i = 0; i < len; i++) {
            if (jQuery.contains(self[i], this)) {
              return true;
            }
          }
        }));
      }
      for (i = 0; i < len; i++) {
        jQuery.find(selector, self[i], ret);
      }
      ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
      ret.selector = this.selector ? this.selector + " " + selector : selector;
      return ret;
    },
    filter: function(selector) {
      return this.pushStack(winnow(this, selector || [], false));
    },
    not: function(selector) {
      return this.pushStack(winnow(this, selector || [], true));
    },
    is: function(selector) {
      return !!winnow(this, typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
    }
  });
  var rootjQuery,
      rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
      init = jQuery.fn.init = function(selector, context) {
        var match,
            elem;
        if (!selector) {
          return this;
        }
        if (typeof selector === "string") {
          if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
            match = [null, selector, null];
          } else {
            match = rquickExpr.exec(selector);
          }
          if (match && (match[1] || !context)) {
            if (match[1]) {
              context = context instanceof jQuery ? context[0] : context;
              jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
              if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                for (match in context) {
                  if (jQuery.isFunction(this[match])) {
                    this[match](context[match]);
                  } else {
                    this.attr(match, context[match]);
                  }
                }
              }
              return this;
            } else {
              elem = document.getElementById(match[2]);
              if (elem && elem.parentNode) {
                this.length = 1;
                this[0] = elem;
              }
              this.context = document;
              this.selector = selector;
              return this;
            }
          } else if (!context || context.jquery) {
            return (context || rootjQuery).find(selector);
          } else {
            return this.constructor(context).find(selector);
          }
        } else if (selector.nodeType) {
          this.context = this[0] = selector;
          this.length = 1;
          return this;
        } else if (jQuery.isFunction(selector)) {
          return typeof rootjQuery.ready !== "undefined" ? rootjQuery.ready(selector) : selector(jQuery);
        }
        if (selector.selector !== undefined) {
          this.selector = selector.selector;
          this.context = selector.context;
        }
        return jQuery.makeArray(selector, this);
      };
  init.prototype = jQuery.fn;
  rootjQuery = jQuery(document);
  var rparentsprev = /^(?:parents|prev(?:Until|All))/,
      guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
      };
  jQuery.extend({
    dir: function(elem, dir, until) {
      var matched = [],
          truncate = until !== undefined;
      while ((elem = elem[dir]) && elem.nodeType !== 9) {
        if (elem.nodeType === 1) {
          if (truncate && jQuery(elem).is(until)) {
            break;
          }
          matched.push(elem);
        }
      }
      return matched;
    },
    sibling: function(n, elem) {
      var matched = [];
      for (; n; n = n.nextSibling) {
        if (n.nodeType === 1 && n !== elem) {
          matched.push(n);
        }
      }
      return matched;
    }
  });
  jQuery.fn.extend({
    has: function(target) {
      var targets = jQuery(target, this),
          l = targets.length;
      return this.filter(function() {
        var i = 0;
        for (; i < l; i++) {
          if (jQuery.contains(this, targets[i])) {
            return true;
          }
        }
      });
    },
    closest: function(selectors, context) {
      var cur,
          i = 0,
          l = this.length,
          matched = [],
          pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery(selectors, context || this.context) : 0;
      for (; i < l; i++) {
        for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
          if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
            matched.push(cur);
            break;
          }
        }
      }
      return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
    },
    index: function(elem) {
      if (!elem) {
        return (this[0] && this[0].parentNode) ? this.first().prevAll().length : -1;
      }
      if (typeof elem === "string") {
        return indexOf.call(jQuery(elem), this[0]);
      }
      return indexOf.call(this, elem.jquery ? elem[0] : elem);
    },
    add: function(selector, context) {
      return this.pushStack(jQuery.unique(jQuery.merge(this.get(), jQuery(selector, context))));
    },
    addBack: function(selector) {
      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
    }
  });
  function sibling(cur, dir) {
    while ((cur = cur[dir]) && cur.nodeType !== 1) {}
    return cur;
  }
  jQuery.each({
    parent: function(elem) {
      var parent = elem.parentNode;
      return parent && parent.nodeType !== 11 ? parent : null;
    },
    parents: function(elem) {
      return jQuery.dir(elem, "parentNode");
    },
    parentsUntil: function(elem, i, until) {
      return jQuery.dir(elem, "parentNode", until);
    },
    next: function(elem) {
      return sibling(elem, "nextSibling");
    },
    prev: function(elem) {
      return sibling(elem, "previousSibling");
    },
    nextAll: function(elem) {
      return jQuery.dir(elem, "nextSibling");
    },
    prevAll: function(elem) {
      return jQuery.dir(elem, "previousSibling");
    },
    nextUntil: function(elem, i, until) {
      return jQuery.dir(elem, "nextSibling", until);
    },
    prevUntil: function(elem, i, until) {
      return jQuery.dir(elem, "previousSibling", until);
    },
    siblings: function(elem) {
      return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
    },
    children: function(elem) {
      return jQuery.sibling(elem.firstChild);
    },
    contents: function(elem) {
      return elem.contentDocument || jQuery.merge([], elem.childNodes);
    }
  }, function(name, fn) {
    jQuery.fn[name] = function(until, selector) {
      var matched = jQuery.map(this, fn, until);
      if (name.slice(-5) !== "Until") {
        selector = until;
      }
      if (selector && typeof selector === "string") {
        matched = jQuery.filter(selector, matched);
      }
      if (this.length > 1) {
        if (!guaranteedUnique[name]) {
          jQuery.unique(matched);
        }
        if (rparentsprev.test(name)) {
          matched.reverse();
        }
      }
      return this.pushStack(matched);
    };
  });
  var rnotwhite = (/\S+/g);
  var optionsCache = {};
  function createOptions(options) {
    var object = optionsCache[options] = {};
    jQuery.each(options.match(rnotwhite) || [], function(_, flag) {
      object[flag] = true;
    });
    return object;
  }
  jQuery.Callbacks = function(options) {
    options = typeof options === "string" ? (optionsCache[options] || createOptions(options)) : jQuery.extend({}, options);
    var memory,
        fired,
        firing,
        firingStart,
        firingLength,
        firingIndex,
        list = [],
        stack = !options.once && [],
        fire = function(data) {
          memory = options.memory && data;
          fired = true;
          firingIndex = firingStart || 0;
          firingStart = 0;
          firingLength = list.length;
          firing = true;
          for (; list && firingIndex < firingLength; firingIndex++) {
            if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
              memory = false;
              break;
            }
          }
          firing = false;
          if (list) {
            if (stack) {
              if (stack.length) {
                fire(stack.shift());
              }
            } else if (memory) {
              list = [];
            } else {
              self.disable();
            }
          }
        },
        self = {
          add: function() {
            if (list) {
              var start = list.length;
              (function add(args) {
                jQuery.each(args, function(_, arg) {
                  var type = jQuery.type(arg);
                  if (type === "function") {
                    if (!options.unique || !self.has(arg)) {
                      list.push(arg);
                    }
                  } else if (arg && arg.length && type !== "string") {
                    add(arg);
                  }
                });
              })(arguments);
              if (firing) {
                firingLength = list.length;
              } else if (memory) {
                firingStart = start;
                fire(memory);
              }
            }
            return this;
          },
          remove: function() {
            if (list) {
              jQuery.each(arguments, function(_, arg) {
                var index;
                while ((index = jQuery.inArray(arg, list, index)) > -1) {
                  list.splice(index, 1);
                  if (firing) {
                    if (index <= firingLength) {
                      firingLength--;
                    }
                    if (index <= firingIndex) {
                      firingIndex--;
                    }
                  }
                }
              });
            }
            return this;
          },
          has: function(fn) {
            return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);
          },
          empty: function() {
            list = [];
            firingLength = 0;
            return this;
          },
          disable: function() {
            list = stack = memory = undefined;
            return this;
          },
          disabled: function() {
            return !list;
          },
          lock: function() {
            stack = undefined;
            if (!memory) {
              self.disable();
            }
            return this;
          },
          locked: function() {
            return !stack;
          },
          fireWith: function(context, args) {
            if (list && (!fired || stack)) {
              args = args || [];
              args = [context, args.slice ? args.slice() : args];
              if (firing) {
                stack.push(args);
              } else {
                fire(args);
              }
            }
            return this;
          },
          fire: function() {
            self.fireWith(this, arguments);
            return this;
          },
          fired: function() {
            return !!fired;
          }
        };
    return self;
  };
  jQuery.extend({
    Deferred: function(func) {
      var tuples = [["resolve", "done", jQuery.Callbacks("once memory"), "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"], ["notify", "progress", jQuery.Callbacks("memory")]],
          state = "pending",
          promise = {
            state: function() {
              return state;
            },
            always: function() {
              deferred.done(arguments).fail(arguments);
              return this;
            },
            then: function() {
              var fns = arguments;
              return jQuery.Deferred(function(newDefer) {
                jQuery.each(tuples, function(i, tuple) {
                  var fn = jQuery.isFunction(fns[i]) && fns[i];
                  deferred[tuple[1]](function() {
                    var returned = fn && fn.apply(this, arguments);
                    if (returned && jQuery.isFunction(returned.promise)) {
                      returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);
                    } else {
                      newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                    }
                  });
                });
                fns = null;
              }).promise();
            },
            promise: function(obj) {
              return obj != null ? jQuery.extend(obj, promise) : promise;
            }
          },
          deferred = {};
      promise.pipe = promise.then;
      jQuery.each(tuples, function(i, tuple) {
        var list = tuple[2],
            stateString = tuple[3];
        promise[tuple[1]] = list.add;
        if (stateString) {
          list.add(function() {
            state = stateString;
          }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
        }
        deferred[tuple[0]] = function() {
          deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
          return this;
        };
        deferred[tuple[0] + "With"] = list.fireWith;
      });
      promise.promise(deferred);
      if (func) {
        func.call(deferred, deferred);
      }
      return deferred;
    },
    when: function(subordinate) {
      var i = 0,
          resolveValues = slice.call(arguments),
          length = resolveValues.length,
          remaining = length !== 1 || (subordinate && jQuery.isFunction(subordinate.promise)) ? length : 0,
          deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
          updateFunc = function(i, contexts, values) {
            return function(value) {
              contexts[i] = this;
              values[i] = arguments.length > 1 ? slice.call(arguments) : value;
              if (values === progressValues) {
                deferred.notifyWith(contexts, values);
              } else if (!(--remaining)) {
                deferred.resolveWith(contexts, values);
              }
            };
          },
          progressValues,
          progressContexts,
          resolveContexts;
      if (length > 1) {
        progressValues = new Array(length);
        progressContexts = new Array(length);
        resolveContexts = new Array(length);
        for (; i < length; i++) {
          if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
            resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));
          } else {
            --remaining;
          }
        }
      }
      if (!remaining) {
        deferred.resolveWith(resolveContexts, resolveValues);
      }
      return deferred.promise();
    }
  });
  var readyList;
  jQuery.fn.ready = function(fn) {
    jQuery.ready.promise().done(fn);
    return this;
  };
  jQuery.extend({
    isReady: false,
    readyWait: 1,
    holdReady: function(hold) {
      if (hold) {
        jQuery.readyWait++;
      } else {
        jQuery.ready(true);
      }
    },
    ready: function(wait) {
      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
        return;
      }
      jQuery.isReady = true;
      if (wait !== true && --jQuery.readyWait > 0) {
        return;
      }
      readyList.resolveWith(document, [jQuery]);
      if (jQuery.fn.triggerHandler) {
        jQuery(document).triggerHandler("ready");
        jQuery(document).off("ready");
      }
    }
  });
  function completed() {
    document.removeEventListener("DOMContentLoaded", completed, false);
    window.removeEventListener("load", completed, false);
    jQuery.ready();
  }
  jQuery.ready.promise = function(obj) {
    if (!readyList) {
      readyList = jQuery.Deferred();
      if (document.readyState === "complete") {
        setTimeout(jQuery.ready);
      } else {
        document.addEventListener("DOMContentLoaded", completed, false);
        window.addEventListener("load", completed, false);
      }
    }
    return readyList.promise(obj);
  };
  jQuery.ready.promise();
  var access = jQuery.access = function(elems, fn, key, value, chainable, emptyGet, raw) {
    var i = 0,
        len = elems.length,
        bulk = key == null;
    if (jQuery.type(key) === "object") {
      chainable = true;
      for (i in key) {
        jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
      }
    } else if (value !== undefined) {
      chainable = true;
      if (!jQuery.isFunction(value)) {
        raw = true;
      }
      if (bulk) {
        if (raw) {
          fn.call(elems, value);
          fn = null;
        } else {
          bulk = fn;
          fn = function(elem, key, value) {
            return bulk.call(jQuery(elem), value);
          };
        }
      }
      if (fn) {
        for (; i < len; i++) {
          fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
        }
      }
    }
    return chainable ? elems : bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
  };
  jQuery.acceptData = function(owner) {
    return owner.nodeType === 1 || owner.nodeType === 9 || !(+owner.nodeType);
  };
  function Data() {
    Object.defineProperty(this.cache = {}, 0, {get: function() {
        return {};
      }});
    this.expando = jQuery.expando + Data.uid++;
  }
  Data.uid = 1;
  Data.accepts = jQuery.acceptData;
  Data.prototype = {
    key: function(owner) {
      if (!Data.accepts(owner)) {
        return 0;
      }
      var descriptor = {},
          unlock = owner[this.expando];
      if (!unlock) {
        unlock = Data.uid++;
        try {
          descriptor[this.expando] = {value: unlock};
          Object.defineProperties(owner, descriptor);
        } catch (e) {
          descriptor[this.expando] = unlock;
          jQuery.extend(owner, descriptor);
        }
      }
      if (!this.cache[unlock]) {
        this.cache[unlock] = {};
      }
      return unlock;
    },
    set: function(owner, data, value) {
      var prop,
          unlock = this.key(owner),
          cache = this.cache[unlock];
      if (typeof data === "string") {
        cache[data] = value;
      } else {
        if (jQuery.isEmptyObject(cache)) {
          jQuery.extend(this.cache[unlock], data);
        } else {
          for (prop in data) {
            cache[prop] = data[prop];
          }
        }
      }
      return cache;
    },
    get: function(owner, key) {
      var cache = this.cache[this.key(owner)];
      return key === undefined ? cache : cache[key];
    },
    access: function(owner, key, value) {
      var stored;
      if (key === undefined || ((key && typeof key === "string") && value === undefined)) {
        stored = this.get(owner, key);
        return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
      }
      this.set(owner, key, value);
      return value !== undefined ? value : key;
    },
    remove: function(owner, key) {
      var i,
          name,
          camel,
          unlock = this.key(owner),
          cache = this.cache[unlock];
      if (key === undefined) {
        this.cache[unlock] = {};
      } else {
        if (jQuery.isArray(key)) {
          name = key.concat(key.map(jQuery.camelCase));
        } else {
          camel = jQuery.camelCase(key);
          if (key in cache) {
            name = [key, camel];
          } else {
            name = camel;
            name = name in cache ? [name] : (name.match(rnotwhite) || []);
          }
        }
        i = name.length;
        while (i--) {
          delete cache[name[i]];
        }
      }
    },
    hasData: function(owner) {
      return !jQuery.isEmptyObject(this.cache[owner[this.expando]] || {});
    },
    discard: function(owner) {
      if (owner[this.expando]) {
        delete this.cache[owner[this.expando]];
      }
    }
  };
  var data_priv = new Data();
  var data_user = new Data();
  var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
      rmultiDash = /([A-Z])/g;
  function dataAttr(elem, key, data) {
    var name;
    if (data === undefined && elem.nodeType === 1) {
      name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();
      data = elem.getAttribute(name);
      if (typeof data === "string") {
        try {
          data = data === "true" ? true : data === "false" ? false : data === "null" ? null : +data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
        } catch (e) {}
        data_user.set(elem, key, data);
      } else {
        data = undefined;
      }
    }
    return data;
  }
  jQuery.extend({
    hasData: function(elem) {
      return data_user.hasData(elem) || data_priv.hasData(elem);
    },
    data: function(elem, name, data) {
      return data_user.access(elem, name, data);
    },
    removeData: function(elem, name) {
      data_user.remove(elem, name);
    },
    _data: function(elem, name, data) {
      return data_priv.access(elem, name, data);
    },
    _removeData: function(elem, name) {
      data_priv.remove(elem, name);
    }
  });
  jQuery.fn.extend({
    data: function(key, value) {
      var i,
          name,
          data,
          elem = this[0],
          attrs = elem && elem.attributes;
      if (key === undefined) {
        if (this.length) {
          data = data_user.get(elem);
          if (elem.nodeType === 1 && !data_priv.get(elem, "hasDataAttrs")) {
            i = attrs.length;
            while (i--) {
              if (attrs[i]) {
                name = attrs[i].name;
                if (name.indexOf("data-") === 0) {
                  name = jQuery.camelCase(name.slice(5));
                  dataAttr(elem, name, data[name]);
                }
              }
            }
            data_priv.set(elem, "hasDataAttrs", true);
          }
        }
        return data;
      }
      if (typeof key === "object") {
        return this.each(function() {
          data_user.set(this, key);
        });
      }
      return access(this, function(value) {
        var data,
            camelKey = jQuery.camelCase(key);
        if (elem && value === undefined) {
          data = data_user.get(elem, key);
          if (data !== undefined) {
            return data;
          }
          data = data_user.get(elem, camelKey);
          if (data !== undefined) {
            return data;
          }
          data = dataAttr(elem, camelKey, undefined);
          if (data !== undefined) {
            return data;
          }
          return;
        }
        this.each(function() {
          var data = data_user.get(this, camelKey);
          data_user.set(this, camelKey, value);
          if (key.indexOf("-") !== -1 && data !== undefined) {
            data_user.set(this, key, value);
          }
        });
      }, null, value, arguments.length > 1, null, true);
    },
    removeData: function(key) {
      return this.each(function() {
        data_user.remove(this, key);
      });
    }
  });
  jQuery.extend({
    queue: function(elem, type, data) {
      var queue;
      if (elem) {
        type = (type || "fx") + "queue";
        queue = data_priv.get(elem, type);
        if (data) {
          if (!queue || jQuery.isArray(data)) {
            queue = data_priv.access(elem, type, jQuery.makeArray(data));
          } else {
            queue.push(data);
          }
        }
        return queue || [];
      }
    },
    dequeue: function(elem, type) {
      type = type || "fx";
      var queue = jQuery.queue(elem, type),
          startLength = queue.length,
          fn = queue.shift(),
          hooks = jQuery._queueHooks(elem, type),
          next = function() {
            jQuery.dequeue(elem, type);
          };
      if (fn === "inprogress") {
        fn = queue.shift();
        startLength--;
      }
      if (fn) {
        if (type === "fx") {
          queue.unshift("inprogress");
        }
        delete hooks.stop;
        fn.call(elem, next, hooks);
      }
      if (!startLength && hooks) {
        hooks.empty.fire();
      }
    },
    _queueHooks: function(elem, type) {
      var key = type + "queueHooks";
      return data_priv.get(elem, key) || data_priv.access(elem, key, {empty: jQuery.Callbacks("once memory").add(function() {
          data_priv.remove(elem, [type + "queue", key]);
        })});
    }
  });
  jQuery.fn.extend({
    queue: function(type, data) {
      var setter = 2;
      if (typeof type !== "string") {
        data = type;
        type = "fx";
        setter--;
      }
      if (arguments.length < setter) {
        return jQuery.queue(this[0], type);
      }
      return data === undefined ? this : this.each(function() {
        var queue = jQuery.queue(this, type, data);
        jQuery._queueHooks(this, type);
        if (type === "fx" && queue[0] !== "inprogress") {
          jQuery.dequeue(this, type);
        }
      });
    },
    dequeue: function(type) {
      return this.each(function() {
        jQuery.dequeue(this, type);
      });
    },
    clearQueue: function(type) {
      return this.queue(type || "fx", []);
    },
    promise: function(type, obj) {
      var tmp,
          count = 1,
          defer = jQuery.Deferred(),
          elements = this,
          i = this.length,
          resolve = function() {
            if (!(--count)) {
              defer.resolveWith(elements, [elements]);
            }
          };
      if (typeof type !== "string") {
        obj = type;
        type = undefined;
      }
      type = type || "fx";
      while (i--) {
        tmp = data_priv.get(elements[i], type + "queueHooks");
        if (tmp && tmp.empty) {
          count++;
          tmp.empty.add(resolve);
        }
      }
      resolve();
      return defer.promise(obj);
    }
  });
  var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;
  var cssExpand = ["Top", "Right", "Bottom", "Left"];
  var isHidden = function(elem, el) {
    elem = el || elem;
    return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
  };
  var rcheckableType = (/^(?:checkbox|radio)$/i);
  (function() {
    var fragment = document.createDocumentFragment(),
        div = fragment.appendChild(document.createElement("div")),
        input = document.createElement("input");
    input.setAttribute("type", "radio");
    input.setAttribute("checked", "checked");
    input.setAttribute("name", "t");
    div.appendChild(input);
    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
    div.innerHTML = "<textarea>x</textarea>";
    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
  })();
  var strundefined = typeof undefined;
  support.focusinBubbles = "onfocusin" in window;
  var rkeyEvent = /^key/,
      rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
      rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
      rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
  function returnTrue() {
    return true;
  }
  function returnFalse() {
    return false;
  }
  function safeActiveElement() {
    try {
      return document.activeElement;
    } catch (err) {}
  }
  jQuery.event = {
    global: {},
    add: function(elem, types, handler, data, selector) {
      var handleObjIn,
          eventHandle,
          tmp,
          events,
          t,
          handleObj,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = data_priv.get(elem);
      if (!elemData) {
        return;
      }
      if (handler.handler) {
        handleObjIn = handler;
        handler = handleObjIn.handler;
        selector = handleObjIn.selector;
      }
      if (!handler.guid) {
        handler.guid = jQuery.guid++;
      }
      if (!(events = elemData.events)) {
        events = elemData.events = {};
      }
      if (!(eventHandle = elemData.handle)) {
        eventHandle = elemData.handle = function(e) {
          return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
        };
      }
      types = (types || "").match(rnotwhite) || [""];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort();
        if (!type) {
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        special = jQuery.event.special[type] || {};
        handleObj = jQuery.extend({
          type: type,
          origType: origType,
          data: data,
          handler: handler,
          guid: handler.guid,
          selector: selector,
          needsContext: selector && jQuery.expr.match.needsContext.test(selector),
          namespace: namespaces.join(".")
        }, handleObjIn);
        if (!(handlers = events[type])) {
          handlers = events[type] = [];
          handlers.delegateCount = 0;
          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
            if (elem.addEventListener) {
              elem.addEventListener(type, eventHandle, false);
            }
          }
        }
        if (special.add) {
          special.add.call(elem, handleObj);
          if (!handleObj.handler.guid) {
            handleObj.handler.guid = handler.guid;
          }
        }
        if (selector) {
          handlers.splice(handlers.delegateCount++, 0, handleObj);
        } else {
          handlers.push(handleObj);
        }
        jQuery.event.global[type] = true;
      }
    },
    remove: function(elem, types, handler, selector, mappedTypes) {
      var j,
          origCount,
          tmp,
          events,
          t,
          handleObj,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = data_priv.hasData(elem) && data_priv.get(elem);
      if (!elemData || !(events = elemData.events)) {
        return;
      }
      types = (types || "").match(rnotwhite) || [""];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort();
        if (!type) {
          for (type in events) {
            jQuery.event.remove(elem, type + types[t], handler, selector, true);
          }
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        handlers = events[type] || [];
        tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
        origCount = j = handlers.length;
        while (j--) {
          handleObj = handlers[j];
          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
            handlers.splice(j, 1);
            if (handleObj.selector) {
              handlers.delegateCount--;
            }
            if (special.remove) {
              special.remove.call(elem, handleObj);
            }
          }
        }
        if (origCount && !handlers.length) {
          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
            jQuery.removeEvent(elem, type, elemData.handle);
          }
          delete events[type];
        }
      }
      if (jQuery.isEmptyObject(events)) {
        delete elemData.handle;
        data_priv.remove(elem, "events");
      }
    },
    trigger: function(event, data, elem, onlyHandlers) {
      var i,
          cur,
          tmp,
          bubbleType,
          ontype,
          handle,
          special,
          eventPath = [elem || document],
          type = hasOwn.call(event, "type") ? event.type : event,
          namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
      cur = tmp = elem = elem || document;
      if (elem.nodeType === 3 || elem.nodeType === 8) {
        return;
      }
      if (rfocusMorph.test(type + jQuery.event.triggered)) {
        return;
      }
      if (type.indexOf(".") >= 0) {
        namespaces = type.split(".");
        type = namespaces.shift();
        namespaces.sort();
      }
      ontype = type.indexOf(":") < 0 && "on" + type;
      event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
      event.isTrigger = onlyHandlers ? 2 : 3;
      event.namespace = namespaces.join(".");
      event.namespace_re = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
      event.result = undefined;
      if (!event.target) {
        event.target = elem;
      }
      data = data == null ? [event] : jQuery.makeArray(data, [event]);
      special = jQuery.event.special[type] || {};
      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
        return;
      }
      if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
        bubbleType = special.delegateType || type;
        if (!rfocusMorph.test(bubbleType + type)) {
          cur = cur.parentNode;
        }
        for (; cur; cur = cur.parentNode) {
          eventPath.push(cur);
          tmp = cur;
        }
        if (tmp === (elem.ownerDocument || document)) {
          eventPath.push(tmp.defaultView || tmp.parentWindow || window);
        }
      }
      i = 0;
      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
        event.type = i > 1 ? bubbleType : special.bindType || type;
        handle = (data_priv.get(cur, "events") || {})[event.type] && data_priv.get(cur, "handle");
        if (handle) {
          handle.apply(cur, data);
        }
        handle = ontype && cur[ontype];
        if (handle && handle.apply && jQuery.acceptData(cur)) {
          event.result = handle.apply(cur, data);
          if (event.result === false) {
            event.preventDefault();
          }
        }
      }
      event.type = type;
      if (!onlyHandlers && !event.isDefaultPrevented()) {
        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem)) {
          if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
            tmp = elem[ontype];
            if (tmp) {
              elem[ontype] = null;
            }
            jQuery.event.triggered = type;
            elem[type]();
            jQuery.event.triggered = undefined;
            if (tmp) {
              elem[ontype] = tmp;
            }
          }
        }
      }
      return event.result;
    },
    dispatch: function(event) {
      event = jQuery.event.fix(event);
      var i,
          j,
          ret,
          matched,
          handleObj,
          handlerQueue = [],
          args = slice.call(arguments),
          handlers = (data_priv.get(this, "events") || {})[event.type] || [],
          special = jQuery.event.special[event.type] || {};
      args[0] = event;
      event.delegateTarget = this;
      if (special.preDispatch && special.preDispatch.call(this, event) === false) {
        return;
      }
      handlerQueue = jQuery.event.handlers.call(this, event, handlers);
      i = 0;
      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
        event.currentTarget = matched.elem;
        j = 0;
        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
          if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {
            event.handleObj = handleObj;
            event.data = handleObj.data;
            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
            if (ret !== undefined) {
              if ((event.result = ret) === false) {
                event.preventDefault();
                event.stopPropagation();
              }
            }
          }
        }
      }
      if (special.postDispatch) {
        special.postDispatch.call(this, event);
      }
      return event.result;
    },
    handlers: function(event, handlers) {
      var i,
          matches,
          sel,
          handleObj,
          handlerQueue = [],
          delegateCount = handlers.delegateCount,
          cur = event.target;
      if (delegateCount && cur.nodeType && (!event.button || event.type !== "click")) {
        for (; cur !== this; cur = cur.parentNode || this) {
          if (cur.disabled !== true || event.type !== "click") {
            matches = [];
            for (i = 0; i < delegateCount; i++) {
              handleObj = handlers[i];
              sel = handleObj.selector + " ";
              if (matches[sel] === undefined) {
                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length;
              }
              if (matches[sel]) {
                matches.push(handleObj);
              }
            }
            if (matches.length) {
              handlerQueue.push({
                elem: cur,
                handlers: matches
              });
            }
          }
        }
      }
      if (delegateCount < handlers.length) {
        handlerQueue.push({
          elem: this,
          handlers: handlers.slice(delegateCount)
        });
      }
      return handlerQueue;
    },
    props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
    fixHooks: {},
    keyHooks: {
      props: "char charCode key keyCode".split(" "),
      filter: function(event, original) {
        if (event.which == null) {
          event.which = original.charCode != null ? original.charCode : original.keyCode;
        }
        return event;
      }
    },
    mouseHooks: {
      props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
      filter: function(event, original) {
        var eventDoc,
            doc,
            body,
            button = original.button;
        if (event.pageX == null && original.clientX != null) {
          eventDoc = event.target.ownerDocument || document;
          doc = eventDoc.documentElement;
          body = eventDoc.body;
          event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
          event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
        }
        if (!event.which && button !== undefined) {
          event.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));
        }
        return event;
      }
    },
    fix: function(event) {
      if (event[jQuery.expando]) {
        return event;
      }
      var i,
          prop,
          copy,
          type = event.type,
          originalEvent = event,
          fixHook = this.fixHooks[type];
      if (!fixHook) {
        this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
      }
      copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
      event = new jQuery.Event(originalEvent);
      i = copy.length;
      while (i--) {
        prop = copy[i];
        event[prop] = originalEvent[prop];
      }
      if (!event.target) {
        event.target = document;
      }
      if (event.target.nodeType === 3) {
        event.target = event.target.parentNode;
      }
      return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
    },
    special: {
      load: {noBubble: true},
      focus: {
        trigger: function() {
          if (this !== safeActiveElement() && this.focus) {
            this.focus();
            return false;
          }
        },
        delegateType: "focusin"
      },
      blur: {
        trigger: function() {
          if (this === safeActiveElement() && this.blur) {
            this.blur();
            return false;
          }
        },
        delegateType: "focusout"
      },
      click: {
        trigger: function() {
          if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
            this.click();
            return false;
          }
        },
        _default: function(event) {
          return jQuery.nodeName(event.target, "a");
        }
      },
      beforeunload: {postDispatch: function(event) {
          if (event.result !== undefined && event.originalEvent) {
            event.originalEvent.returnValue = event.result;
          }
        }}
    },
    simulate: function(type, elem, event, bubble) {
      var e = jQuery.extend(new jQuery.Event(), event, {
        type: type,
        isSimulated: true,
        originalEvent: {}
      });
      if (bubble) {
        jQuery.event.trigger(e, null, elem);
      } else {
        jQuery.event.dispatch.call(elem, e);
      }
      if (e.isDefaultPrevented()) {
        event.preventDefault();
      }
    }
  };
  jQuery.removeEvent = function(elem, type, handle) {
    if (elem.removeEventListener) {
      elem.removeEventListener(type, handle, false);
    }
  };
  jQuery.Event = function(src, props) {
    if (!(this instanceof jQuery.Event)) {
      return new jQuery.Event(src, props);
    }
    if (src && src.type) {
      this.originalEvent = src;
      this.type = src.type;
      this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && src.returnValue === false ? returnTrue : returnFalse;
    } else {
      this.type = src;
    }
    if (props) {
      jQuery.extend(this, props);
    }
    this.timeStamp = src && src.timeStamp || jQuery.now();
    this[jQuery.expando] = true;
  };
  jQuery.Event.prototype = {
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,
    preventDefault: function() {
      var e = this.originalEvent;
      this.isDefaultPrevented = returnTrue;
      if (e && e.preventDefault) {
        e.preventDefault();
      }
    },
    stopPropagation: function() {
      var e = this.originalEvent;
      this.isPropagationStopped = returnTrue;
      if (e && e.stopPropagation) {
        e.stopPropagation();
      }
    },
    stopImmediatePropagation: function() {
      var e = this.originalEvent;
      this.isImmediatePropagationStopped = returnTrue;
      if (e && e.stopImmediatePropagation) {
        e.stopImmediatePropagation();
      }
      this.stopPropagation();
    }
  };
  jQuery.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout",
    pointerenter: "pointerover",
    pointerleave: "pointerout"
  }, function(orig, fix) {
    jQuery.event.special[orig] = {
      delegateType: fix,
      bindType: fix,
      handle: function(event) {
        var ret,
            target = this,
            related = event.relatedTarget,
            handleObj = event.handleObj;
        if (!related || (related !== target && !jQuery.contains(target, related))) {
          event.type = handleObj.origType;
          ret = handleObj.handler.apply(this, arguments);
          event.type = fix;
        }
        return ret;
      }
    };
  });
  if (!support.focusinBubbles) {
    jQuery.each({
      focus: "focusin",
      blur: "focusout"
    }, function(orig, fix) {
      var handler = function(event) {
        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
      };
      jQuery.event.special[fix] = {
        setup: function() {
          var doc = this.ownerDocument || this,
              attaches = data_priv.access(doc, fix);
          if (!attaches) {
            doc.addEventListener(orig, handler, true);
          }
          data_priv.access(doc, fix, (attaches || 0) + 1);
        },
        teardown: function() {
          var doc = this.ownerDocument || this,
              attaches = data_priv.access(doc, fix) - 1;
          if (!attaches) {
            doc.removeEventListener(orig, handler, true);
            data_priv.remove(doc, fix);
          } else {
            data_priv.access(doc, fix, attaches);
          }
        }
      };
    });
  }
  jQuery.fn.extend({
    on: function(types, selector, data, fn, one) {
      var origFn,
          type;
      if (typeof types === "object") {
        if (typeof selector !== "string") {
          data = data || selector;
          selector = undefined;
        }
        for (type in types) {
          this.on(type, selector, data, types[type], one);
        }
        return this;
      }
      if (data == null && fn == null) {
        fn = selector;
        data = selector = undefined;
      } else if (fn == null) {
        if (typeof selector === "string") {
          fn = data;
          data = undefined;
        } else {
          fn = data;
          data = selector;
          selector = undefined;
        }
      }
      if (fn === false) {
        fn = returnFalse;
      } else if (!fn) {
        return this;
      }
      if (one === 1) {
        origFn = fn;
        fn = function(event) {
          jQuery().off(event);
          return origFn.apply(this, arguments);
        };
        fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
      }
      return this.each(function() {
        jQuery.event.add(this, types, fn, data, selector);
      });
    },
    one: function(types, selector, data, fn) {
      return this.on(types, selector, data, fn, 1);
    },
    off: function(types, selector, fn) {
      var handleObj,
          type;
      if (types && types.preventDefault && types.handleObj) {
        handleObj = types.handleObj;
        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
        return this;
      }
      if (typeof types === "object") {
        for (type in types) {
          this.off(type, selector, types[type]);
        }
        return this;
      }
      if (selector === false || typeof selector === "function") {
        fn = selector;
        selector = undefined;
      }
      if (fn === false) {
        fn = returnFalse;
      }
      return this.each(function() {
        jQuery.event.remove(this, types, fn, selector);
      });
    },
    trigger: function(type, data) {
      return this.each(function() {
        jQuery.event.trigger(type, data, this);
      });
    },
    triggerHandler: function(type, data) {
      var elem = this[0];
      if (elem) {
        return jQuery.event.trigger(type, data, elem, true);
      }
    }
  });
  var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
      rtagName = /<([\w:]+)/,
      rhtml = /<|&#?\w+;/,
      rnoInnerhtml = /<(?:script|style|link)/i,
      rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
      rscriptType = /^$|\/(?:java|ecma)script/i,
      rscriptTypeMasked = /^true\/(.*)/,
      rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
      wrapMap = {
        option: [1, "<select multiple='multiple'>", "</select>"],
        thead: [1, "<table>", "</table>"],
        col: [2, "<table><colgroup>", "</colgroup></table>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
        _default: [0, "", ""]
      };
  wrapMap.optgroup = wrapMap.option;
  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td;
  function manipulationTarget(elem, content) {
    return jQuery.nodeName(elem, "table") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem;
  }
  function disableScript(elem) {
    elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
    return elem;
  }
  function restoreScript(elem) {
    var match = rscriptTypeMasked.exec(elem.type);
    if (match) {
      elem.type = match[1];
    } else {
      elem.removeAttribute("type");
    }
    return elem;
  }
  function setGlobalEval(elems, refElements) {
    var i = 0,
        l = elems.length;
    for (; i < l; i++) {
      data_priv.set(elems[i], "globalEval", !refElements || data_priv.get(refElements[i], "globalEval"));
    }
  }
  function cloneCopyEvent(src, dest) {
    var i,
        l,
        type,
        pdataOld,
        pdataCur,
        udataOld,
        udataCur,
        events;
    if (dest.nodeType !== 1) {
      return;
    }
    if (data_priv.hasData(src)) {
      pdataOld = data_priv.access(src);
      pdataCur = data_priv.set(dest, pdataOld);
      events = pdataOld.events;
      if (events) {
        delete pdataCur.handle;
        pdataCur.events = {};
        for (type in events) {
          for (i = 0, l = events[type].length; i < l; i++) {
            jQuery.event.add(dest, type, events[type][i]);
          }
        }
      }
    }
    if (data_user.hasData(src)) {
      udataOld = data_user.access(src);
      udataCur = jQuery.extend({}, udataOld);
      data_user.set(dest, udataCur);
    }
  }
  function getAll(context, tag) {
    var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || "*") : context.querySelectorAll ? context.querySelectorAll(tag || "*") : [];
    return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret;
  }
  function fixInput(src, dest) {
    var nodeName = dest.nodeName.toLowerCase();
    if (nodeName === "input" && rcheckableType.test(src.type)) {
      dest.checked = src.checked;
    } else if (nodeName === "input" || nodeName === "textarea") {
      dest.defaultValue = src.defaultValue;
    }
  }
  jQuery.extend({
    clone: function(elem, dataAndEvents, deepDataAndEvents) {
      var i,
          l,
          srcElements,
          destElements,
          clone = elem.cloneNode(true),
          inPage = jQuery.contains(elem.ownerDocument, elem);
      if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
        destElements = getAll(clone);
        srcElements = getAll(elem);
        for (i = 0, l = srcElements.length; i < l; i++) {
          fixInput(srcElements[i], destElements[i]);
        }
      }
      if (dataAndEvents) {
        if (deepDataAndEvents) {
          srcElements = srcElements || getAll(elem);
          destElements = destElements || getAll(clone);
          for (i = 0, l = srcElements.length; i < l; i++) {
            cloneCopyEvent(srcElements[i], destElements[i]);
          }
        } else {
          cloneCopyEvent(elem, clone);
        }
      }
      destElements = getAll(clone, "script");
      if (destElements.length > 0) {
        setGlobalEval(destElements, !inPage && getAll(elem, "script"));
      }
      return clone;
    },
    buildFragment: function(elems, context, scripts, selection) {
      var elem,
          tmp,
          tag,
          wrap,
          contains,
          j,
          fragment = context.createDocumentFragment(),
          nodes = [],
          i = 0,
          l = elems.length;
      for (; i < l; i++) {
        elem = elems[i];
        if (elem || elem === 0) {
          if (jQuery.type(elem) === "object") {
            jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
          } else if (!rhtml.test(elem)) {
            nodes.push(context.createTextNode(elem));
          } else {
            tmp = tmp || fragment.appendChild(context.createElement("div"));
            tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
            wrap = wrapMap[tag] || wrapMap._default;
            tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2];
            j = wrap[0];
            while (j--) {
              tmp = tmp.lastChild;
            }
            jQuery.merge(nodes, tmp.childNodes);
            tmp = fragment.firstChild;
            tmp.textContent = "";
          }
        }
      }
      fragment.textContent = "";
      i = 0;
      while ((elem = nodes[i++])) {
        if (selection && jQuery.inArray(elem, selection) !== -1) {
          continue;
        }
        contains = jQuery.contains(elem.ownerDocument, elem);
        tmp = getAll(fragment.appendChild(elem), "script");
        if (contains) {
          setGlobalEval(tmp);
        }
        if (scripts) {
          j = 0;
          while ((elem = tmp[j++])) {
            if (rscriptType.test(elem.type || "")) {
              scripts.push(elem);
            }
          }
        }
      }
      return fragment;
    },
    cleanData: function(elems) {
      var data,
          elem,
          type,
          key,
          special = jQuery.event.special,
          i = 0;
      for (; (elem = elems[i]) !== undefined; i++) {
        if (jQuery.acceptData(elem)) {
          key = elem[data_priv.expando];
          if (key && (data = data_priv.cache[key])) {
            if (data.events) {
              for (type in data.events) {
                if (special[type]) {
                  jQuery.event.remove(elem, type);
                } else {
                  jQuery.removeEvent(elem, type, data.handle);
                }
              }
            }
            if (data_priv.cache[key]) {
              delete data_priv.cache[key];
            }
          }
        }
        delete data_user.cache[elem[data_user.expando]];
      }
    }
  });
  jQuery.fn.extend({
    text: function(value) {
      return access(this, function(value) {
        return value === undefined ? jQuery.text(this) : this.empty().each(function() {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            this.textContent = value;
          }
        });
      }, null, value, arguments.length);
    },
    append: function() {
      return this.domManip(arguments, function(elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.appendChild(elem);
        }
      });
    },
    prepend: function() {
      return this.domManip(arguments, function(elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.insertBefore(elem, target.firstChild);
        }
      });
    },
    before: function() {
      return this.domManip(arguments, function(elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this);
        }
      });
    },
    after: function() {
      return this.domManip(arguments, function(elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this.nextSibling);
        }
      });
    },
    remove: function(selector, keepData) {
      var elem,
          elems = selector ? jQuery.filter(selector, this) : this,
          i = 0;
      for (; (elem = elems[i]) != null; i++) {
        if (!keepData && elem.nodeType === 1) {
          jQuery.cleanData(getAll(elem));
        }
        if (elem.parentNode) {
          if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
            setGlobalEval(getAll(elem, "script"));
          }
          elem.parentNode.removeChild(elem);
        }
      }
      return this;
    },
    empty: function() {
      var elem,
          i = 0;
      for (; (elem = this[i]) != null; i++) {
        if (elem.nodeType === 1) {
          jQuery.cleanData(getAll(elem, false));
          elem.textContent = "";
        }
      }
      return this;
    },
    clone: function(dataAndEvents, deepDataAndEvents) {
      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
      return this.map(function() {
        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
      });
    },
    html: function(value) {
      return access(this, function(value) {
        var elem = this[0] || {},
            i = 0,
            l = this.length;
        if (value === undefined && elem.nodeType === 1) {
          return elem.innerHTML;
        }
        if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
          value = value.replace(rxhtmlTag, "<$1></$2>");
          try {
            for (; i < l; i++) {
              elem = this[i] || {};
              if (elem.nodeType === 1) {
                jQuery.cleanData(getAll(elem, false));
                elem.innerHTML = value;
              }
            }
            elem = 0;
          } catch (e) {}
        }
        if (elem) {
          this.empty().append(value);
        }
      }, null, value, arguments.length);
    },
    replaceWith: function() {
      var arg = arguments[0];
      this.domManip(arguments, function(elem) {
        arg = this.parentNode;
        jQuery.cleanData(getAll(this));
        if (arg) {
          arg.replaceChild(elem, this);
        }
      });
      return arg && (arg.length || arg.nodeType) ? this : this.remove();
    },
    detach: function(selector) {
      return this.remove(selector, true);
    },
    domManip: function(args, callback) {
      args = concat.apply([], args);
      var fragment,
          first,
          scripts,
          hasScripts,
          node,
          doc,
          i = 0,
          l = this.length,
          set = this,
          iNoClone = l - 1,
          value = args[0],
          isFunction = jQuery.isFunction(value);
      if (isFunction || (l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value))) {
        return this.each(function(index) {
          var self = set.eq(index);
          if (isFunction) {
            args[0] = value.call(this, index, self.html());
          }
          self.domManip(args, callback);
        });
      }
      if (l) {
        fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this);
        first = fragment.firstChild;
        if (fragment.childNodes.length === 1) {
          fragment = first;
        }
        if (first) {
          scripts = jQuery.map(getAll(fragment, "script"), disableScript);
          hasScripts = scripts.length;
          for (; i < l; i++) {
            node = fragment;
            if (i !== iNoClone) {
              node = jQuery.clone(node, true, true);
              if (hasScripts) {
                jQuery.merge(scripts, getAll(node, "script"));
              }
            }
            callback.call(this[i], node, i);
          }
          if (hasScripts) {
            doc = scripts[scripts.length - 1].ownerDocument;
            jQuery.map(scripts, restoreScript);
            for (i = 0; i < hasScripts; i++) {
              node = scripts[i];
              if (rscriptType.test(node.type || "") && !data_priv.access(node, "globalEval") && jQuery.contains(doc, node)) {
                if (node.src) {
                  if (jQuery._evalUrl) {
                    jQuery._evalUrl(node.src);
                  }
                } else {
                  jQuery.globalEval(node.textContent.replace(rcleanScript, ""));
                }
              }
            }
          }
        }
      }
      return this;
    }
  });
  jQuery.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function(name, original) {
    jQuery.fn[name] = function(selector) {
      var elems,
          ret = [],
          insert = jQuery(selector),
          last = insert.length - 1,
          i = 0;
      for (; i <= last; i++) {
        elems = i === last ? this : this.clone(true);
        jQuery(insert[i])[original](elems);
        push.apply(ret, elems.get());
      }
      return this.pushStack(ret);
    };
  });
  var iframe,
      elemdisplay = {};
  function actualDisplay(name, doc) {
    var style,
        elem = jQuery(doc.createElement(name)).appendTo(doc.body),
        display = window.getDefaultComputedStyle && (style = window.getDefaultComputedStyle(elem[0])) ? style.display : jQuery.css(elem[0], "display");
    elem.detach();
    return display;
  }
  function defaultDisplay(nodeName) {
    var doc = document,
        display = elemdisplay[nodeName];
    if (!display) {
      display = actualDisplay(nodeName, doc);
      if (display === "none" || !display) {
        iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement);
        doc = iframe[0].contentDocument;
        doc.write();
        doc.close();
        display = actualDisplay(nodeName, doc);
        iframe.detach();
      }
      elemdisplay[nodeName] = display;
    }
    return display;
  }
  var rmargin = (/^margin/);
  var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
  var getStyles = function(elem) {
    if (elem.ownerDocument.defaultView.opener) {
      return elem.ownerDocument.defaultView.getComputedStyle(elem, null);
    }
    return window.getComputedStyle(elem, null);
  };
  function curCSS(elem, name, computed) {
    var width,
        minWidth,
        maxWidth,
        ret,
        style = elem.style;
    computed = computed || getStyles(elem);
    if (computed) {
      ret = computed.getPropertyValue(name) || computed[name];
    }
    if (computed) {
      if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
        ret = jQuery.style(elem, name);
      }
      if (rnumnonpx.test(ret) && rmargin.test(name)) {
        width = style.width;
        minWidth = style.minWidth;
        maxWidth = style.maxWidth;
        style.minWidth = style.maxWidth = style.width = ret;
        ret = computed.width;
        style.width = width;
        style.minWidth = minWidth;
        style.maxWidth = maxWidth;
      }
    }
    return ret !== undefined ? ret + "" : ret;
  }
  function addGetHookIf(conditionFn, hookFn) {
    return {get: function() {
        if (conditionFn()) {
          delete this.get;
          return;
        }
        return (this.get = hookFn).apply(this, arguments);
      }};
  }
  (function() {
    var pixelPositionVal,
        boxSizingReliableVal,
        docElem = document.documentElement,
        container = document.createElement("div"),
        div = document.createElement("div");
    if (!div.style) {
      return;
    }
    div.style.backgroundClip = "content-box";
    div.cloneNode(true).style.backgroundClip = "";
    support.clearCloneStyle = div.style.backgroundClip === "content-box";
    container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" + "position:absolute";
    container.appendChild(div);
    function computePixelPositionAndBoxSizingReliable() {
      div.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" + "box-sizing:border-box;display:block;margin-top:1%;top:1%;" + "border:1px;padding:1px;width:4px;position:absolute";
      div.innerHTML = "";
      docElem.appendChild(container);
      var divStyle = window.getComputedStyle(div, null);
      pixelPositionVal = divStyle.top !== "1%";
      boxSizingReliableVal = divStyle.width === "4px";
      docElem.removeChild(container);
    }
    if (window.getComputedStyle) {
      jQuery.extend(support, {
        pixelPosition: function() {
          computePixelPositionAndBoxSizingReliable();
          return pixelPositionVal;
        },
        boxSizingReliable: function() {
          if (boxSizingReliableVal == null) {
            computePixelPositionAndBoxSizingReliable();
          }
          return boxSizingReliableVal;
        },
        reliableMarginRight: function() {
          var ret,
              marginDiv = div.appendChild(document.createElement("div"));
          marginDiv.style.cssText = div.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" + "box-sizing:content-box;display:block;margin:0;border:0;padding:0";
          marginDiv.style.marginRight = marginDiv.style.width = "0";
          div.style.width = "1px";
          docElem.appendChild(container);
          ret = !parseFloat(window.getComputedStyle(marginDiv, null).marginRight);
          docElem.removeChild(container);
          div.removeChild(marginDiv);
          return ret;
        }
      });
    }
  })();
  jQuery.swap = function(elem, options, callback, args) {
    var ret,
        name,
        old = {};
    for (name in options) {
      old[name] = elem.style[name];
      elem.style[name] = options[name];
    }
    ret = callback.apply(elem, args || []);
    for (name in options) {
      elem.style[name] = old[name];
    }
    return ret;
  };
  var rdisplayswap = /^(none|table(?!-c[ea]).+)/,
      rnumsplit = new RegExp("^(" + pnum + ")(.*)$", "i"),
      rrelNum = new RegExp("^([+-])=(" + pnum + ")", "i"),
      cssShow = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
      },
      cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
      },
      cssPrefixes = ["Webkit", "O", "Moz", "ms"];
  function vendorPropName(style, name) {
    if (name in style) {
      return name;
    }
    var capName = name[0].toUpperCase() + name.slice(1),
        origName = name,
        i = cssPrefixes.length;
    while (i--) {
      name = cssPrefixes[i] + capName;
      if (name in style) {
        return name;
      }
    }
    return origName;
  }
  function setPositiveNumber(elem, value, subtract) {
    var matches = rnumsplit.exec(value);
    return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px") : value;
  }
  function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
    var i = extra === (isBorderBox ? "border" : "content") ? 4 : name === "width" ? 1 : 0,
        val = 0;
    for (; i < 4; i += 2) {
      if (extra === "margin") {
        val += jQuery.css(elem, extra + cssExpand[i], true, styles);
      }
      if (isBorderBox) {
        if (extra === "content") {
          val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        }
        if (extra !== "margin") {
          val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      } else {
        val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        if (extra !== "padding") {
          val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      }
    }
    return val;
  }
  function getWidthOrHeight(elem, name, extra) {
    var valueIsBorderBox = true,
        val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
        styles = getStyles(elem),
        isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
    if (val <= 0 || val == null) {
      val = curCSS(elem, name, styles);
      if (val < 0 || val == null) {
        val = elem.style[name];
      }
      if (rnumnonpx.test(val)) {
        return val;
      }
      valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);
      val = parseFloat(val) || 0;
    }
    return (val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles)) + "px";
  }
  function showHide(elements, show) {
    var display,
        elem,
        hidden,
        values = [],
        index = 0,
        length = elements.length;
    for (; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      values[index] = data_priv.get(elem, "olddisplay");
      display = elem.style.display;
      if (show) {
        if (!values[index] && display === "none") {
          elem.style.display = "";
        }
        if (elem.style.display === "" && isHidden(elem)) {
          values[index] = data_priv.access(elem, "olddisplay", defaultDisplay(elem.nodeName));
        }
      } else {
        hidden = isHidden(elem);
        if (display !== "none" || !hidden) {
          data_priv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
        }
      }
    }
    for (index = 0; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      if (!show || elem.style.display === "none" || elem.style.display === "") {
        elem.style.display = show ? values[index] || "" : "none";
      }
    }
    return elements;
  }
  jQuery.extend({
    cssHooks: {opacity: {get: function(elem, computed) {
          if (computed) {
            var ret = curCSS(elem, "opacity");
            return ret === "" ? "1" : ret;
          }
        }}},
    cssNumber: {
      "columnCount": true,
      "fillOpacity": true,
      "flexGrow": true,
      "flexShrink": true,
      "fontWeight": true,
      "lineHeight": true,
      "opacity": true,
      "order": true,
      "orphans": true,
      "widows": true,
      "zIndex": true,
      "zoom": true
    },
    cssProps: {"float": "cssFloat"},
    style: function(elem, name, value, extra) {
      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
        return;
      }
      var ret,
          type,
          hooks,
          origName = jQuery.camelCase(name),
          style = elem.style;
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      if (value !== undefined) {
        type = typeof value;
        if (type === "string" && (ret = rrelNum.exec(value))) {
          value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
          type = "number";
        }
        if (value == null || value !== value) {
          return;
        }
        if (type === "number" && !jQuery.cssNumber[origName]) {
          value += "px";
        }
        if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
          style[name] = "inherit";
        }
        if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
          style[name] = value;
        }
      } else {
        if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
          return ret;
        }
        return style[name];
      }
    },
    css: function(elem, name, extra, styles) {
      var val,
          num,
          hooks,
          origName = jQuery.camelCase(name);
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      if (hooks && "get" in hooks) {
        val = hooks.get(elem, true, extra);
      }
      if (val === undefined) {
        val = curCSS(elem, name, styles);
      }
      if (val === "normal" && name in cssNormalTransform) {
        val = cssNormalTransform[name];
      }
      if (extra === "" || extra) {
        num = parseFloat(val);
        return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
      }
      return val;
    }
  });
  jQuery.each(["height", "width"], function(i, name) {
    jQuery.cssHooks[name] = {
      get: function(elem, computed, extra) {
        if (computed) {
          return rdisplayswap.test(jQuery.css(elem, "display")) && elem.offsetWidth === 0 ? jQuery.swap(elem, cssShow, function() {
            return getWidthOrHeight(elem, name, extra);
          }) : getWidthOrHeight(elem, name, extra);
        }
      },
      set: function(elem, value, extra) {
        var styles = extra && getStyles(elem);
        return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles) : 0);
      }
    };
  });
  jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function(elem, computed) {
    if (computed) {
      return jQuery.swap(elem, {"display": "inline-block"}, curCSS, [elem, "marginRight"]);
    }
  });
  jQuery.each({
    margin: "",
    padding: "",
    border: "Width"
  }, function(prefix, suffix) {
    jQuery.cssHooks[prefix + suffix] = {expand: function(value) {
        var i = 0,
            expanded = {},
            parts = typeof value === "string" ? value.split(" ") : [value];
        for (; i < 4; i++) {
          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
        }
        return expanded;
      }};
    if (!rmargin.test(prefix)) {
      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
    }
  });
  jQuery.fn.extend({
    css: function(name, value) {
      return access(this, function(elem, name, value) {
        var styles,
            len,
            map = {},
            i = 0;
        if (jQuery.isArray(name)) {
          styles = getStyles(elem);
          len = name.length;
          for (; i < len; i++) {
            map[name[i]] = jQuery.css(elem, name[i], false, styles);
          }
          return map;
        }
        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
      }, name, value, arguments.length > 1);
    },
    show: function() {
      return showHide(this, true);
    },
    hide: function() {
      return showHide(this);
    },
    toggle: function(state) {
      if (typeof state === "boolean") {
        return state ? this.show() : this.hide();
      }
      return this.each(function() {
        if (isHidden(this)) {
          jQuery(this).show();
        } else {
          jQuery(this).hide();
        }
      });
    }
  });
  function Tween(elem, options, prop, end, easing) {
    return new Tween.prototype.init(elem, options, prop, end, easing);
  }
  jQuery.Tween = Tween;
  Tween.prototype = {
    constructor: Tween,
    init: function(elem, options, prop, end, easing, unit) {
      this.elem = elem;
      this.prop = prop;
      this.easing = easing || "swing";
      this.options = options;
      this.start = this.now = this.cur();
      this.end = end;
      this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
    },
    cur: function() {
      var hooks = Tween.propHooks[this.prop];
      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
    },
    run: function(percent) {
      var eased,
          hooks = Tween.propHooks[this.prop];
      if (this.options.duration) {
        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
      } else {
        this.pos = eased = percent;
      }
      this.now = (this.end - this.start) * eased + this.start;
      if (this.options.step) {
        this.options.step.call(this.elem, this.now, this);
      }
      if (hooks && hooks.set) {
        hooks.set(this);
      } else {
        Tween.propHooks._default.set(this);
      }
      return this;
    }
  };
  Tween.prototype.init.prototype = Tween.prototype;
  Tween.propHooks = {_default: {
      get: function(tween) {
        var result;
        if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
          return tween.elem[tween.prop];
        }
        result = jQuery.css(tween.elem, tween.prop, "");
        return !result || result === "auto" ? 0 : result;
      },
      set: function(tween) {
        if (jQuery.fx.step[tween.prop]) {
          jQuery.fx.step[tween.prop](tween);
        } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
        } else {
          tween.elem[tween.prop] = tween.now;
        }
      }
    }};
  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {set: function(tween) {
      if (tween.elem.nodeType && tween.elem.parentNode) {
        tween.elem[tween.prop] = tween.now;
      }
    }};
  jQuery.easing = {
    linear: function(p) {
      return p;
    },
    swing: function(p) {
      return 0.5 - Math.cos(p * Math.PI) / 2;
    }
  };
  jQuery.fx = Tween.prototype.init;
  jQuery.fx.step = {};
  var fxNow,
      timerId,
      rfxtypes = /^(?:toggle|show|hide)$/,
      rfxnum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i"),
      rrun = /queueHooks$/,
      animationPrefilters = [defaultPrefilter],
      tweeners = {"*": [function(prop, value) {
          var tween = this.createTween(prop, value),
              target = tween.cur(),
              parts = rfxnum.exec(value),
              unit = parts && parts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
              start = (jQuery.cssNumber[prop] || unit !== "px" && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)),
              scale = 1,
              maxIterations = 20;
          if (start && start[3] !== unit) {
            unit = unit || start[3];
            parts = parts || [];
            start = +target || 1;
            do {
              scale = scale || ".5";
              start = start / scale;
              jQuery.style(tween.elem, prop, start + unit);
            } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
          }
          if (parts) {
            start = tween.start = +start || +target || 0;
            tween.unit = unit;
            tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2];
          }
          return tween;
        }]};
  function createFxNow() {
    setTimeout(function() {
      fxNow = undefined;
    });
    return (fxNow = jQuery.now());
  }
  function genFx(type, includeWidth) {
    var which,
        i = 0,
        attrs = {height: type};
    includeWidth = includeWidth ? 1 : 0;
    for (; i < 4; i += 2 - includeWidth) {
      which = cssExpand[i];
      attrs["margin" + which] = attrs["padding" + which] = type;
    }
    if (includeWidth) {
      attrs.opacity = attrs.width = type;
    }
    return attrs;
  }
  function createTween(value, prop, animation) {
    var tween,
        collection = (tweeners[prop] || []).concat(tweeners["*"]),
        index = 0,
        length = collection.length;
    for (; index < length; index++) {
      if ((tween = collection[index].call(animation, prop, value))) {
        return tween;
      }
    }
  }
  function defaultPrefilter(elem, props, opts) {
    var prop,
        value,
        toggle,
        tween,
        hooks,
        oldfire,
        display,
        checkDisplay,
        anim = this,
        orig = {},
        style = elem.style,
        hidden = elem.nodeType && isHidden(elem),
        dataShow = data_priv.get(elem, "fxshow");
    if (!opts.queue) {
      hooks = jQuery._queueHooks(elem, "fx");
      if (hooks.unqueued == null) {
        hooks.unqueued = 0;
        oldfire = hooks.empty.fire;
        hooks.empty.fire = function() {
          if (!hooks.unqueued) {
            oldfire();
          }
        };
      }
      hooks.unqueued++;
      anim.always(function() {
        anim.always(function() {
          hooks.unqueued--;
          if (!jQuery.queue(elem, "fx").length) {
            hooks.empty.fire();
          }
        });
      });
    }
    if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
      opts.overflow = [style.overflow, style.overflowX, style.overflowY];
      display = jQuery.css(elem, "display");
      checkDisplay = display === "none" ? data_priv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;
      if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {
        style.display = "inline-block";
      }
    }
    if (opts.overflow) {
      style.overflow = "hidden";
      anim.always(function() {
        style.overflow = opts.overflow[0];
        style.overflowX = opts.overflow[1];
        style.overflowY = opts.overflow[2];
      });
    }
    for (prop in props) {
      value = props[prop];
      if (rfxtypes.exec(value)) {
        delete props[prop];
        toggle = toggle || value === "toggle";
        if (value === (hidden ? "hide" : "show")) {
          if (value === "show" && dataShow && dataShow[prop] !== undefined) {
            hidden = true;
          } else {
            continue;
          }
        }
        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
      } else {
        display = undefined;
      }
    }
    if (!jQuery.isEmptyObject(orig)) {
      if (dataShow) {
        if ("hidden" in dataShow) {
          hidden = dataShow.hidden;
        }
      } else {
        dataShow = data_priv.access(elem, "fxshow", {});
      }
      if (toggle) {
        dataShow.hidden = !hidden;
      }
      if (hidden) {
        jQuery(elem).show();
      } else {
        anim.done(function() {
          jQuery(elem).hide();
        });
      }
      anim.done(function() {
        var prop;
        data_priv.remove(elem, "fxshow");
        for (prop in orig) {
          jQuery.style(elem, prop, orig[prop]);
        }
      });
      for (prop in orig) {
        tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
        if (!(prop in dataShow)) {
          dataShow[prop] = tween.start;
          if (hidden) {
            tween.end = tween.start;
            tween.start = prop === "width" || prop === "height" ? 1 : 0;
          }
        }
      }
    } else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
      style.display = display;
    }
  }
  function propFilter(props, specialEasing) {
    var index,
        name,
        easing,
        value,
        hooks;
    for (index in props) {
      name = jQuery.camelCase(index);
      easing = specialEasing[name];
      value = props[index];
      if (jQuery.isArray(value)) {
        easing = value[1];
        value = props[index] = value[0];
      }
      if (index !== name) {
        props[name] = value;
        delete props[index];
      }
      hooks = jQuery.cssHooks[name];
      if (hooks && "expand" in hooks) {
        value = hooks.expand(value);
        delete props[name];
        for (index in value) {
          if (!(index in props)) {
            props[index] = value[index];
            specialEasing[index] = easing;
          }
        }
      } else {
        specialEasing[name] = easing;
      }
    }
  }
  function Animation(elem, properties, options) {
    var result,
        stopped,
        index = 0,
        length = animationPrefilters.length,
        deferred = jQuery.Deferred().always(function() {
          delete tick.elem;
        }),
        tick = function() {
          if (stopped) {
            return false;
          }
          var currentTime = fxNow || createFxNow(),
              remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
              temp = remaining / animation.duration || 0,
              percent = 1 - temp,
              index = 0,
              length = animation.tweens.length;
          for (; index < length; index++) {
            animation.tweens[index].run(percent);
          }
          deferred.notifyWith(elem, [animation, percent, remaining]);
          if (percent < 1 && length) {
            return remaining;
          } else {
            deferred.resolveWith(elem, [animation]);
            return false;
          }
        },
        animation = deferred.promise({
          elem: elem,
          props: jQuery.extend({}, properties),
          opts: jQuery.extend(true, {specialEasing: {}}, options),
          originalProperties: properties,
          originalOptions: options,
          startTime: fxNow || createFxNow(),
          duration: options.duration,
          tweens: [],
          createTween: function(prop, end) {
            var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
            animation.tweens.push(tween);
            return tween;
          },
          stop: function(gotoEnd) {
            var index = 0,
                length = gotoEnd ? animation.tweens.length : 0;
            if (stopped) {
              return this;
            }
            stopped = true;
            for (; index < length; index++) {
              animation.tweens[index].run(1);
            }
            if (gotoEnd) {
              deferred.resolveWith(elem, [animation, gotoEnd]);
            } else {
              deferred.rejectWith(elem, [animation, gotoEnd]);
            }
            return this;
          }
        }),
        props = animation.props;
    propFilter(props, animation.opts.specialEasing);
    for (; index < length; index++) {
      result = animationPrefilters[index].call(animation, elem, props, animation.opts);
      if (result) {
        return result;
      }
    }
    jQuery.map(props, createTween, animation);
    if (jQuery.isFunction(animation.opts.start)) {
      animation.opts.start.call(elem, animation);
    }
    jQuery.fx.timer(jQuery.extend(tick, {
      elem: elem,
      anim: animation,
      queue: animation.opts.queue
    }));
    return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
  }
  jQuery.Animation = jQuery.extend(Animation, {
    tweener: function(props, callback) {
      if (jQuery.isFunction(props)) {
        callback = props;
        props = ["*"];
      } else {
        props = props.split(" ");
      }
      var prop,
          index = 0,
          length = props.length;
      for (; index < length; index++) {
        prop = props[index];
        tweeners[prop] = tweeners[prop] || [];
        tweeners[prop].unshift(callback);
      }
    },
    prefilter: function(callback, prepend) {
      if (prepend) {
        animationPrefilters.unshift(callback);
      } else {
        animationPrefilters.push(callback);
      }
    }
  });
  jQuery.speed = function(speed, easing, fn) {
    var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
      complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
      duration: speed,
      easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
    };
    opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
    if (opt.queue == null || opt.queue === true) {
      opt.queue = "fx";
    }
    opt.old = opt.complete;
    opt.complete = function() {
      if (jQuery.isFunction(opt.old)) {
        opt.old.call(this);
      }
      if (opt.queue) {
        jQuery.dequeue(this, opt.queue);
      }
    };
    return opt;
  };
  jQuery.fn.extend({
    fadeTo: function(speed, to, easing, callback) {
      return this.filter(isHidden).css("opacity", 0).show().end().animate({opacity: to}, speed, easing, callback);
    },
    animate: function(prop, speed, easing, callback) {
      var empty = jQuery.isEmptyObject(prop),
          optall = jQuery.speed(speed, easing, callback),
          doAnimation = function() {
            var anim = Animation(this, jQuery.extend({}, prop), optall);
            if (empty || data_priv.get(this, "finish")) {
              anim.stop(true);
            }
          };
      doAnimation.finish = doAnimation;
      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
    },
    stop: function(type, clearQueue, gotoEnd) {
      var stopQueue = function(hooks) {
        var stop = hooks.stop;
        delete hooks.stop;
        stop(gotoEnd);
      };
      if (typeof type !== "string") {
        gotoEnd = clearQueue;
        clearQueue = type;
        type = undefined;
      }
      if (clearQueue && type !== false) {
        this.queue(type || "fx", []);
      }
      return this.each(function() {
        var dequeue = true,
            index = type != null && type + "queueHooks",
            timers = jQuery.timers,
            data = data_priv.get(this);
        if (index) {
          if (data[index] && data[index].stop) {
            stopQueue(data[index]);
          }
        } else {
          for (index in data) {
            if (data[index] && data[index].stop && rrun.test(index)) {
              stopQueue(data[index]);
            }
          }
        }
        for (index = timers.length; index--; ) {
          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
            timers[index].anim.stop(gotoEnd);
            dequeue = false;
            timers.splice(index, 1);
          }
        }
        if (dequeue || !gotoEnd) {
          jQuery.dequeue(this, type);
        }
      });
    },
    finish: function(type) {
      if (type !== false) {
        type = type || "fx";
      }
      return this.each(function() {
        var index,
            data = data_priv.get(this),
            queue = data[type + "queue"],
            hooks = data[type + "queueHooks"],
            timers = jQuery.timers,
            length = queue ? queue.length : 0;
        data.finish = true;
        jQuery.queue(this, type, []);
        if (hooks && hooks.stop) {
          hooks.stop.call(this, true);
        }
        for (index = timers.length; index--; ) {
          if (timers[index].elem === this && timers[index].queue === type) {
            timers[index].anim.stop(true);
            timers.splice(index, 1);
          }
        }
        for (index = 0; index < length; index++) {
          if (queue[index] && queue[index].finish) {
            queue[index].finish.call(this);
          }
        }
        delete data.finish;
      });
    }
  });
  jQuery.each(["toggle", "show", "hide"], function(i, name) {
    var cssFn = jQuery.fn[name];
    jQuery.fn[name] = function(speed, easing, callback) {
      return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
    };
  });
  jQuery.each({
    slideDown: genFx("show"),
    slideUp: genFx("hide"),
    slideToggle: genFx("toggle"),
    fadeIn: {opacity: "show"},
    fadeOut: {opacity: "hide"},
    fadeToggle: {opacity: "toggle"}
  }, function(name, props) {
    jQuery.fn[name] = function(speed, easing, callback) {
      return this.animate(props, speed, easing, callback);
    };
  });
  jQuery.timers = [];
  jQuery.fx.tick = function() {
    var timer,
        i = 0,
        timers = jQuery.timers;
    fxNow = jQuery.now();
    for (; i < timers.length; i++) {
      timer = timers[i];
      if (!timer() && timers[i] === timer) {
        timers.splice(i--, 1);
      }
    }
    if (!timers.length) {
      jQuery.fx.stop();
    }
    fxNow = undefined;
  };
  jQuery.fx.timer = function(timer) {
    jQuery.timers.push(timer);
    if (timer()) {
      jQuery.fx.start();
    } else {
      jQuery.timers.pop();
    }
  };
  jQuery.fx.interval = 13;
  jQuery.fx.start = function() {
    if (!timerId) {
      timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
    }
  };
  jQuery.fx.stop = function() {
    clearInterval(timerId);
    timerId = null;
  };
  jQuery.fx.speeds = {
    slow: 600,
    fast: 200,
    _default: 400
  };
  jQuery.fn.delay = function(time, type) {
    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
    type = type || "fx";
    return this.queue(type, function(next, hooks) {
      var timeout = setTimeout(next, time);
      hooks.stop = function() {
        clearTimeout(timeout);
      };
    });
  };
  (function() {
    var input = document.createElement("input"),
        select = document.createElement("select"),
        opt = select.appendChild(document.createElement("option"));
    input.type = "checkbox";
    support.checkOn = input.value !== "";
    support.optSelected = opt.selected;
    select.disabled = true;
    support.optDisabled = !opt.disabled;
    input = document.createElement("input");
    input.value = "t";
    input.type = "radio";
    support.radioValue = input.value === "t";
  })();
  var nodeHook,
      boolHook,
      attrHandle = jQuery.expr.attrHandle;
  jQuery.fn.extend({
    attr: function(name, value) {
      return access(this, jQuery.attr, name, value, arguments.length > 1);
    },
    removeAttr: function(name) {
      return this.each(function() {
        jQuery.removeAttr(this, name);
      });
    }
  });
  jQuery.extend({
    attr: function(elem, name, value) {
      var hooks,
          ret,
          nType = elem.nodeType;
      if (!elem || nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      if (typeof elem.getAttribute === strundefined) {
        return jQuery.prop(elem, name, value);
      }
      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        name = name.toLowerCase();
        hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
      }
      if (value !== undefined) {
        if (value === null) {
          jQuery.removeAttr(elem, name);
        } else if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        } else {
          elem.setAttribute(name, value + "");
          return value;
        }
      } else if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      } else {
        ret = jQuery.find.attr(elem, name);
        return ret == null ? undefined : ret;
      }
    },
    removeAttr: function(elem, value) {
      var name,
          propName,
          i = 0,
          attrNames = value && value.match(rnotwhite);
      if (attrNames && elem.nodeType === 1) {
        while ((name = attrNames[i++])) {
          propName = jQuery.propFix[name] || name;
          if (jQuery.expr.match.bool.test(name)) {
            elem[propName] = false;
          }
          elem.removeAttribute(name);
        }
      }
    },
    attrHooks: {type: {set: function(elem, value) {
          if (!support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
            var val = elem.value;
            elem.setAttribute("type", value);
            if (val) {
              elem.value = val;
            }
            return value;
          }
        }}}
  });
  boolHook = {set: function(elem, value, name) {
      if (value === false) {
        jQuery.removeAttr(elem, name);
      } else {
        elem.setAttribute(name, name);
      }
      return name;
    }};
  jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
    var getter = attrHandle[name] || jQuery.find.attr;
    attrHandle[name] = function(elem, name, isXML) {
      var ret,
          handle;
      if (!isXML) {
        handle = attrHandle[name];
        attrHandle[name] = ret;
        ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
        attrHandle[name] = handle;
      }
      return ret;
    };
  });
  var rfocusable = /^(?:input|select|textarea|button)$/i;
  jQuery.fn.extend({
    prop: function(name, value) {
      return access(this, jQuery.prop, name, value, arguments.length > 1);
    },
    removeProp: function(name) {
      return this.each(function() {
        delete this[jQuery.propFix[name] || name];
      });
    }
  });
  jQuery.extend({
    propFix: {
      "for": "htmlFor",
      "class": "className"
    },
    prop: function(elem, name, value) {
      var ret,
          hooks,
          notxml,
          nType = elem.nodeType;
      if (!elem || nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      notxml = nType !== 1 || !jQuery.isXMLDoc(elem);
      if (notxml) {
        name = jQuery.propFix[name] || name;
        hooks = jQuery.propHooks[name];
      }
      if (value !== undefined) {
        return hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : (elem[name] = value);
      } else {
        return hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name];
      }
    },
    propHooks: {tabIndex: {get: function(elem) {
          return elem.hasAttribute("tabindex") || rfocusable.test(elem.nodeName) || elem.href ? elem.tabIndex : -1;
        }}}
  });
  if (!support.optSelected) {
    jQuery.propHooks.selected = {get: function(elem) {
        var parent = elem.parentNode;
        if (parent && parent.parentNode) {
          parent.parentNode.selectedIndex;
        }
        return null;
      }};
  }
  jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
    jQuery.propFix[this.toLowerCase()] = this;
  });
  var rclass = /[\t\r\n\f]/g;
  jQuery.fn.extend({
    addClass: function(value) {
      var classes,
          elem,
          cur,
          clazz,
          j,
          finalValue,
          proceed = typeof value === "string" && value,
          i = 0,
          len = this.length;
      if (jQuery.isFunction(value)) {
        return this.each(function(j) {
          jQuery(this).addClass(value.call(this, j, this.className));
        });
      }
      if (proceed) {
        classes = (value || "").match(rnotwhite) || [];
        for (; i < len; i++) {
          elem = this[i];
          cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : " ");
          if (cur) {
            j = 0;
            while ((clazz = classes[j++])) {
              if (cur.indexOf(" " + clazz + " ") < 0) {
                cur += clazz + " ";
              }
            }
            finalValue = jQuery.trim(cur);
            if (elem.className !== finalValue) {
              elem.className = finalValue;
            }
          }
        }
      }
      return this;
    },
    removeClass: function(value) {
      var classes,
          elem,
          cur,
          clazz,
          j,
          finalValue,
          proceed = arguments.length === 0 || typeof value === "string" && value,
          i = 0,
          len = this.length;
      if (jQuery.isFunction(value)) {
        return this.each(function(j) {
          jQuery(this).removeClass(value.call(this, j, this.className));
        });
      }
      if (proceed) {
        classes = (value || "").match(rnotwhite) || [];
        for (; i < len; i++) {
          elem = this[i];
          cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : "");
          if (cur) {
            j = 0;
            while ((clazz = classes[j++])) {
              while (cur.indexOf(" " + clazz + " ") >= 0) {
                cur = cur.replace(" " + clazz + " ", " ");
              }
            }
            finalValue = value ? jQuery.trim(cur) : "";
            if (elem.className !== finalValue) {
              elem.className = finalValue;
            }
          }
        }
      }
      return this;
    },
    toggleClass: function(value, stateVal) {
      var type = typeof value;
      if (typeof stateVal === "boolean" && type === "string") {
        return stateVal ? this.addClass(value) : this.removeClass(value);
      }
      if (jQuery.isFunction(value)) {
        return this.each(function(i) {
          jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
        });
      }
      return this.each(function() {
        if (type === "string") {
          var className,
              i = 0,
              self = jQuery(this),
              classNames = value.match(rnotwhite) || [];
          while ((className = classNames[i++])) {
            if (self.hasClass(className)) {
              self.removeClass(className);
            } else {
              self.addClass(className);
            }
          }
        } else if (type === strundefined || type === "boolean") {
          if (this.className) {
            data_priv.set(this, "__className__", this.className);
          }
          this.className = this.className || value === false ? "" : data_priv.get(this, "__className__") || "";
        }
      });
    },
    hasClass: function(selector) {
      var className = " " + selector + " ",
          i = 0,
          l = this.length;
      for (; i < l; i++) {
        if (this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) >= 0) {
          return true;
        }
      }
      return false;
    }
  });
  var rreturn = /\r/g;
  jQuery.fn.extend({val: function(value) {
      var hooks,
          ret,
          isFunction,
          elem = this[0];
      if (!arguments.length) {
        if (elem) {
          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
          if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
            return ret;
          }
          ret = elem.value;
          return typeof ret === "string" ? ret.replace(rreturn, "") : ret == null ? "" : ret;
        }
        return;
      }
      isFunction = jQuery.isFunction(value);
      return this.each(function(i) {
        var val;
        if (this.nodeType !== 1) {
          return;
        }
        if (isFunction) {
          val = value.call(this, i, jQuery(this).val());
        } else {
          val = value;
        }
        if (val == null) {
          val = "";
        } else if (typeof val === "number") {
          val += "";
        } else if (jQuery.isArray(val)) {
          val = jQuery.map(val, function(value) {
            return value == null ? "" : value + "";
          });
        }
        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
        if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
          this.value = val;
        }
      });
    }});
  jQuery.extend({valHooks: {
      option: {get: function(elem) {
          var val = jQuery.find.attr(elem, "value");
          return val != null ? val : jQuery.trim(jQuery.text(elem));
        }},
      select: {
        get: function(elem) {
          var value,
              option,
              options = elem.options,
              index = elem.selectedIndex,
              one = elem.type === "select-one" || index < 0,
              values = one ? null : [],
              max = one ? index + 1 : options.length,
              i = index < 0 ? max : one ? index : 0;
          for (; i < max; i++) {
            option = options[i];
            if ((option.selected || i === index) && (support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
              value = jQuery(option).val();
              if (one) {
                return value;
              }
              values.push(value);
            }
          }
          return values;
        },
        set: function(elem, value) {
          var optionSet,
              option,
              options = elem.options,
              values = jQuery.makeArray(value),
              i = options.length;
          while (i--) {
            option = options[i];
            if ((option.selected = jQuery.inArray(option.value, values) >= 0)) {
              optionSet = true;
            }
          }
          if (!optionSet) {
            elem.selectedIndex = -1;
          }
          return values;
        }
      }
    }});
  jQuery.each(["radio", "checkbox"], function() {
    jQuery.valHooks[this] = {set: function(elem, value) {
        if (jQuery.isArray(value)) {
          return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0);
        }
      }};
    if (!support.checkOn) {
      jQuery.valHooks[this].get = function(elem) {
        return elem.getAttribute("value") === null ? "on" : elem.value;
      };
    }
  });
  jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup error contextmenu").split(" "), function(i, name) {
    jQuery.fn[name] = function(data, fn) {
      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
    };
  });
  jQuery.fn.extend({
    hover: function(fnOver, fnOut) {
      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
    },
    bind: function(types, data, fn) {
      return this.on(types, null, data, fn);
    },
    unbind: function(types, fn) {
      return this.off(types, null, fn);
    },
    delegate: function(selector, types, data, fn) {
      return this.on(types, selector, data, fn);
    },
    undelegate: function(selector, types, fn) {
      return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
    }
  });
  var nonce = jQuery.now();
  var rquery = (/\?/);
  jQuery.parseJSON = function(data) {
    return JSON.parse(data + "");
  };
  jQuery.parseXML = function(data) {
    var xml,
        tmp;
    if (!data || typeof data !== "string") {
      return null;
    }
    try {
      tmp = new DOMParser();
      xml = tmp.parseFromString(data, "text/xml");
    } catch (e) {
      xml = undefined;
    }
    if (!xml || xml.getElementsByTagName("parsererror").length) {
      jQuery.error("Invalid XML: " + data);
    }
    return xml;
  };
  var rhash = /#.*$/,
      rts = /([?&])_=[^&]*/,
      rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
      rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
      rnoContent = /^(?:GET|HEAD)$/,
      rprotocol = /^\/\//,
      rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
      prefilters = {},
      transports = {},
      allTypes = "*/".concat("*"),
      ajaxLocation = window.location.href,
      ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];
  function addToPrefiltersOrTransports(structure) {
    return function(dataTypeExpression, func) {
      if (typeof dataTypeExpression !== "string") {
        func = dataTypeExpression;
        dataTypeExpression = "*";
      }
      var dataType,
          i = 0,
          dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
      if (jQuery.isFunction(func)) {
        while ((dataType = dataTypes[i++])) {
          if (dataType[0] === "+") {
            dataType = dataType.slice(1) || "*";
            (structure[dataType] = structure[dataType] || []).unshift(func);
          } else {
            (structure[dataType] = structure[dataType] || []).push(func);
          }
        }
      }
    };
  }
  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
    var inspected = {},
        seekingTransport = (structure === transports);
    function inspect(dataType) {
      var selected;
      inspected[dataType] = true;
      jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
        if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
          options.dataTypes.unshift(dataTypeOrTransport);
          inspect(dataTypeOrTransport);
          return false;
        } else if (seekingTransport) {
          return !(selected = dataTypeOrTransport);
        }
      });
      return selected;
    }
    return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
  }
  function ajaxExtend(target, src) {
    var key,
        deep,
        flatOptions = jQuery.ajaxSettings.flatOptions || {};
    for (key in src) {
      if (src[key] !== undefined) {
        (flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key];
      }
    }
    if (deep) {
      jQuery.extend(true, target, deep);
    }
    return target;
  }
  function ajaxHandleResponses(s, jqXHR, responses) {
    var ct,
        type,
        finalDataType,
        firstDataType,
        contents = s.contents,
        dataTypes = s.dataTypes;
    while (dataTypes[0] === "*") {
      dataTypes.shift();
      if (ct === undefined) {
        ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
      }
    }
    if (ct) {
      for (type in contents) {
        if (contents[type] && contents[type].test(ct)) {
          dataTypes.unshift(type);
          break;
        }
      }
    }
    if (dataTypes[0] in responses) {
      finalDataType = dataTypes[0];
    } else {
      for (type in responses) {
        if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
          finalDataType = type;
          break;
        }
        if (!firstDataType) {
          firstDataType = type;
        }
      }
      finalDataType = finalDataType || firstDataType;
    }
    if (finalDataType) {
      if (finalDataType !== dataTypes[0]) {
        dataTypes.unshift(finalDataType);
      }
      return responses[finalDataType];
    }
  }
  function ajaxConvert(s, response, jqXHR, isSuccess) {
    var conv2,
        current,
        conv,
        tmp,
        prev,
        converters = {},
        dataTypes = s.dataTypes.slice();
    if (dataTypes[1]) {
      for (conv in s.converters) {
        converters[conv.toLowerCase()] = s.converters[conv];
      }
    }
    current = dataTypes.shift();
    while (current) {
      if (s.responseFields[current]) {
        jqXHR[s.responseFields[current]] = response;
      }
      if (!prev && isSuccess && s.dataFilter) {
        response = s.dataFilter(response, s.dataType);
      }
      prev = current;
      current = dataTypes.shift();
      if (current) {
        if (current === "*") {
          current = prev;
        } else if (prev !== "*" && prev !== current) {
          conv = converters[prev + " " + current] || converters["* " + current];
          if (!conv) {
            for (conv2 in converters) {
              tmp = conv2.split(" ");
              if (tmp[1] === current) {
                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                if (conv) {
                  if (conv === true) {
                    conv = converters[conv2];
                  } else if (converters[conv2] !== true) {
                    current = tmp[0];
                    dataTypes.unshift(tmp[1]);
                  }
                  break;
                }
              }
            }
          }
          if (conv !== true) {
            if (conv && s["throws"]) {
              response = conv(response);
            } else {
              try {
                response = conv(response);
              } catch (e) {
                return {
                  state: "parsererror",
                  error: conv ? e : "No conversion from " + prev + " to " + current
                };
              }
            }
          }
        }
      }
    }
    return {
      state: "success",
      data: response
    };
  }
  jQuery.extend({
    active: 0,
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: ajaxLocation,
      type: "GET",
      isLocal: rlocalProtocol.test(ajaxLocParts[1]),
      global: true,
      processData: true,
      async: true,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",
      accepts: {
        "*": allTypes,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      },
      contents: {
        xml: /xml/,
        html: /html/,
        json: /json/
      },
      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
      },
      converters: {
        "* text": String,
        "text html": true,
        "text json": jQuery.parseJSON,
        "text xml": jQuery.parseXML
      },
      flatOptions: {
        url: true,
        context: true
      }
    },
    ajaxSetup: function(target, settings) {
      return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
    },
    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
    ajaxTransport: addToPrefiltersOrTransports(transports),
    ajax: function(url, options) {
      if (typeof url === "object") {
        options = url;
        url = undefined;
      }
      options = options || {};
      var transport,
          cacheURL,
          responseHeadersString,
          responseHeaders,
          timeoutTimer,
          parts,
          fireGlobals,
          i,
          s = jQuery.ajaxSetup({}, options),
          callbackContext = s.context || s,
          globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
          deferred = jQuery.Deferred(),
          completeDeferred = jQuery.Callbacks("once memory"),
          statusCode = s.statusCode || {},
          requestHeaders = {},
          requestHeadersNames = {},
          state = 0,
          strAbort = "canceled",
          jqXHR = {
            readyState: 0,
            getResponseHeader: function(key) {
              var match;
              if (state === 2) {
                if (!responseHeaders) {
                  responseHeaders = {};
                  while ((match = rheaders.exec(responseHeadersString))) {
                    responseHeaders[match[1].toLowerCase()] = match[2];
                  }
                }
                match = responseHeaders[key.toLowerCase()];
              }
              return match == null ? null : match;
            },
            getAllResponseHeaders: function() {
              return state === 2 ? responseHeadersString : null;
            },
            setRequestHeader: function(name, value) {
              var lname = name.toLowerCase();
              if (!state) {
                name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                requestHeaders[name] = value;
              }
              return this;
            },
            overrideMimeType: function(type) {
              if (!state) {
                s.mimeType = type;
              }
              return this;
            },
            statusCode: function(map) {
              var code;
              if (map) {
                if (state < 2) {
                  for (code in map) {
                    statusCode[code] = [statusCode[code], map[code]];
                  }
                } else {
                  jqXHR.always(map[jqXHR.status]);
                }
              }
              return this;
            },
            abort: function(statusText) {
              var finalText = statusText || strAbort;
              if (transport) {
                transport.abort(finalText);
              }
              done(0, finalText);
              return this;
            }
          };
      deferred.promise(jqXHR).complete = completeDeferred.add;
      jqXHR.success = jqXHR.done;
      jqXHR.error = jqXHR.fail;
      s.url = ((url || s.url || ajaxLocation) + "").replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//");
      s.type = options.method || options.type || s.method || s.type;
      s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [""];
      if (s.crossDomain == null) {
        parts = rurl.exec(s.url.toLowerCase());
        s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === "http:" ? "80" : "443")) !== (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? "80" : "443"))));
      }
      if (s.data && s.processData && typeof s.data !== "string") {
        s.data = jQuery.param(s.data, s.traditional);
      }
      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
      if (state === 2) {
        return jqXHR;
      }
      fireGlobals = jQuery.event && s.global;
      if (fireGlobals && jQuery.active++ === 0) {
        jQuery.event.trigger("ajaxStart");
      }
      s.type = s.type.toUpperCase();
      s.hasContent = !rnoContent.test(s.type);
      cacheURL = s.url;
      if (!s.hasContent) {
        if (s.data) {
          cacheURL = (s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data);
          delete s.data;
        }
        if (s.cache === false) {
          s.url = rts.test(cacheURL) ? cacheURL.replace(rts, "$1_=" + nonce++) : cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
        }
      }
      if (s.ifModified) {
        if (jQuery.lastModified[cacheURL]) {
          jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
        }
        if (jQuery.etag[cacheURL]) {
          jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
        }
      }
      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
        jqXHR.setRequestHeader("Content-Type", s.contentType);
      }
      jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
      for (i in s.headers) {
        jqXHR.setRequestHeader(i, s.headers[i]);
      }
      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
        return jqXHR.abort();
      }
      strAbort = "abort";
      for (i in {
        success: 1,
        error: 1,
        complete: 1
      }) {
        jqXHR[i](s[i]);
      }
      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
      if (!transport) {
        done(-1, "No Transport");
      } else {
        jqXHR.readyState = 1;
        if (fireGlobals) {
          globalEventContext.trigger("ajaxSend", [jqXHR, s]);
        }
        if (s.async && s.timeout > 0) {
          timeoutTimer = setTimeout(function() {
            jqXHR.abort("timeout");
          }, s.timeout);
        }
        try {
          state = 1;
          transport.send(requestHeaders, done);
        } catch (e) {
          if (state < 2) {
            done(-1, e);
          } else {
            throw e;
          }
        }
      }
      function done(status, nativeStatusText, responses, headers) {
        var isSuccess,
            success,
            error,
            response,
            modified,
            statusText = nativeStatusText;
        if (state === 2) {
          return;
        }
        state = 2;
        if (timeoutTimer) {
          clearTimeout(timeoutTimer);
        }
        transport = undefined;
        responseHeadersString = headers || "";
        jqXHR.readyState = status > 0 ? 4 : 0;
        isSuccess = status >= 200 && status < 300 || status === 304;
        if (responses) {
          response = ajaxHandleResponses(s, jqXHR, responses);
        }
        response = ajaxConvert(s, response, jqXHR, isSuccess);
        if (isSuccess) {
          if (s.ifModified) {
            modified = jqXHR.getResponseHeader("Last-Modified");
            if (modified) {
              jQuery.lastModified[cacheURL] = modified;
            }
            modified = jqXHR.getResponseHeader("etag");
            if (modified) {
              jQuery.etag[cacheURL] = modified;
            }
          }
          if (status === 204 || s.type === "HEAD") {
            statusText = "nocontent";
          } else if (status === 304) {
            statusText = "notmodified";
          } else {
            statusText = response.state;
            success = response.data;
            error = response.error;
            isSuccess = !error;
          }
        } else {
          error = statusText;
          if (status || !statusText) {
            statusText = "error";
            if (status < 0) {
              status = 0;
            }
          }
        }
        jqXHR.status = status;
        jqXHR.statusText = (nativeStatusText || statusText) + "";
        if (isSuccess) {
          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
        } else {
          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
        }
        jqXHR.statusCode(statusCode);
        statusCode = undefined;
        if (fireGlobals) {
          globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
        }
        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
        if (fireGlobals) {
          globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
          if (!(--jQuery.active)) {
            jQuery.event.trigger("ajaxStop");
          }
        }
      }
      return jqXHR;
    },
    getJSON: function(url, data, callback) {
      return jQuery.get(url, data, callback, "json");
    },
    getScript: function(url, callback) {
      return jQuery.get(url, undefined, callback, "script");
    }
  });
  jQuery.each(["get", "post"], function(i, method) {
    jQuery[method] = function(url, data, callback, type) {
      if (jQuery.isFunction(data)) {
        type = type || callback;
        callback = data;
        data = undefined;
      }
      return jQuery.ajax({
        url: url,
        type: method,
        dataType: type,
        data: data,
        success: callback
      });
    };
  });
  jQuery._evalUrl = function(url) {
    return jQuery.ajax({
      url: url,
      type: "GET",
      dataType: "script",
      async: false,
      global: false,
      "throws": true
    });
  };
  jQuery.fn.extend({
    wrapAll: function(html) {
      var wrap;
      if (jQuery.isFunction(html)) {
        return this.each(function(i) {
          jQuery(this).wrapAll(html.call(this, i));
        });
      }
      if (this[0]) {
        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
        if (this[0].parentNode) {
          wrap.insertBefore(this[0]);
        }
        wrap.map(function() {
          var elem = this;
          while (elem.firstElementChild) {
            elem = elem.firstElementChild;
          }
          return elem;
        }).append(this);
      }
      return this;
    },
    wrapInner: function(html) {
      if (jQuery.isFunction(html)) {
        return this.each(function(i) {
          jQuery(this).wrapInner(html.call(this, i));
        });
      }
      return this.each(function() {
        var self = jQuery(this),
            contents = self.contents();
        if (contents.length) {
          contents.wrapAll(html);
        } else {
          self.append(html);
        }
      });
    },
    wrap: function(html) {
      var isFunction = jQuery.isFunction(html);
      return this.each(function(i) {
        jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
      });
    },
    unwrap: function() {
      return this.parent().each(function() {
        if (!jQuery.nodeName(this, "body")) {
          jQuery(this).replaceWith(this.childNodes);
        }
      }).end();
    }
  });
  jQuery.expr.filters.hidden = function(elem) {
    return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
  };
  jQuery.expr.filters.visible = function(elem) {
    return !jQuery.expr.filters.hidden(elem);
  };
  var r20 = /%20/g,
      rbracket = /\[\]$/,
      rCRLF = /\r?\n/g,
      rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
      rsubmittable = /^(?:input|select|textarea|keygen)/i;
  function buildParams(prefix, obj, traditional, add) {
    var name;
    if (jQuery.isArray(obj)) {
      jQuery.each(obj, function(i, v) {
        if (traditional || rbracket.test(prefix)) {
          add(prefix, v);
        } else {
          buildParams(prefix + "[" + (typeof v === "object" ? i : "") + "]", v, traditional, add);
        }
      });
    } else if (!traditional && jQuery.type(obj) === "object") {
      for (name in obj) {
        buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
      }
    } else {
      add(prefix, obj);
    }
  }
  jQuery.param = function(a, traditional) {
    var prefix,
        s = [],
        add = function(key, value) {
          value = jQuery.isFunction(value) ? value() : (value == null ? "" : value);
          s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
        };
    if (traditional === undefined) {
      traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
    }
    if (jQuery.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
      jQuery.each(a, function() {
        add(this.name, this.value);
      });
    } else {
      for (prefix in a) {
        buildParams(prefix, a[prefix], traditional, add);
      }
    }
    return s.join("&").replace(r20, "+");
  };
  jQuery.fn.extend({
    serialize: function() {
      return jQuery.param(this.serializeArray());
    },
    serializeArray: function() {
      return this.map(function() {
        var elements = jQuery.prop(this, "elements");
        return elements ? jQuery.makeArray(elements) : this;
      }).filter(function() {
        var type = this.type;
        return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
      }).map(function(i, elem) {
        var val = jQuery(this).val();
        return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function(val) {
          return {
            name: elem.name,
            value: val.replace(rCRLF, "\r\n")
          };
        }) : {
          name: elem.name,
          value: val.replace(rCRLF, "\r\n")
        };
      }).get();
    }
  });
  jQuery.ajaxSettings.xhr = function() {
    try {
      return new XMLHttpRequest();
    } catch (e) {}
  };
  var xhrId = 0,
      xhrCallbacks = {},
      xhrSuccessStatus = {
        0: 200,
        1223: 204
      },
      xhrSupported = jQuery.ajaxSettings.xhr();
  if (window.attachEvent) {
    window.attachEvent("onunload", function() {
      for (var key in xhrCallbacks) {
        xhrCallbacks[key]();
      }
    });
  }
  support.cors = !!xhrSupported && ("withCredentials" in xhrSupported);
  support.ajax = xhrSupported = !!xhrSupported;
  jQuery.ajaxTransport(function(options) {
    var callback;
    if (support.cors || xhrSupported && !options.crossDomain) {
      return {
        send: function(headers, complete) {
          var i,
              xhr = options.xhr(),
              id = ++xhrId;
          xhr.open(options.type, options.url, options.async, options.username, options.password);
          if (options.xhrFields) {
            for (i in options.xhrFields) {
              xhr[i] = options.xhrFields[i];
            }
          }
          if (options.mimeType && xhr.overrideMimeType) {
            xhr.overrideMimeType(options.mimeType);
          }
          if (!options.crossDomain && !headers["X-Requested-With"]) {
            headers["X-Requested-With"] = "XMLHttpRequest";
          }
          for (i in headers) {
            xhr.setRequestHeader(i, headers[i]);
          }
          callback = function(type) {
            return function() {
              if (callback) {
                delete xhrCallbacks[id];
                callback = xhr.onload = xhr.onerror = null;
                if (type === "abort") {
                  xhr.abort();
                } else if (type === "error") {
                  complete(xhr.status, xhr.statusText);
                } else {
                  complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, typeof xhr.responseText === "string" ? {text: xhr.responseText} : undefined, xhr.getAllResponseHeaders());
                }
              }
            };
          };
          xhr.onload = callback();
          xhr.onerror = callback("error");
          callback = xhrCallbacks[id] = callback("abort");
          try {
            xhr.send(options.hasContent && options.data || null);
          } catch (e) {
            if (callback) {
              throw e;
            }
          }
        },
        abort: function() {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  jQuery.ajaxSetup({
    accepts: {script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},
    contents: {script: /(?:java|ecma)script/},
    converters: {"text script": function(text) {
        jQuery.globalEval(text);
        return text;
      }}
  });
  jQuery.ajaxPrefilter("script", function(s) {
    if (s.cache === undefined) {
      s.cache = false;
    }
    if (s.crossDomain) {
      s.type = "GET";
    }
  });
  jQuery.ajaxTransport("script", function(s) {
    if (s.crossDomain) {
      var script,
          callback;
      return {
        send: function(_, complete) {
          script = jQuery("<script>").prop({
            async: true,
            charset: s.scriptCharset,
            src: s.url
          }).on("load error", callback = function(evt) {
            script.remove();
            callback = null;
            if (evt) {
              complete(evt.type === "error" ? 404 : 200, evt.type);
            }
          });
          document.head.appendChild(script[0]);
        },
        abort: function() {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  var oldCallbacks = [],
      rjsonp = /(=)\?(?=&|$)|\?\?/;
  jQuery.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function() {
      var callback = oldCallbacks.pop() || (jQuery.expando + "_" + (nonce++));
      this[callback] = true;
      return callback;
    }
  });
  jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
    var callbackName,
        overwritten,
        responseContainer,
        jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && !(s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data");
    if (jsonProp || s.dataTypes[0] === "jsonp") {
      callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
      if (jsonProp) {
        s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
      } else if (s.jsonp !== false) {
        s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
      }
      s.converters["script json"] = function() {
        if (!responseContainer) {
          jQuery.error(callbackName + " was not called");
        }
        return responseContainer[0];
      };
      s.dataTypes[0] = "json";
      overwritten = window[callbackName];
      window[callbackName] = function() {
        responseContainer = arguments;
      };
      jqXHR.always(function() {
        window[callbackName] = overwritten;
        if (s[callbackName]) {
          s.jsonpCallback = originalSettings.jsonpCallback;
          oldCallbacks.push(callbackName);
        }
        if (responseContainer && jQuery.isFunction(overwritten)) {
          overwritten(responseContainer[0]);
        }
        responseContainer = overwritten = undefined;
      });
      return "script";
    }
  });
  jQuery.parseHTML = function(data, context, keepScripts) {
    if (!data || typeof data !== "string") {
      return null;
    }
    if (typeof context === "boolean") {
      keepScripts = context;
      context = false;
    }
    context = context || document;
    var parsed = rsingleTag.exec(data),
        scripts = !keepScripts && [];
    if (parsed) {
      return [context.createElement(parsed[1])];
    }
    parsed = jQuery.buildFragment([data], context, scripts);
    if (scripts && scripts.length) {
      jQuery(scripts).remove();
    }
    return jQuery.merge([], parsed.childNodes);
  };
  var _load = jQuery.fn.load;
  jQuery.fn.load = function(url, params, callback) {
    if (typeof url !== "string" && _load) {
      return _load.apply(this, arguments);
    }
    var selector,
        type,
        response,
        self = this,
        off = url.indexOf(" ");
    if (off >= 0) {
      selector = jQuery.trim(url.slice(off));
      url = url.slice(0, off);
    }
    if (jQuery.isFunction(params)) {
      callback = params;
      params = undefined;
    } else if (params && typeof params === "object") {
      type = "POST";
    }
    if (self.length > 0) {
      jQuery.ajax({
        url: url,
        type: type,
        dataType: "html",
        data: params
      }).done(function(responseText) {
        response = arguments;
        self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText);
      }).complete(callback && function(jqXHR, status) {
        self.each(callback, response || [jqXHR.responseText, status, jqXHR]);
      });
    }
    return this;
  };
  jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(i, type) {
    jQuery.fn[type] = function(fn) {
      return this.on(type, fn);
    };
  });
  jQuery.expr.filters.animated = function(elem) {
    return jQuery.grep(jQuery.timers, function(fn) {
      return elem === fn.elem;
    }).length;
  };
  var docElem = window.document.documentElement;
  function getWindow(elem) {
    return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
  }
  jQuery.offset = {setOffset: function(elem, options, i) {
      var curPosition,
          curLeft,
          curCSSTop,
          curTop,
          curOffset,
          curCSSLeft,
          calculatePosition,
          position = jQuery.css(elem, "position"),
          curElem = jQuery(elem),
          props = {};
      if (position === "static") {
        elem.style.position = "relative";
      }
      curOffset = curElem.offset();
      curCSSTop = jQuery.css(elem, "top");
      curCSSLeft = jQuery.css(elem, "left");
      calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
      if (calculatePosition) {
        curPosition = curElem.position();
        curTop = curPosition.top;
        curLeft = curPosition.left;
      } else {
        curTop = parseFloat(curCSSTop) || 0;
        curLeft = parseFloat(curCSSLeft) || 0;
      }
      if (jQuery.isFunction(options)) {
        options = options.call(elem, i, curOffset);
      }
      if (options.top != null) {
        props.top = (options.top - curOffset.top) + curTop;
      }
      if (options.left != null) {
        props.left = (options.left - curOffset.left) + curLeft;
      }
      if ("using" in options) {
        options.using.call(elem, props);
      } else {
        curElem.css(props);
      }
    }};
  jQuery.fn.extend({
    offset: function(options) {
      if (arguments.length) {
        return options === undefined ? this : this.each(function(i) {
          jQuery.offset.setOffset(this, options, i);
        });
      }
      var docElem,
          win,
          elem = this[0],
          box = {
            top: 0,
            left: 0
          },
          doc = elem && elem.ownerDocument;
      if (!doc) {
        return;
      }
      docElem = doc.documentElement;
      if (!jQuery.contains(docElem, elem)) {
        return box;
      }
      if (typeof elem.getBoundingClientRect !== strundefined) {
        box = elem.getBoundingClientRect();
      }
      win = getWindow(doc);
      return {
        top: box.top + win.pageYOffset - docElem.clientTop,
        left: box.left + win.pageXOffset - docElem.clientLeft
      };
    },
    position: function() {
      if (!this[0]) {
        return;
      }
      var offsetParent,
          offset,
          elem = this[0],
          parentOffset = {
            top: 0,
            left: 0
          };
      if (jQuery.css(elem, "position") === "fixed") {
        offset = elem.getBoundingClientRect();
      } else {
        offsetParent = this.offsetParent();
        offset = this.offset();
        if (!jQuery.nodeName(offsetParent[0], "html")) {
          parentOffset = offsetParent.offset();
        }
        parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
        parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
      }
      return {
        top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
        left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
      };
    },
    offsetParent: function() {
      return this.map(function() {
        var offsetParent = this.offsetParent || docElem;
        while (offsetParent && (!jQuery.nodeName(offsetParent, "html") && jQuery.css(offsetParent, "position") === "static")) {
          offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || docElem;
      });
    }
  });
  jQuery.each({
    scrollLeft: "pageXOffset",
    scrollTop: "pageYOffset"
  }, function(method, prop) {
    var top = "pageYOffset" === prop;
    jQuery.fn[method] = function(val) {
      return access(this, function(elem, method, val) {
        var win = getWindow(elem);
        if (val === undefined) {
          return win ? win[prop] : elem[method];
        }
        if (win) {
          win.scrollTo(!top ? val : window.pageXOffset, top ? val : window.pageYOffset);
        } else {
          elem[method] = val;
        }
      }, method, val, arguments.length, null);
    };
  });
  jQuery.each(["top", "left"], function(i, prop) {
    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
      if (computed) {
        computed = curCSS(elem, prop);
        return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
      }
    });
  });
  jQuery.each({
    Height: "height",
    Width: "width"
  }, function(name, type) {
    jQuery.each({
      padding: "inner" + name,
      content: type,
      "": "outer" + name
    }, function(defaultExtra, funcName) {
      jQuery.fn[funcName] = function(margin, value) {
        var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
            extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
        return access(this, function(elem, type, value) {
          var doc;
          if (jQuery.isWindow(elem)) {
            return elem.document.documentElement["client" + name];
          }
          if (elem.nodeType === 9) {
            doc = elem.documentElement;
            return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
          }
          return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
        }, type, chainable ? margin : undefined, chainable, null);
      };
    });
  });
  jQuery.fn.size = function() {
    return this.length;
  };
  jQuery.fn.andSelf = jQuery.fn.addBack;
  if (typeof define === "function" && define.amd) {
    define("github:components/jquery@2.1.4/jquery", [], function() {
      return jQuery;
    });
  }
  var _jQuery = window.jQuery,
      _$ = window.$;
  jQuery.noConflict = function(deep) {
    if (window.$ === jQuery) {
      window.$ = _$;
    }
    if (deep && window.jQuery === jQuery) {
      window.jQuery = _jQuery;
    }
    return jQuery;
  };
  if (typeof noGlobal === strundefined) {
    window.jQuery = window.$ = jQuery;
  }
  return jQuery;
}));

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("github:components/jquery@2.1.4", ["github:components/jquery@2.1.4/jquery"], function(main) {
  return main;
});

_removeDefine();
})();
System.registerDynamic("github:angular/bower-angular-route@1.4.8/angular-route", ["angular"], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {
    "format global";
    "deps angular";
    (function(window, angular, undefined) {
      'use strict';
      var ngRouteModule = angular.module('ngRoute', ['ng']).provider('$route', $RouteProvider),
          $routeMinErr = angular.$$minErr('ngRoute');
      function $RouteProvider() {
        function inherit(parent, extra) {
          return angular.extend(Object.create(parent), extra);
        }
        var routes = {};
        this.when = function(path, route) {
          var routeCopy = angular.copy(route);
          if (angular.isUndefined(routeCopy.reloadOnSearch)) {
            routeCopy.reloadOnSearch = true;
          }
          if (angular.isUndefined(routeCopy.caseInsensitiveMatch)) {
            routeCopy.caseInsensitiveMatch = this.caseInsensitiveMatch;
          }
          routes[path] = angular.extend(routeCopy, path && pathRegExp(path, routeCopy));
          if (path) {
            var redirectPath = (path[path.length - 1] == '/') ? path.substr(0, path.length - 1) : path + '/';
            routes[redirectPath] = angular.extend({redirectTo: path}, pathRegExp(redirectPath, routeCopy));
          }
          return this;
        };
        this.caseInsensitiveMatch = false;
        function pathRegExp(path, opts) {
          var insensitive = opts.caseInsensitiveMatch,
              ret = {
                originalPath: path,
                regexp: path
              },
              keys = ret.keys = [];
          path = path.replace(/([().])/g, '\\$1').replace(/(\/)?:(\w+)([\?\*])?/g, function(_, slash, key, option) {
            var optional = option === '?' ? option : null;
            var star = option === '*' ? option : null;
            keys.push({
              name: key,
              optional: !!optional
            });
            slash = slash || '';
            return '' + (optional ? '' : slash) + '(?:' + (optional ? slash : '') + (star && '(.+?)' || '([^/]+)') + (optional || '') + ')' + (optional || '');
          }).replace(/([\/$\*])/g, '\\$1');
          ret.regexp = new RegExp('^' + path + '$', insensitive ? 'i' : '');
          return ret;
        }
        this.otherwise = function(params) {
          if (typeof params === 'string') {
            params = {redirectTo: params};
          }
          this.when(null, params);
          return this;
        };
        this.$get = ['$rootScope', '$location', '$routeParams', '$q', '$injector', '$templateRequest', '$sce', function($rootScope, $location, $routeParams, $q, $injector, $templateRequest, $sce) {
          var forceReload = false,
              preparedRoute,
              preparedRouteIsUpdateOnly,
              $route = {
                routes: routes,
                reload: function() {
                  forceReload = true;
                  $rootScope.$evalAsync(function() {
                    prepareRoute();
                    commitRoute();
                  });
                },
                updateParams: function(newParams) {
                  if (this.current && this.current.$$route) {
                    newParams = angular.extend({}, this.current.params, newParams);
                    $location.path(interpolate(this.current.$$route.originalPath, newParams));
                    $location.search(newParams);
                  } else {
                    throw $routeMinErr('norout', 'Tried updating route when with no current route');
                  }
                }
              };
          $rootScope.$on('$locationChangeStart', prepareRoute);
          $rootScope.$on('$locationChangeSuccess', commitRoute);
          return $route;
          function switchRouteMatcher(on, route) {
            var keys = route.keys,
                params = {};
            if (!route.regexp)
              return null;
            var m = route.regexp.exec(on);
            if (!m)
              return null;
            for (var i = 1,
                len = m.length; i < len; ++i) {
              var key = keys[i - 1];
              var val = m[i];
              if (key && val) {
                params[key.name] = val;
              }
            }
            return params;
          }
          function prepareRoute($locationEvent) {
            var lastRoute = $route.current;
            preparedRoute = parseRoute();
            preparedRouteIsUpdateOnly = preparedRoute && lastRoute && preparedRoute.$$route === lastRoute.$$route && angular.equals(preparedRoute.pathParams, lastRoute.pathParams) && !preparedRoute.reloadOnSearch && !forceReload;
            if (!preparedRouteIsUpdateOnly && (lastRoute || preparedRoute)) {
              if ($rootScope.$broadcast('$routeChangeStart', preparedRoute, lastRoute).defaultPrevented) {
                if ($locationEvent) {
                  $locationEvent.preventDefault();
                }
              }
            }
          }
          function commitRoute() {
            var lastRoute = $route.current;
            var nextRoute = preparedRoute;
            if (preparedRouteIsUpdateOnly) {
              lastRoute.params = nextRoute.params;
              angular.copy(lastRoute.params, $routeParams);
              $rootScope.$broadcast('$routeUpdate', lastRoute);
            } else if (nextRoute || lastRoute) {
              forceReload = false;
              $route.current = nextRoute;
              if (nextRoute) {
                if (nextRoute.redirectTo) {
                  if (angular.isString(nextRoute.redirectTo)) {
                    $location.path(interpolate(nextRoute.redirectTo, nextRoute.params)).search(nextRoute.params).replace();
                  } else {
                    $location.url(nextRoute.redirectTo(nextRoute.pathParams, $location.path(), $location.search())).replace();
                  }
                }
              }
              $q.when(nextRoute).then(function() {
                if (nextRoute) {
                  var locals = angular.extend({}, nextRoute.resolve),
                      template,
                      templateUrl;
                  angular.forEach(locals, function(value, key) {
                    locals[key] = angular.isString(value) ? $injector.get(value) : $injector.invoke(value, null, null, key);
                  });
                  if (angular.isDefined(template = nextRoute.template)) {
                    if (angular.isFunction(template)) {
                      template = template(nextRoute.params);
                    }
                  } else if (angular.isDefined(templateUrl = nextRoute.templateUrl)) {
                    if (angular.isFunction(templateUrl)) {
                      templateUrl = templateUrl(nextRoute.params);
                    }
                    if (angular.isDefined(templateUrl)) {
                      nextRoute.loadedTemplateUrl = $sce.valueOf(templateUrl);
                      template = $templateRequest(templateUrl);
                    }
                  }
                  if (angular.isDefined(template)) {
                    locals['$template'] = template;
                  }
                  return $q.all(locals);
                }
              }).then(function(locals) {
                if (nextRoute == $route.current) {
                  if (nextRoute) {
                    nextRoute.locals = locals;
                    angular.copy(nextRoute.params, $routeParams);
                  }
                  $rootScope.$broadcast('$routeChangeSuccess', nextRoute, lastRoute);
                }
              }, function(error) {
                if (nextRoute == $route.current) {
                  $rootScope.$broadcast('$routeChangeError', nextRoute, lastRoute, error);
                }
              });
            }
          }
          function parseRoute() {
            var params,
                match;
            angular.forEach(routes, function(route, path) {
              if (!match && (params = switchRouteMatcher($location.path(), route))) {
                match = inherit(route, {
                  params: angular.extend({}, $location.search(), params),
                  pathParams: params
                });
                match.$$route = route;
              }
            });
            return match || routes[null] && inherit(routes[null], {
              params: {},
              pathParams: {}
            });
          }
          function interpolate(string, params) {
            var result = [];
            angular.forEach((string || '').split(':'), function(segment, i) {
              if (i === 0) {
                result.push(segment);
              } else {
                var segmentMatch = segment.match(/(\w+)(?:[?*])?(.*)/);
                var key = segmentMatch[1];
                result.push(params[key]);
                result.push(segmentMatch[2] || '');
                delete params[key];
              }
            });
            return result.join('');
          }
        }];
      }
      ngRouteModule.provider('$routeParams', $RouteParamsProvider);
      function $RouteParamsProvider() {
        this.$get = function() {
          return {};
        };
      }
      ngRouteModule.directive('ngView', ngViewFactory);
      ngRouteModule.directive('ngView', ngViewFillContentFactory);
      ngViewFactory.$inject = ['$route', '$anchorScroll', '$animate'];
      function ngViewFactory($route, $anchorScroll, $animate) {
        return {
          restrict: 'ECA',
          terminal: true,
          priority: 400,
          transclude: 'element',
          link: function(scope, $element, attr, ctrl, $transclude) {
            var currentScope,
                currentElement,
                previousLeaveAnimation,
                autoScrollExp = attr.autoscroll,
                onloadExp = attr.onload || '';
            scope.$on('$routeChangeSuccess', update);
            update();
            function cleanupLastView() {
              if (previousLeaveAnimation) {
                $animate.cancel(previousLeaveAnimation);
                previousLeaveAnimation = null;
              }
              if (currentScope) {
                currentScope.$destroy();
                currentScope = null;
              }
              if (currentElement) {
                previousLeaveAnimation = $animate.leave(currentElement);
                previousLeaveAnimation.then(function() {
                  previousLeaveAnimation = null;
                });
                currentElement = null;
              }
            }
            function update() {
              var locals = $route.current && $route.current.locals,
                  template = locals && locals.$template;
              if (angular.isDefined(template)) {
                var newScope = scope.$new();
                var current = $route.current;
                var clone = $transclude(newScope, function(clone) {
                  $animate.enter(clone, null, currentElement || $element).then(function onNgViewEnter() {
                    if (angular.isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                      $anchorScroll();
                    }
                  });
                  cleanupLastView();
                });
                currentElement = clone;
                currentScope = current.scope = newScope;
                currentScope.$emit('$viewContentLoaded');
                currentScope.$eval(onloadExp);
              } else {
                cleanupLastView();
              }
            }
          }
        };
      }
      ngViewFillContentFactory.$inject = ['$compile', '$controller', '$route'];
      function ngViewFillContentFactory($compile, $controller, $route) {
        return {
          restrict: 'ECA',
          priority: -400,
          link: function(scope, $element) {
            var current = $route.current,
                locals = current.locals;
            $element.html(locals.$template);
            var link = $compile($element.contents());
            if (current.controller) {
              locals.$scope = scope;
              var controller = $controller(current.controller, locals);
              if (current.controllerAs) {
                scope[current.controllerAs] = controller;
              }
              $element.data('$ngControllerController', controller);
              $element.children().data('$ngControllerController', controller);
            }
            link(scope);
          }
        };
      }
    })(window, window.angular);
  })();
  return _retrieveGlobal();
});

System.registerDynamic("github:angular/bower-angular-route@1.4.8", ["github:angular/bower-angular-route@1.4.8/angular-route"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('github:angular/bower-angular-route@1.4.8/angular-route');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:angular-ui/angular-google-maps@2.3.2/dist/angular-google-maps", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  ;
  (function(window, angular, undefined) {
    'use strict';
    (function() {
      angular.module('uiGmapgoogle-maps.providers', ['nemLogging']);
      angular.module('uiGmapgoogle-maps.wrapped', []);
      angular.module('uiGmapgoogle-maps.extensions', ['uiGmapgoogle-maps.wrapped', 'uiGmapgoogle-maps.providers']);
      angular.module('uiGmapgoogle-maps.directives.api.utils', ['uiGmapgoogle-maps.extensions']);
      angular.module('uiGmapgoogle-maps.directives.api.managers', []);
      angular.module('uiGmapgoogle-maps.directives.api.options', ['uiGmapgoogle-maps.directives.api.utils']);
      angular.module('uiGmapgoogle-maps.directives.api.options.builders', []);
      angular.module('uiGmapgoogle-maps.directives.api.models.child', ['uiGmapgoogle-maps.directives.api.utils', 'uiGmapgoogle-maps.directives.api.options', 'uiGmapgoogle-maps.directives.api.options.builders']);
      angular.module('uiGmapgoogle-maps.directives.api.models.parent', ['uiGmapgoogle-maps.directives.api.managers', 'uiGmapgoogle-maps.directives.api.models.child', 'uiGmapgoogle-maps.providers']);
      angular.module('uiGmapgoogle-maps.directives.api', ['uiGmapgoogle-maps.directives.api.models.parent']);
      angular.module('uiGmapgoogle-maps', ['uiGmapgoogle-maps.directives.api', 'uiGmapgoogle-maps.providers']);
    }).call(this);
    ;
    (function() {
      angular.module('uiGmapgoogle-maps.providers').factory('uiGmapMapScriptLoader', ['$q', 'uiGmapuuid', function($q, uuid) {
        var getScriptUrl,
            includeScript,
            isGoogleMapsLoaded,
            scriptId,
            usedConfiguration;
        scriptId = void 0;
        usedConfiguration = void 0;
        getScriptUrl = function(options) {
          if (options.china) {
            return 'http://maps.google.cn/maps/api/js?';
          } else {
            if (options.transport === 'auto') {
              return '//maps.googleapis.com/maps/api/js?';
            } else {
              return options.transport + '://maps.googleapis.com/maps/api/js?';
            }
          }
        };
        includeScript = function(options) {
          var omitOptions,
              query,
              script,
              scriptElem;
          omitOptions = ['transport', 'isGoogleMapsForWork', 'china', 'preventLoad'];
          if (options.isGoogleMapsForWork) {
            omitOptions.push('key');
          }
          query = _.map(_.omit(options, omitOptions), function(v, k) {
            return k + '=' + v;
          });
          if (scriptId) {
            scriptElem = document.getElementById(scriptId);
            scriptElem.parentNode.removeChild(scriptElem);
          }
          query = query.join('&');
          script = document.createElement('script');
          script.id = scriptId = "ui_gmap_map_load_" + (uuid.generate());
          script.type = 'text/javascript';
          script.src = getScriptUrl(options) + query;
          return document.body.appendChild(script);
        };
        isGoogleMapsLoaded = function() {
          return angular.isDefined(window.google) && angular.isDefined(window.google.maps);
        };
        return {
          load: function(options) {
            var deferred,
                randomizedFunctionName;
            deferred = $q.defer();
            if (isGoogleMapsLoaded()) {
              deferred.resolve(window.google.maps);
              return deferred.promise;
            }
            randomizedFunctionName = options.callback = 'onGoogleMapsReady' + Math.round(Math.random() * 1000);
            window[randomizedFunctionName] = function() {
              window[randomizedFunctionName] = null;
              deferred.resolve(window.google.maps);
            };
            if (window.navigator.connection && window.Connection && window.navigator.connection.type === window.Connection.NONE && !options.preventLoad) {
              document.addEventListener('online', function() {
                if (!isGoogleMapsLoaded()) {
                  return includeScript(options);
                }
              });
            } else if (!options.preventLoad) {
              includeScript(options);
            }
            usedConfiguration = options;
            usedConfiguration.randomizedFunctionName = randomizedFunctionName;
            return deferred.promise;
          },
          manualLoad: function() {
            var config;
            config = usedConfiguration;
            if (!isGoogleMapsLoaded()) {
              return includeScript(config);
            } else {
              if (window[config.randomizedFunctionName]) {
                return window[config.randomizedFunctionName]();
              }
            }
          }
        };
      }]).provider('uiGmapGoogleMapApi', function() {
        this.options = {
          transport: 'https',
          isGoogleMapsForWork: false,
          china: false,
          v: '3',
          libraries: '',
          language: 'en',
          preventLoad: false
        };
        this.configure = function(options) {
          angular.extend(this.options, options);
        };
        this.$get = ['uiGmapMapScriptLoader', (function(_this) {
          return function(loader) {
            return loader.load(_this.options);
          };
        })(this)];
        return this;
      }).service('uiGmapGoogleMapApiManualLoader', ['uiGmapMapScriptLoader', function(loader) {
        return {load: function() {
            loader.manualLoad();
          }};
      }]);
    }).call(this);
    ;
    (function() {
      var bind = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      },
          extend = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;
      angular.module('uiGmapgoogle-maps.extensions').service('uiGmapExtendGWin', function() {
        return {init: _.once(function() {
            var uiGmapInfoBox;
            if (!(google || (typeof google !== "undefined" && google !== null ? google.maps : void 0) || (google.maps.InfoWindow != null))) {
              return;
            }
            google.maps.InfoWindow.prototype._open = google.maps.InfoWindow.prototype.open;
            google.maps.InfoWindow.prototype._close = google.maps.InfoWindow.prototype.close;
            google.maps.InfoWindow.prototype._isOpen = false;
            google.maps.InfoWindow.prototype.open = function(map, anchor, recurse) {
              if (recurse != null) {
                return;
              }
              this._isOpen = true;
              this._open(map, anchor, true);
            };
            google.maps.InfoWindow.prototype.close = function(recurse) {
              if (recurse != null) {
                return;
              }
              this._isOpen = false;
              this._close(true);
            };
            google.maps.InfoWindow.prototype.isOpen = function(val) {
              if (val == null) {
                val = void 0;
              }
              if (val == null) {
                return this._isOpen;
              } else {
                return this._isOpen = val;
              }
            };
            if (window.InfoBox) {
              window.InfoBox.prototype._open = window.InfoBox.prototype.open;
              window.InfoBox.prototype._close = window.InfoBox.prototype.close;
              window.InfoBox.prototype._isOpen = false;
              window.InfoBox.prototype.open = function(map, anchor) {
                this._isOpen = true;
                this._open(map, anchor);
              };
              window.InfoBox.prototype.close = function() {
                this._isOpen = false;
                this._close();
              };
              window.InfoBox.prototype.isOpen = function(val) {
                if (val == null) {
                  val = void 0;
                }
                if (val == null) {
                  return this._isOpen;
                } else {
                  return this._isOpen = val;
                }
              };
              uiGmapInfoBox = (function(superClass) {
                extend(uiGmapInfoBox, superClass);
                function uiGmapInfoBox(opts) {
                  this.getOrigCloseBoxImg_ = bind(this.getOrigCloseBoxImg_, this);
                  this.getCloseBoxDiv_ = bind(this.getCloseBoxDiv_, this);
                  var box;
                  box = new window.InfoBox(opts);
                  _.extend(this, box);
                  if (opts.closeBoxDiv != null) {
                    this.closeBoxDiv_ = opts.closeBoxDiv;
                  }
                }
                uiGmapInfoBox.prototype.getCloseBoxDiv_ = function() {
                  return this.closeBoxDiv_;
                };
                uiGmapInfoBox.prototype.getCloseBoxImg_ = function() {
                  var div,
                      img;
                  div = this.getCloseBoxDiv_();
                  img = this.getOrigCloseBoxImg_();
                  return div || img;
                };
                uiGmapInfoBox.prototype.getOrigCloseBoxImg_ = function() {
                  var img;
                  img = "";
                  if (this.closeBoxURL_ !== "") {
                    img = "<img";
                    img += " src='" + this.closeBoxURL_ + "'";
                    img += " align=right";
                    img += " style='";
                    img += " position: relative;";
                    img += " cursor: pointer;";
                    img += " margin: " + this.closeBoxMargin_ + ";";
                    img += "'>";
                  }
                  return img;
                };
                return uiGmapInfoBox;
              })(window.InfoBox);
              window.uiGmapInfoBox = uiGmapInfoBox;
            }
            if (window.MarkerLabel_) {
              return window.MarkerLabel_.prototype.setContent = function() {
                var content;
                content = this.marker_.get('labelContent');
                if (!content || _.isEqual(this.oldContent, content)) {
                  return;
                }
                if (typeof(content != null ? content.nodeType : void 0) === 'undefined') {
                  this.labelDiv_.innerHTML = content;
                  this.eventDiv_.innerHTML = this.labelDiv_.innerHTML;
                  this.oldContent = content;
                } else {
                  this.labelDiv_.innerHTML = '';
                  this.labelDiv_.appendChild(content);
                  content = content.cloneNode(true);
                  this.labelDiv_.innerHTML = '';
                  this.eventDiv_.appendChild(content);
                  this.oldContent = content;
                }
              };
            }
          })};
      });
    }).call(this);
    ;
    (function() {
      angular.module('uiGmapgoogle-maps.extensions').service('uiGmapLodash', function() {
        var baseGet,
            baseToString,
            fixLodash,
            get,
            reEscapeChar,
            rePropName,
            toObject,
            toPath;
        rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;
        reEscapeChar = /\\(\\)?/g;
        fixLodash = function(arg) {
          var isProto,
              missingName,
              swapName;
          missingName = arg.missingName, swapName = arg.swapName, isProto = arg.isProto;
          if (_[missingName] == null) {
            _[missingName] = _[swapName];
            if (isProto) {
              return _.prototype[missingName] = _[swapName];
            }
          }
        };
        [{
          missingName: 'contains',
          swapName: 'includes',
          isProto: true
        }, {
          missingName: 'includes',
          swapName: 'contains',
          isProto: true
        }, {
          missingName: 'object',
          swapName: 'zipObject'
        }, {
          missingName: 'zipObject',
          swapName: 'object'
        }, {
          missingName: 'all',
          swapName: 'every'
        }, {
          missingName: 'every',
          swapName: 'all'
        }, {
          missingName: 'any',
          swapName: 'some'
        }, {
          missingName: 'some',
          swapName: 'any'
        }, {
          missingName: 'first',
          swapName: 'head'
        }, {
          missingName: 'head',
          swapName: 'first'
        }].forEach(function(toMonkeyPatch) {
          return fixLodash(toMonkeyPatch);
        });
        if (_.get == null) {
          toObject = function(value) {
            if (_.isObject(value)) {
              return value;
            } else {
              return Object(value);
            }
          };
          baseToString = function(value) {
            if (value === null) {
              return '';
            } else {
              return value + '';
            }
          };
          toPath = function(value) {
            var result;
            if (_.isArray(value)) {
              return value;
            }
            result = [];
            baseToString(value).replace(rePropName, function(match, number, quote, string) {
              result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
            });
            return result;
          };
          baseGet = function(object, path, pathKey) {
            var index,
                length;
            if (object === null) {
              return;
            }
            if (pathKey !== void 0 && pathKey in toObject(object)) {
              path = [pathKey];
            }
            index = 0;
            length = path.length;
            while (!_.isUndefined(object) && index < length) {
              object = object[path[index++]];
            }
            if (index && index === length) {
              return object;
            } else {
              return void 0;
            }
          };
          get = function(object, path, defaultValue) {
            var result;
            result = object === null ? void 0 : baseGet(object, toPath(path), path + '');
            if (result === void 0) {
              return defaultValue;
            } else {
              return result;
            }
          };
          _.get = get;
        }
        this.intersectionObjects = function(array1, array2, comparison) {
          var res;
          if (comparison == null) {
            comparison = void 0;
          }
          res = _.map(array1, function(obj1) {
            return _.find(array2, function(obj2) {
              if (comparison != null) {
                return comparison(obj1, obj2);
              } else {
                return _.isEqual(obj1, obj2);
              }
            });
          });
          return _.filter(res, function(o) {
            return o != null;
          });
        };
        this.containsObject = _.includeObject = function(obj, target, comparison) {
          if (comparison == null) {
            comparison = void 0;
          }
          if (obj === null) {
            return false;
          }
          return _.some(obj, function(value) {
            if (comparison != null) {
              return comparison(value, target);
            } else {
              return _.isEqual(value, target);
            }
          });
        };
        this.differenceObjects = function(array1, array2, comparison) {
          if (comparison == null) {
            comparison = void 0;
          }
          return _.filter(array1, (function(_this) {
            return function(value) {
              return !_this.containsObject(array2, value, comparison);
            };
          })(this));
        };
        this.withoutObjects = this.differenceObjects;
        this.indexOfObject = function(array, item, comparison, isSorted) {
          var i,
              length;
          if (array == null) {
            return -1;
          }
          i = 0;
          length = array.length;
          if (isSorted) {
            if (typeof isSorted === "number") {
              i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);
            } else {
              i = _.sortedIndex(array, item);
              return (array[i] === item ? i : -1);
            }
          }
          while (i < length) {
            if (comparison != null) {
              if (comparison(array[i], item)) {
                return i;
              }
            } else {
              if (_.isEqual(array[i], item)) {
                return i;
              }
            }
            i++;
          }
          return -1;
        };
        this.isNullOrUndefined = function(thing) {
          return _.isNull(thing || _.isUndefined(thing));
        };
        return this;
      });
    }).call(this);
    ;
    (function() {
      angular.module('uiGmapgoogle-maps.extensions').factory('uiGmapString', function() {
        return function(str) {
          this.contains = function(value, fromIndex) {
            return str.indexOf(value, fromIndex) !== -1;
          };
          return this;
        };
      });
    }).call(this);
    ;
    (function() {
      angular.module('uiGmapgoogle-maps.directives.api.utils').service('uiGmap_sync', [function() {
        return {fakePromise: function() {
            var _cb;
            _cb = void 0;
            return {
              then: function(cb) {
                return _cb = cb;
              },
              resolve: function() {
                return _cb.apply(void 0, arguments);
              }
            };
          }};
      }]).service('uiGmap_async', ['$timeout', 'uiGmapPromise', 'uiGmapLogger', '$q', 'uiGmapDataStructures', 'uiGmapGmapUtil', function($timeout, uiGmapPromise, $log, $q, uiGmapDataStructures, uiGmapGmapUtil) {
        var ExposedPromise,
            PromiseQueueManager,
            SniffedPromise,
            _getIterateeValue,
            _ignoreFields,
            defaultChunkSize,
            doChunk,
            doSkippPromise,
            each,
            errorObject,
            getArrayAndKeys,
            isInProgress,
            kickPromise,
            logTryCatch,
            managePromiseQueue,
            map,
            maybeCancelPromises,
            promiseStatus,
            promiseTypes,
            tryCatch;
        promiseTypes = uiGmapPromise.promiseTypes;
        isInProgress = uiGmapPromise.isInProgress;
        promiseStatus = uiGmapPromise.promiseStatus;
        ExposedPromise = uiGmapPromise.ExposedPromise;
        SniffedPromise = uiGmapPromise.SniffedPromise;
        kickPromise = function(sniffedPromise, cancelCb) {
          var promise;
          promise = sniffedPromise.promise();
          promise.promiseType = sniffedPromise.promiseType;
          if (promise.$$state) {
            $log.debug("promiseType: " + promise.promiseType + ", state: " + (promiseStatus(promise.$$state.status)));
          }
          promise.cancelCb = cancelCb;
          return promise;
        };
        doSkippPromise = function(sniffedPromise, lastPromise) {
          if (sniffedPromise.promiseType === promiseTypes.create && lastPromise.promiseType !== promiseTypes["delete"] && lastPromise.promiseType !== promiseTypes.init) {
            $log.debug("lastPromise.promiseType " + lastPromise.promiseType + ", newPromiseType: " + sniffedPromise.promiseType + ", SKIPPED MUST COME AFTER DELETE ONLY");
            return true;
          }
          return false;
        };
        maybeCancelPromises = function(queue, sniffedPromise, lastPromise) {
          var first;
          if (sniffedPromise.promiseType === promiseTypes["delete"] && lastPromise.promiseType !== promiseTypes["delete"]) {
            if ((lastPromise.cancelCb != null) && _.isFunction(lastPromise.cancelCb) && isInProgress(lastPromise)) {
              $log.debug("promiseType: " + sniffedPromise.promiseType + ", CANCELING LAST PROMISE type: " + lastPromise.promiseType);
              lastPromise.cancelCb('cancel safe');
              first = queue.peek();
              if ((first != null) && isInProgress(first)) {
                if (first.hasOwnProperty("cancelCb") && _.isFunction(first.cancelCb)) {
                  $log.debug("promiseType: " + first.promiseType + ", CANCELING FIRST PROMISE type: " + first.promiseType);
                  return first.cancelCb('cancel safe');
                } else {
                  return $log.warn('first promise was not cancelable');
                }
              }
            }
          }
        };
        PromiseQueueManager = function(existingPiecesObj, sniffedPromise, cancelCb) {
          var lastPromise,
              newPromise;
          if (!existingPiecesObj.existingPieces) {
            existingPiecesObj.existingPieces = new uiGmapDataStructures.Queue();
            return existingPiecesObj.existingPieces.enqueue(kickPromise(sniffedPromise, cancelCb));
          } else {
            lastPromise = _.last(existingPiecesObj.existingPieces._content);
            if (doSkippPromise(sniffedPromise, lastPromise)) {
              return;
            }
            maybeCancelPromises(existingPiecesObj.existingPieces, sniffedPromise, lastPromise);
            newPromise = ExposedPromise(lastPromise["finally"](function() {
              return kickPromise(sniffedPromise, cancelCb);
            }));
            newPromise.cancelCb = cancelCb;
            newPromise.promiseType = sniffedPromise.promiseType;
            existingPiecesObj.existingPieces.enqueue(newPromise);
            return lastPromise["finally"](function() {
              return existingPiecesObj.existingPieces.dequeue();
            });
          }
        };
        managePromiseQueue = function(objectToLock, promiseType, msg, cancelCb, fnPromise) {
          var cancelLogger;
          if (msg == null) {
            msg = '';
          }
          cancelLogger = function(msg) {
            $log.debug(msg + ": " + msg);
            if ((cancelCb != null) && _.isFunction(cancelCb)) {
              return cancelCb(msg);
            }
          };
          return PromiseQueueManager(objectToLock, SniffedPromise(fnPromise, promiseType), cancelLogger);
        };
        defaultChunkSize = 80;
        errorObject = {value: null};
        tryCatch = function(fn, ctx, args) {
          var e,
              error1;
          try {
            return fn.apply(ctx, args);
          } catch (error1) {
            e = error1;
            errorObject.value = e;
            return errorObject;
          }
        };
        logTryCatch = function(fn, ctx, deferred, args) {
          var msg,
              result;
          result = tryCatch(fn, ctx, args);
          if (result === errorObject) {
            msg = "error within chunking iterator: " + errorObject.value;
            $log.error(msg);
            deferred.reject(msg);
          }
          if (result === 'cancel safe') {
            return false;
          }
          return true;
        };
        _getIterateeValue = function(collection, array, index) {
          var _isArray,
              valOrKey;
          _isArray = collection === array;
          valOrKey = array[index];
          if (_isArray) {
            return valOrKey;
          }
          return collection[valOrKey];
        };
        _ignoreFields = ['length', 'forEach', 'map'];
        getArrayAndKeys = function(collection, keys, bailOutCb, cb) {
          var array,
              propName,
              val;
          if (angular.isArray(collection)) {
            array = collection;
          } else {
            if (keys) {
              array = keys;
            } else {
              array = [];
              for (propName in collection) {
                val = collection[propName];
                if (collection.hasOwnProperty(propName) && !_.includes(_ignoreFields, propName)) {
                  array.push(propName);
                }
              }
            }
          }
          if (cb == null) {
            cb = bailOutCb;
          }
          if (angular.isArray(array) && !(array != null ? array.length : void 0)) {
            if (cb !== bailOutCb) {
              return bailOutCb();
            }
          }
          return cb(array, keys);
        };
        doChunk = function(collection, chunkSizeOrDontChunk, pauseMilli, chunkCb, pauseCb, overallD, index, _keys) {
          return getArrayAndKeys(collection, _keys, function(array, keys) {
            var cnt,
                i,
                keepGoing,
                val;
            if (chunkSizeOrDontChunk && chunkSizeOrDontChunk < array.length) {
              cnt = chunkSizeOrDontChunk;
            } else {
              cnt = array.length;
            }
            i = index;
            keepGoing = true;
            while (keepGoing && cnt-- && i < (array ? array.length : i + 1)) {
              val = _getIterateeValue(collection, array, i);
              keepGoing = angular.isFunction(val) ? true : logTryCatch(chunkCb, void 0, overallD, [val, i]);
              ++i;
            }
            if (array) {
              if (keepGoing && i < array.length) {
                index = i;
                if (chunkSizeOrDontChunk) {
                  if ((pauseCb != null) && _.isFunction(pauseCb)) {
                    logTryCatch(pauseCb, void 0, overallD, []);
                  }
                  return $timeout(function() {
                    return doChunk(collection, chunkSizeOrDontChunk, pauseMilli, chunkCb, pauseCb, overallD, index, keys);
                  }, pauseMilli, false);
                }
              } else {
                return overallD.resolve();
              }
            }
          });
        };
        each = function(collection, chunk, chunkSizeOrDontChunk, pauseCb, index, pauseMilli, _keys) {
          var error,
              overallD,
              ret;
          if (chunkSizeOrDontChunk == null) {
            chunkSizeOrDontChunk = defaultChunkSize;
          }
          if (index == null) {
            index = 0;
          }
          if (pauseMilli == null) {
            pauseMilli = 1;
          }
          ret = void 0;
          overallD = uiGmapPromise.defer();
          ret = overallD.promise;
          if (!pauseMilli) {
            error = 'pause (delay) must be set from _async!';
            $log.error(error);
            overallD.reject(error);
            return ret;
          }
          return getArrayAndKeys(collection, _keys, function() {
            overallD.resolve();
            return ret;
          }, function(array, keys) {
            doChunk(collection, chunkSizeOrDontChunk, pauseMilli, chunk, pauseCb, overallD, index, keys);
            return ret;
          });
        };
        map = function(collection, iterator, chunkSizeOrDontChunk, pauseCb, index, pauseMilli, _keys) {
          var results;
          results = [];
          return getArrayAndKeys(collection, _keys, function() {
            return uiGmapPromise.resolve(results);
          }, function(array, keys) {
            return each(collection, function(o) {
              return results.push(iterator(o));
            }, chunkSizeOrDontChunk, pauseCb, index, pauseMilli, keys).then(function() {
              return results;
            });
          });
        };
        return {
          each: each,
          map: map,
          managePromiseQueue: managePromiseQueue,
          promiseLock: managePromiseQueue,
          defaultChunkSize: defaultChunkSize,
          getArrayAndKeys: getArrayAndKeys,
          chunkSizeFrom: function(fromSize, ret) {
            if (ret == null) {
              ret = void 0;
            }
            if (_.isNumber(fromSize)) {
              ret = fromSize;
            }
            if (uiGmapGmapUtil.isFalse(fromSize) || fromSize === false) {
              ret = false;
            }
            return ret;
          }
        };
      }]);
    }).call(this);
    ;
    (function() {
      var indexOf = [].indexOf || function(item) {
        for (var i = 0,
            l = this.length; i < l; i++) {
          if (i in this && this[i] === item)
            return i;
        }
        return -1;
      };
      angular.module('uiGmapgoogle-maps.directives.api.utils').factory('uiGmapBaseObject', function() {
        var BaseObject,
            baseObjectKeywords;
        baseObjectKeywords = ['extended', 'included'];
        BaseObject = (function() {
          function BaseObject() {}
          BaseObject.extend = function(obj) {
            var key,
                ref,
                value;
            for (key in obj) {
              value = obj[key];
              if (indexOf.call(baseObjectKeywords, key) < 0) {
                this[key] = value;
              }
            }
            if ((ref = obj.extended) != null) {
              ref.apply(this);
            }
            return this;
          };
          BaseObject.include = function(obj) {
            var key,
                ref,
                value;
            for (key in obj) {
              value = obj[key];
              if (indexOf.call(baseObjectKeywords, key) < 0) {
                this.prototype[key] = value;
              }
            }
            if ((ref = obj.included) != null) {
              ref.apply(this);
            }
            return this;
          };
          return BaseObject;
        })();
        return BaseObject;
      });
    }).call(this);
    ;
    (function() {
      angular.module('uiGmapgoogle-maps.directives.api.utils').factory('uiGmapChildEvents', function() {
        return {onChildCreation: function(child) {}};
      });
    }).call(this);
    ;
    (function() {
      angular.module('uiGmapgoogle-maps.directives.api.utils').service('uiGmapCtrlHandle', ['$q', function($q) {
        var CtrlHandle;
        return CtrlHandle = {
          handle: function($scope, $element) {
            $scope.$on('$destroy', function() {
              return CtrlHandle.handle($scope);
            });
            $scope.deferred = $q.defer();
            return {getScope: function() {
                return $scope;
              }};
          },
          mapPromise: function(scope, ctrl) {
            var mapScope;
            mapScope = ctrl.getScope();
            mapScope.deferred.promise.then(function(map) {
              return scope.map = map;
            });
            return mapScope.deferred.promise;
          }
        };
      }]);
    }).call(this);
    ;
    (function() {
      angular.module("uiGmapgoogle-maps.directives.api.utils").service("uiGmapEventsHelper", ["uiGmapLogger", function($log) {
        var _getEventsObj,
            _hasEvents;
        _hasEvents = function(obj) {
          return angular.isDefined(obj.events) && (obj.events != null) && angular.isObject(obj.events);
        };
        _getEventsObj = function(scope, model) {
          if (_hasEvents(scope)) {
            return scope;
          }
          if (_hasEvents(model)) {
            return model;
          }
        };
        return {
          setEvents: function(gObject, scope, model, ignores) {
            var eventObj;
            eventObj = _getEventsObj(scope, model);
            if (eventObj != null) {
              return _.compact(_.map(eventObj.events, function(eventHandler, eventName) {
                var doIgnore;
                if (ignores) {
                  doIgnore = _(ignores).includes(eventName);
                }
                if (eventObj.events.hasOwnProperty(eventName) && angular.isFunction(eventObj.events[eventName]) && !doIgnore) {
                  return google.maps.event.addListener(gObject, eventName, function() {
                    if (!scope.$evalAsync) {
                      scope.$evalAsync = function() {};
                    }
                    return scope.$evalAsync(eventHandler.apply(scope, [gObject, eventName, model, arguments]));
                  });
                }
              }));
            }
          },
          removeEvents: function(listeners) {
            var key,
                l;
            if (!listeners) {
              return;
            }
            for (key in listeners) {
              l = listeners[key];
              if (l && listeners.hasOwnProperty(key)) {
                google.maps.event.removeListener(l);
              }
            }
          }
        };
      }]);
    }).call(this);
    ;
    (function() {
      angular.module('uiGmapgoogle-maps.directives.api.utils').service('uiGmapFitHelper', ['uiGmapLogger', function($log) {
        return {fit: function(markersOrPoints, gMap) {
            var bounds,
                everSet,
                key,
                markerOrPoint,
                point;
            if (gMap && (markersOrPoints != null ? markersOrPoints.length : void 0)) {
              bounds = new google.maps.LatLngBounds();
              everSet = false;
              for (key in markersOrPoints) {
                markerOrPoint = markersOrPoints[key];
                if (markerOrPoint) {
                  if (!everSet) {
                    everSet = true;
                  }
                  point = _.isFunction(markerOrPoint.getPosition) ? markerOrPoint.getPosition() : markerOrPoint;
                }
                bounds.extend(point);
              }
              if (everSet) {
                return gMap.fitBounds(bounds);
              }
            }
          }};
      }]);
    }).call(this);
    ;
    (function() {
      angular.module('uiGmapgoogle-maps.directives.api.utils').service('uiGmapGmapUtil', ['uiGmapLogger', '$compile', function(Logger, $compile) {
        var _isFalse,
            _isTruthy,
            getCoords,
            getLatitude,
            getLongitude,
            validateCoords;
        _isTruthy = function(value, bool, optionsArray) {
          return value === bool || optionsArray.indexOf(value) !== -1;
        };
        _isFalse = function(value) {
          return _isTruthy(value, false, ['false', 'FALSE', 0, 'n', 'N', 'no', 'NO']);
        };
        getLatitude = function(value) {
          if (Array.isArray(value) && value.length === 2) {
            return value[1];
          } else if (angular.isDefined(value.type) && value.type === 'Point') {
            return value.coordinates[1];
          } else {
            return value.latitude;
          }
        };
        getLongitude = function(value) {
          if (Array.isArray(value) && value.length === 2) {
            return value[0];
          } else if (angular.isDefined(value.type) && value.type === 'Point') {
            return value.coordinates[0];
          } else {
            return value.longitude;
          }
        };
        getCoords = function(value) {
          if (!value) {
            return;
          }
          if (Array.isArray(value) && value.length === 2) {
            return new google.maps.LatLng(value[1], value[0]);
          } else if (angular.isDefined(value.type) && value.type === 'Point') {
            return new google.maps.LatLng(value.coordinates[1], value.coordinates[0]);
          } else {
            return new google.maps.LatLng(value.latitude, value.longitude);
          }
        };
        validateCoords = function(coords) {
          if (angular.isUndefined(coords)) {
            return false;
          }
          if (_.isArray(coords)) {
            if (coords.length === 2) {
              return true;
            }
          } else if ((coords != null) && (coords != null ? coords.type : void 0)) {
            if (coords.type === 'Point' && _.isArray(coords.coordinates) && coords.coordinates.length === 2) {
              return true;
            }
          }
          if (coords && angular.isDefined((coords != null ? coords.latitude : void 0) && angular.isDefined(coords != null ? coords.longitude : void 0))) {
            return true;
          }
          return false;
        };
        return {
          setCoordsFromEvent: function(prevValue, newLatLon) {
            if (!prevValue) {
              return;
            }
            if (Array.isArray(prevValue) && prevValue.length === 2) {
              prevValue[1] = newLatLon.lat();
              prevValue[0] = newLatLon.lng();
            } else if (angular.isDefined(prevValue.type) && prevValue.type === 'Point') {
              prevValue.coordinates[1] = newLatLon.lat();
              prevValue.coordinates[0] = newLatLon.lng();
            } else {
              prevValue.latitude = newLatLon.lat();
              prevValue.longitude = newLatLon.lng();
            }
            return prevValue;
          },
          getLabelPositionPoint: function(anchor) {
            var xPos,
                yPos;
            if (anchor === void 0) {
              return void 0;
            }
            anchor = /^([-\d\.]+)\s([-\d\.]+)$/.exec(anchor);
            xPos = parseFloat(anchor[1]);
            yPos = parseFloat(anchor[2]);
            if ((xPos != null) && (yPos != null)) {
              return new google.maps.Point(xPos, yPos);
            }
          },
          createWindowOptions: function(gMarker, scope, content, defaults) {
            var options;
            if ((content != null) && (defaults != null) && ($compile != null)) {
              options = angular.extend({}, defaults, {
                content: this.buildContent(scope, defaults, content),
                position: defaults.position != null ? defaults.position : angular.isObject(gMarker) ? gMarker.getPosition() : getCoords(scope.coords)
              });
              if ((gMarker != null) && ((options != null ? options.pixelOffset : void 0) == null)) {
                if (options.boxClass == null) {} else {
                  options.pixelOffset = {
                    height: 0,
                    width: -2
                  };
                }
              }
              return options;
            } else {
              if (!defaults) {
                Logger.error('infoWindow defaults not defined');
                if (!content) {
                  return Logger.error('infoWindow content not defined');
                }
              } else {
                return defaults;
              }
            }
          },
          buildContent: function(scope, defaults, content) {
            var parsed,
                ret;
            if (defaults.content != null) {
              ret = defaults.content;
            } else {
              if ($compile != null) {
                content = content.replace(/^\s+|\s+$/g, '');
                parsed = content === '' ? '' : $compile(content)(scope);
                if (parsed.length > 0) {
                  ret = parsed[0];
                }
              } else {
                ret = content;
              }
            }
            return ret;
          },
          defaultDelay: 50,
          isTrue: function(value) {
            return _isTruthy(value, true, ['true', 'TRUE', 1, 'y', 'Y', 'yes', 'YES']);
          },
          isFalse: _isFalse,
          isFalsy: function(value) {
            return _isTruthy(value, false, [void 0, null]) || _isFalse(value);
          },
          getCoords: getCoords,
          validateCoords: validateCoords,
          equalCoords: function(coord1, coord2) {
            return getLatitude(coord1) === getLatitude(coord2) && getLongitude(coord1) === getLongitude(coord2);
          },
          validatePath: function(path) {
            var array,
                i,
                polygon,
                trackMaxVertices;
            i = 0;
            if (angular.isUndefined(path.type)) {
              if (!Array.isArray(path) || path.length < 2) {
                return false;
              }
              while (i < path.length) {
                if (!((angular.isDefined(path[i].latitude) && angular.isDefined(path[i].longitude)) || (typeof path[i].lat === 'function' && typeof path[i].lng === 'function'))) {
                  return false;
                }
                i++;
              }
              return true;
            } else {
              if (angular.isUndefined(path.coordinates)) {
                return false;
              }
              if (path.type === 'Polygon') {
                if (path.coordinates[0].length < 4) {
                  return false;
                }
                array = path.coordinates[0];
              } else if (path.type === 'MultiPolygon') {
                trackMaxVertices = {
                  max: 0,
                  index: 0
                };
                _.forEach(path.coordinates, function(polygon, index) {
                  if (polygon[0].length > this.max) {
                    this.max = polygon[0].length;
                    return this.index = index;
                  }
                }, trackMaxVertices);
                polygon = path.coordinates[trackMaxVertices.index];
                array = polygon[0];
                if (array.length < 4) {
                  return false;
                }
              } else if (path.type === 'LineString') {
                if (path.coordinates.length < 2) {
                  return false;
                }
                array = path.coordinates;
              } else {
                return false;
              }
              while (i < array.length) {
                if (array[i].length !== 2) {
                  return false;
                }
                i++;
              }
              return true;
            }
          },
          convertPathPoints: function(path) {
            var array,
                i,
                latlng,
                result,
                trackMaxVertices;
            i = 0;
            result = new google.maps.MVCArray();
            if (angular.isUndefined(path.type)) {
              while (i < path.length) {
                latlng;
                if (angular.isDefined(path[i].latitude) && angular.isDefined(path[i].longitude)) {
                  latlng = new google.maps.LatLng(path[i].latitude, path[i].longitude);
                } else if (typeof path[i].lat === 'function' && typeof path[i].lng === 'function') {
                  latlng = path[i];
                }
                result.push(latlng);
                i++;
              }
            } else {
              array;
              if (path.type === 'Polygon') {
                array = path.coordinates[0];
              } else if (path.type === 'MultiPolygon') {
                trackMaxVertices = {
                  max: 0,
                  index: 0
                };
                _.forEach(path.coordinates, function(polygon, index) {
                  if (polygon[0].length > this.max) {
                    this.max = polygon[0].length;
                    return this.index = index;
                  }
                }, trackMaxVertices);
                array = path.coordinates[trackMaxVertices.index][0];
              } else if (path.type === 'LineString') {
                array = path.coordinates;
              }
              while (i < array.length) {
                result.push(new google.maps.LatLng(array[i][1], array[i][0]));
                i++;
              }
            }
            return result;
          },
          getPath: function(object, key) {
            var obj;
            if ((key == null) || !_.isString(key)) {
              return key;
            }
            obj = object;
            _.each(key.split('.'), function(value) {
              if (obj) {
                return obj = obj[value];
              }
            });
            return obj;
          },
          validateBoundPoints: function(bounds) {
            if (angular.isUndefined(bounds.sw.latitude) || angular.isUndefined(bounds.sw.longitude) || angular.isUndefined(bounds.ne.latitude) || angular.isUndefined(bounds.ne.longitude)) {
              return false;
            }
            return true;
          },
          convertBoundPoints: function(bounds) {
            var result;
            result = new google.maps.LatLngBounds(new google.maps.LatLng(bounds.sw.latitude, bounds.sw.longitude), new google.maps.LatLng(bounds.ne.latitude, bounds.ne.longitude));
            return result;
          },
          fitMapBounds: function(map, bounds) {
            return map.fitBounds(bounds);
          }
        };
      }]);
    }).call(this);
    ;
    (function() {
      angular.module('uiGmapgoogle-maps.directives.api.utils').service('uiGmapIsReady', ['$q', '$timeout', function($q, $timeout) {
        var _checkIfReady,
            _ctr,
            _promises,
            _proms;
        _ctr = 0;
        _proms = [];
        _promises = function() {
          return $q.all(_proms);
        };
        _checkIfReady = function(deferred, expectedInstances, retriesLeft) {
          return $timeout(function() {
            if (retriesLeft <= 0) {
              deferred.reject('Your maps are not found we have checked the maximum amount of times. :)');
              return;
            }
            if (_ctr !== expectedInstances) {
              _checkIfReady(deferred, expectedInstances, retriesLeft - 1);
            } else {
              deferred.resolve(_promises());
            }
          }, 100);
        };
        return {
          spawn: function() {
            var d;
            d = $q.defer();
            _proms.push(d.promise);
            _ctr += 1;
            return {
              instance: _ctr,
              deferred: d
            };
          },
          promises: _promises,
          instances: function() {
            return _ctr;
          },
          promise: function(expectedInstances, numRetries) {
            var d;
            if (expectedInstances == null) {
              expectedInstances = 1;
            }
            if (numRetries == null) {
              numRetries = 50;
            }
            d = $q.defer();
            _checkIfReady(d, expectedInstances, numRetries);
            return d.promise;
          },
          reset: function() {
            _ctr = 0;
            _proms.length = 0;
          },
          decrement: function() {
            if (_ctr > 0) {
              _ctr -= 1;
            }
            if (_proms.length) {
              _proms.length -= 1;
            }
          }
        };
      }]);
    }).call(this);
    ;
    (function() {
      var extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      },
          hasProp = {}.hasOwnProperty;
      angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapLinked", ["uiGmapBaseObject", function(BaseObject) {
        var Linked;
        Linked = (function(superClass) {
          extend(Linked, superClass);
          function Linked(scope, element, attrs, ctrls) {
            this.scope = scope;
            this.element = element;
            this.attrs = attrs;
            this.ctrls = ctrls;
          }
          return Linked;
        })(BaseObject);
        return Linked;
      }]);
    }).call(this);
    ;
    (function() {
      angular.module('uiGmapgoogle-maps.directives.api.utils').service('uiGmapLogger', ['nemSimpleLogger', function(nemSimpleLogger) {
        return nemSimpleLogger.spawn();
      }]);
    }).call(this);
    ;
    (function() {
      var bind = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      },
          extend = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;
      angular.module('uiGmapgoogle-maps.directives.api.utils').factory('uiGmapModelKey', ['uiGmapBaseObject', 'uiGmapGmapUtil', function(BaseObject, GmapUtil) {
        return (function(superClass) {
          extend(_Class, superClass);
          function _Class(scope1, _interface) {
            this.scope = scope1;
            this["interface"] = _interface != null ? _interface : {scopeKeys: []};
            this.modelsLength = bind(this.modelsLength, this);
            this.updateChild = bind(this.updateChild, this);
            this.destroy = bind(this.destroy, this);
            this.setChildScope = bind(this.setChildScope, this);
            this.getChanges = bind(this.getChanges, this);
            this.getProp = bind(this.getProp, this);
            this.setIdKey = bind(this.setIdKey, this);
            this.modelKeyComparison = bind(this.modelKeyComparison, this);
            _Class.__super__.constructor.call(this);
            this.defaultIdKey = 'id';
            this.idKey = void 0;
          }
          _Class.prototype.evalModelHandle = function(model, modelKey) {
            if ((model == null) || (modelKey == null)) {
              return;
            }
            if (modelKey === 'self') {
              return model;
            } else {
              if (_.isFunction(modelKey)) {
                modelKey = modelKey();
              }
              return GmapUtil.getPath(model, modelKey);
            }
          };
          _Class.prototype.modelKeyComparison = function(model1, model2) {
            var coord1,
                coord2,
                hasCoords,
                isEqual,
                scope,
                without;
            hasCoords = this["interface"].scopeKeys.indexOf('coords') >= 0;
            if (hasCoords && (this.scope.coords != null) || !hasCoords) {
              scope = this.scope;
            }
            if (scope == null) {
              throw 'No scope set!';
            }
            if (hasCoords) {
              coord1 = this.scopeOrModelVal('coords', scope, model1);
              coord2 = this.scopeOrModelVal('coords', scope, model2);
              isEqual = GmapUtil.equalCoords(coord1, coord2);
              if (!isEqual) {
                return isEqual;
              }
            }
            without = _.without(this["interface"].scopeKeys, 'coords');
            isEqual = _.every(without, (function(_this) {
              return function(k) {
                return _this.scopeOrModelVal(scope[k], scope, model1) === _this.scopeOrModelVal(scope[k], scope, model2);
              };
            })(this));
            return isEqual;
          };
          _Class.prototype.setIdKey = function(scope) {
            return this.idKey = scope.idKey != null ? scope.idKey : this.defaultIdKey;
          };
          _Class.prototype.setVal = function(model, key, newValue) {
            this.modelOrKey(model, key = newValue);
            return model;
          };
          _Class.prototype.modelOrKey = function(model, key) {
            if (key == null) {
              return;
            }
            if (key !== 'self') {
              return GmapUtil.getPath(model, key);
            }
            return model;
          };
          _Class.prototype.getProp = function(propName, scope, model) {
            return this.scopeOrModelVal(propName, scope, model);
          };
          _Class.prototype.getChanges = function(now, prev, whitelistedProps) {
            var c,
                changes,
                prop;
            if (whitelistedProps) {
              prev = _.pick(prev, whitelistedProps);
              now = _.pick(now, whitelistedProps);
            }
            changes = {};
            prop = {};
            c = {};
            for (prop in now) {
              if (!prev || prev[prop] !== now[prop]) {
                if (_.isArray(now[prop])) {
                  changes[prop] = now[prop];
                } else if (_.isObject(now[prop])) {
                  c = this.getChanges(now[prop], (prev ? prev[prop] : null));
                  if (!_.isEmpty(c)) {
                    changes[prop] = c;
                  }
                } else {
                  changes[prop] = now[prop];
                }
              }
            }
            return changes;
          };
          _Class.prototype.scopeOrModelVal = function(key, scope, model, doWrap) {
            var maybeWrap,
                modelKey,
                modelProp,
                scopeProp;
            if (doWrap == null) {
              doWrap = false;
            }
            maybeWrap = function(isScope, ret, doWrap) {
              if (doWrap == null) {
                doWrap = false;
              }
              if (doWrap) {
                return {
                  isScope: isScope,
                  value: ret
                };
              }
              return ret;
            };
            scopeProp = _.get(scope, key);
            if (_.isFunction(scopeProp)) {
              return maybeWrap(true, scopeProp(model), doWrap);
            }
            if (_.isObject(scopeProp)) {
              return maybeWrap(true, scopeProp, doWrap);
            }
            if (!_.isString(scopeProp)) {
              return maybeWrap(true, scopeProp, doWrap);
            }
            modelKey = scopeProp;
            if (!modelKey) {
              modelProp = _.get(model, key);
            } else {
              modelProp = modelKey === 'self' ? model : _.get(model, modelKey);
            }
            if (_.isFunction(modelProp)) {
              return maybeWrap(false, modelProp(), doWrap);
            }
            return maybeWrap(false, modelProp, doWrap);
          };
          _Class.prototype.setChildScope = function(keys, childScope, model) {
            var isScopeObj,
                key,
                name,
                newValue;
            for (key in keys) {
              name = keys[key];
              isScopeObj = this.scopeOrModelVal(name, childScope, model, true);
              if ((isScopeObj != null ? isScopeObj.value : void 0) != null) {
                newValue = isScopeObj.value;
                if (newValue !== childScope[name]) {
                  childScope[name] = newValue;
                }
              }
            }
            return childScope.model = model;
          };
          _Class.prototype.onDestroy = function(scope) {};
          _Class.prototype.destroy = function(manualOverride) {
            var ref;
            if (manualOverride == null) {
              manualOverride = false;
            }
            if ((this.scope != null) && !((ref = this.scope) != null ? ref.$$destroyed : void 0) && (this.needToManualDestroy || manualOverride)) {
              return this.scope.$destroy();
            } else {
              return this.clean();
            }
          };
          _Class.prototype.updateChild = function(child, model) {
            if (model[this.idKey] == null) {
              this.$log.error("Model has no id to assign a child to. This is required for performance. Please assign id, or redirect id to a different key.");
              return;
            }
            return child.updateModel(model);
          };
          _Class.prototype.modelsLength = function(arrayOrObjModels) {
            var len,
                toCheck;
            if (arrayOrObjModels == null) {
              arrayOrObjModels = void 0;
            }
            len = 0;
            toCheck = arrayOrObjModels ? arrayOrObjModels : this.scope.models;
            if (toCheck == null) {
              return len;
            }
            if (angular.isArray(toCheck) || (toCheck.length != null)) {
              len = toCheck.length;
            } else {
              len = Object.keys(toCheck).length;
            }
            return len;
          };
          return _Class;
        })(BaseObject);
      }]);
    }).call(this);
    ;
    (function() {
      angular.module('uiGmapgoogle-maps.directives.api.utils').factory('uiGmapModelsWatcher', ['uiGmapLogger', 'uiGmap_async', '$q', 'uiGmapPromise', function(Logger, _async, $q, uiGmapPromise) {
        return {
          didQueueInitPromise: function(existingPiecesObj, scope) {
            if (scope.models.length === 0) {
              _async.promiseLock(existingPiecesObj, uiGmapPromise.promiseTypes.init, null, null, (function() {
                return uiGmapPromise.resolve();
              }));
              return true;
            }
            return false;
          },
          figureOutState: function(idKey, scope, childObjects, comparison, callBack) {
            var adds,
                children,
                mappedScopeModelIds,
                removals,
                updates;
            adds = [];
            mappedScopeModelIds = {};
            removals = [];
            updates = [];
            scope.models.forEach(function(m) {
              var child;
              if (m[idKey] != null) {
                mappedScopeModelIds[m[idKey]] = {};
                if (childObjects.get(m[idKey]) == null) {
                  return adds.push(m);
                } else {
                  child = childObjects.get(m[idKey]);
                  if (!comparison(m, child.clonedModel, scope)) {
                    return updates.push({
                      model: m,
                      child: child
                    });
                  }
                }
              } else {
                return Logger.error(' id missing for model #{m.toString()},\ncan not use do comparison/insertion');
              }
            });
            children = childObjects.values();
            children.forEach(function(c) {
              var id;
              if (c == null) {
                Logger.error('child undefined in ModelsWatcher.');
                return;
              }
              if (c.model == null) {
                Logger.error('child.model undefined in ModelsWatcher.');
                return;
              }
              id = c.model[idKey];
              if (mappedScopeModelIds[id] == null) {
                return removals.push(c);
              }
            });
            return {
              adds: adds,
              removals: removals,
              updates: updates
            };
          }
        };
      }]);
    }).call(this);
    ;
    (function() {
      angular.module('uiGmapgoogle-maps.directives.api.utils').service('uiGmapPromise', ['$q', '$timeout', 'uiGmapLogger', function($q, $timeout, $log) {
        var ExposedPromise,
            SniffedPromise,
            defer,
            isInProgress,
            isResolved,
            promise,
            promiseStatus,
            promiseStatuses,
            promiseTypes,
            resolve,
            strPromiseStatuses;
        promiseTypes = {
          create: 'create',
          update: 'update',
          "delete": 'delete',
          init: 'init'
        };
        promiseStatuses = {
          IN_PROGRESS: 0,
          RESOLVED: 1,
          REJECTED: 2
        };
        strPromiseStatuses = (function() {
          var obj;
          obj = {};
          obj["" + promiseStatuses.IN_PROGRESS] = 'in-progress';
          obj["" + promiseStatuses.RESOLVED] = 'resolved';
          obj["" + promiseStatuses.REJECTED] = 'rejected';
          return obj;
        })();
        isInProgress = function(promise) {
          if (promise.$$state) {
            return promise.$$state.status === promiseStatuses.IN_PROGRESS;
          }
          if (!promise.hasOwnProperty("$$v")) {
            return true;
          }
        };
        isResolved = function(promise) {
          if (promise.$$state) {
            return promise.$$state.status === promiseStatuses.RESOLVED;
          }
          if (promise.hasOwnProperty("$$v")) {
            return true;
          }
        };
        promiseStatus = function(status) {
          return strPromiseStatuses[status] || 'done w error';
        };
        ExposedPromise = function(promise) {
          var cancelDeferred,
              combined,
              wrapped;
          cancelDeferred = $q.defer();
          combined = $q.all([promise, cancelDeferred.promise]);
          wrapped = $q.defer();
          promise.then(cancelDeferred.resolve, (function() {}), function(notify) {
            cancelDeferred.notify(notify);
            return wrapped.notify(notify);
          });
          combined.then(function(successes) {
            return wrapped.resolve(successes[0] || successes[1]);
          }, function(error) {
            return wrapped.reject(error);
          });
          wrapped.promise.cancel = function(reason) {
            if (reason == null) {
              reason = 'canceled';
            }
            return cancelDeferred.reject(reason);
          };
          wrapped.promise.notify = function(msg) {
            if (msg == null) {
              msg = 'cancel safe';
            }
            wrapped.notify(msg);
            if (promise.hasOwnProperty('notify')) {
              return promise.notify(msg);
            }
          };
          if (promise.promiseType != null) {
            wrapped.promise.promiseType = promise.promiseType;
          }
          return wrapped.promise;
        };
        SniffedPromise = function(fnPromise, promiseType) {
          return {
            promise: fnPromise,
            promiseType: promiseType
          };
        };
        defer = function() {
          return $q.defer();
        };
        resolve = function() {
          var d;
          d = $q.defer();
          d.resolve.apply(void 0, arguments);
          return d.promise;
        };
        promise = function(fnToWrap) {
          var d;
          if (!_.isFunction(fnToWrap)) {
            $log.error("uiGmapPromise.promise() only accepts functions");
            return;
          }
          d = $q.defer();
          $timeout(function() {
            var result;
            result = fnToWrap();
            return d.resolve(result);
          });
          return d.promise;
        };
        return {
          defer: defer,
          promise: promise,
          resolve: resolve,
          promiseTypes: promiseTypes,
          isInProgress: isInProgress,
          isResolved: isResolved,
          promiseStatus: promiseStatus,
          ExposedPromise: ExposedPromise,
          SniffedPromise: SniffedPromise
        };
      }]);
    }).call(this);
    ;
    (function() {
      var bind = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      };
      angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapPropMap", function() {
        var PropMap;
        return PropMap = (function() {
          function PropMap() {
            this.removeAll = bind(this.removeAll, this);
            this.slice = bind(this.slice, this);
            this.push = bind(this.push, this);
            this.keys = bind(this.keys, this);
            this.values = bind(this.values, this);
            this.remove = bind(this.remove, this);
            this.put = bind(this.put, this);
            this.stateChanged = bind(this.stateChanged, this);
            this.get = bind(this.get, this);
            this.length = 0;
            this.dict = {};
            this.didValsStateChange = false;
            this.didKeysStateChange = false;
            this.allVals = [];
            this.allKeys = [];
          }
          PropMap.prototype.get = function(key) {
            return this.dict[key];
          };
          PropMap.prototype.stateChanged = function() {
            this.didValsStateChange = true;
            return this.didKeysStateChange = true;
          };
          PropMap.prototype.put = function(key, value) {
            if (this.get(key) == null) {
              this.length++;
            }
            this.stateChanged();
            return this.dict[key] = value;
          };
          PropMap.prototype.remove = function(key, isSafe) {
            var value;
            if (isSafe == null) {
              isSafe = false;
            }
            if (isSafe && !this.get(key)) {
              return void 0;
            }
            value = this.dict[key];
            delete this.dict[key];
            this.length--;
            this.stateChanged();
            return value;
          };
          PropMap.prototype.valuesOrKeys = function(str) {
            var keys,
                vals;
            if (str == null) {
              str = 'Keys';
            }
            if (!this["did" + str + "StateChange"]) {
              return this['all' + str];
            }
            vals = [];
            keys = [];
            _.each(this.dict, function(v, k) {
              vals.push(v);
              return keys.push(k);
            });
            this.didKeysStateChange = false;
            this.didValsStateChange = false;
            this.allVals = vals;
            this.allKeys = keys;
            return this['all' + str];
          };
          PropMap.prototype.values = function() {
            return this.valuesOrKeys('Vals');
          };
          PropMap.prototype.keys = function() {
            return this.valuesOrKeys();
          };
          PropMap.prototype.push = function(obj, key) {
            if (key == null) {
              key = "key";
            }
            return this.put(obj[key], obj);
          };
          PropMap.prototype.slice = function() {
            return this.keys().map((function(_this) {
              return function(k) {
                return _this.remove(k);
              };
            })(this));
          };
          PropMap.prototype.removeAll = function() {
            return this.slice();
          };
          PropMap.prototype.each = function(cb) {
            return _.each(this.dict, function(v, k) {
              return cb(v);
            });
          };
          PropMap.prototype.map = function(cb) {
            return _.map(this.dict, function(v, k) {
              return cb(v);
            });
          };
          return PropMap;
        })();
      });
    }).call(this);
    ;
    (function() {
      angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapPropertyAction", ["uiGmapLogger", function(Logger) {
        var PropertyAction;
        PropertyAction = function(setterFn) {
          this.setIfChange = function(callingKey) {
            return function(newVal, oldVal) {
              if (!_.isEqual(oldVal, newVal)) {
                return setterFn(callingKey, newVal);
              }
            };
          };
          this.sic = this.setIfChange;
          return this;
        };
        return PropertyAction;
      }]);
    }).call(this);
    ;
    (function() {
      var bind = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      };
      angular.module('uiGmapgoogle-maps.directives.api.managers').factory('uiGmapClustererMarkerManager', ['uiGmapLogger', 'uiGmapFitHelper', 'uiGmapPropMap', 'uiGmapEventsHelper', function($log, FitHelper, PropMap, EventsHelper) {
        var ClustererMarkerManager;
        ClustererMarkerManager = (function() {
          ClustererMarkerManager.type = 'ClustererMarkerManager';
          function ClustererMarkerManager(gMap, opt_markers, opt_options, opt_events) {
            if (opt_markers == null) {
              opt_markers = {};
            }
            this.opt_options = opt_options != null ? opt_options : {};
            this.opt_events = opt_events;
            this.checkSync = bind(this.checkSync, this);
            this.getGMarkers = bind(this.getGMarkers, this);
            this.fit = bind(this.fit, this);
            this.destroy = bind(this.destroy, this);
            this.attachEvents = bind(this.attachEvents, this);
            this.clear = bind(this.clear, this);
            this.draw = bind(this.draw, this);
            this.removeMany = bind(this.removeMany, this);
            this.remove = bind(this.remove, this);
            this.addMany = bind(this.addMany, this);
            this.update = bind(this.update, this);
            this.add = bind(this.add, this);
            this.type = ClustererMarkerManager.type;
            this.clusterer = new NgMapMarkerClusterer(gMap, opt_markers, this.opt_options);
            this.propMapGMarkers = new PropMap();
            this.attachEvents(this.opt_events, 'opt_events');
            this.clusterer.setIgnoreHidden(true);
            this.noDrawOnSingleAddRemoves = true;
            $log.info(this);
          }
          ClustererMarkerManager.prototype.checkKey = function(gMarker) {
            var msg;
            if (gMarker.key == null) {
              msg = 'gMarker.key undefined and it is REQUIRED!!';
              return $log.error(msg);
            }
          };
          ClustererMarkerManager.prototype.add = function(gMarker) {
            this.checkKey(gMarker);
            this.clusterer.addMarker(gMarker, this.noDrawOnSingleAddRemoves);
            this.propMapGMarkers.put(gMarker.key, gMarker);
            return this.checkSync();
          };
          ClustererMarkerManager.prototype.update = function(gMarker) {
            this.remove(gMarker);
            return this.add(gMarker);
          };
          ClustererMarkerManager.prototype.addMany = function(gMarkers) {
            return gMarkers.forEach((function(_this) {
              return function(gMarker) {
                return _this.add(gMarker);
              };
            })(this));
          };
          ClustererMarkerManager.prototype.remove = function(gMarker) {
            var exists;
            this.checkKey(gMarker);
            exists = this.propMapGMarkers.get(gMarker.key);
            if (exists) {
              this.clusterer.removeMarker(gMarker, this.noDrawOnSingleAddRemoves);
              this.propMapGMarkers.remove(gMarker.key);
            }
            return this.checkSync();
          };
          ClustererMarkerManager.prototype.removeMany = function(gMarkers) {
            return gMarkers.forEach((function(_this) {
              return function(gMarker) {
                return _this.remove(gMarker);
              };
            })(this));
          };
          ClustererMarkerManager.prototype.draw = function() {
            return this.clusterer.repaint();
          };
          ClustererMarkerManager.prototype.clear = function() {
            this.removeMany(this.getGMarkers());
            return this.clusterer.repaint();
          };
          ClustererMarkerManager.prototype.attachEvents = function(options, optionsName) {
            var eventHandler,
                eventName,
                results;
            this.listeners = [];
            if (angular.isDefined(options) && (options != null) && angular.isObject(options)) {
              results = [];
              for (eventName in options) {
                eventHandler = options[eventName];
                if (options.hasOwnProperty(eventName) && angular.isFunction(options[eventName])) {
                  $log.info(optionsName + ": Attaching event: " + eventName + " to clusterer");
                  results.push(this.listeners.push(google.maps.event.addListener(this.clusterer, eventName, options[eventName])));
                } else {
                  results.push(void 0);
                }
              }
              return results;
            }
          };
          ClustererMarkerManager.prototype.clearEvents = function() {
            EventsHelper.removeEvents(this.listeners);
            return this.listeners = [];
          };
          ClustererMarkerManager.prototype.destroy = function() {
            this.clearEvents();
            return this.clear();
          };
          ClustererMarkerManager.prototype.fit = function() {
            return FitHelper.fit(this.getGMarkers(), this.clusterer.getMap());
          };
          ClustererMarkerManager.prototype.getGMarkers = function() {
            return this.clusterer.getMarkers().values();
          };
          ClustererMarkerManager.prototype.checkSync = function() {};
          return ClustererMarkerManager;
        })();
        return ClustererMarkerManager;
      }]);
    }).call(this);
    ;
    (function() {
      angular.module('uiGmapgoogle-maps.directives.api.managers').service('uiGmapGoogleMapObjectManager', [function() {
        var _availableInstances,
            _usedInstances;
        _availableInstances = [];
        _usedInstances = [];
        return {
          createMapInstance: function(parentElement, options) {
            var instance;
            instance = null;
            if (_availableInstances.length === 0) {
              instance = new google.maps.Map(parentElement, options);
              _usedInstances.push(instance);
            } else {
              instance = _availableInstances.pop();
              angular.element(parentElement).append(instance.getDiv());
              instance.setOptions(options);
              _usedInstances.push(instance);
            }
            return instance;
          },
          recycleMapInstance: function(instance) {
            var index;
            index = _usedInstances.indexOf(instance);
            if (index < 0) {
              throw new Error('Expected map instance to be a previously used instance');
            }
            _usedInstances.splice(index, 1);
            return _availableInstances.push(instance);
          }
        };
      }]);
    }).call(this);
    ;
    (function() {
      var bind = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      };
      angular.module("uiGmapgoogle-maps.directives.api.managers").factory("uiGmapMarkerManager", ["uiGmapLogger", "uiGmapFitHelper", "uiGmapPropMap", function(Logger, FitHelper, PropMap) {
        var MarkerManager;
        MarkerManager = (function() {
          MarkerManager.type = 'MarkerManager';
          function MarkerManager(gMap, opt_markers, opt_options) {
            this.getGMarkers = bind(this.getGMarkers, this);
            this.fit = bind(this.fit, this);
            this.handleOptDraw = bind(this.handleOptDraw, this);
            this.clear = bind(this.clear, this);
            this.destroy = bind(this.destroy, this);
            this.draw = bind(this.draw, this);
            this.removeMany = bind(this.removeMany, this);
            this.remove = bind(this.remove, this);
            this.addMany = bind(this.addMany, this);
            this.update = bind(this.update, this);
            this.add = bind(this.add, this);
            this.type = MarkerManager.type;
            this.gMap = gMap;
            this.gMarkers = new PropMap();
            this.$log = Logger;
            this.$log.info(this);
          }
          MarkerManager.prototype.add = function(gMarker, optDraw) {
            var exists,
                msg;
            if (optDraw == null) {
              optDraw = true;
            }
            if (gMarker.key == null) {
              msg = "gMarker.key undefined and it is REQUIRED!!";
              Logger.error(msg);
              throw msg;
            }
            exists = this.gMarkers.get(gMarker.key);
            if (!exists) {
              this.handleOptDraw(gMarker, optDraw, true);
              return this.gMarkers.put(gMarker.key, gMarker);
            }
          };
          MarkerManager.prototype.update = function(gMarker, optDraw) {
            if (optDraw == null) {
              optDraw = true;
            }
            this.remove(gMarker, optDraw);
            return this.add(gMarker, optDraw);
          };
          MarkerManager.prototype.addMany = function(gMarkers) {
            return gMarkers.forEach((function(_this) {
              return function(gMarker) {
                return _this.add(gMarker);
              };
            })(this));
          };
          MarkerManager.prototype.remove = function(gMarker, optDraw) {
            if (optDraw == null) {
              optDraw = true;
            }
            this.handleOptDraw(gMarker, optDraw, false);
            if (this.gMarkers.get(gMarker.key)) {
              return this.gMarkers.remove(gMarker.key);
            }
          };
          MarkerManager.prototype.removeMany = function(gMarkers) {
            return gMarkers.forEach((function(_this) {
              return function(marker) {
                return _this.remove(marker);
              };
            })(this));
          };
          MarkerManager.prototype.draw = function() {
            var deletes;
            deletes = [];
            this.gMarkers.each((function(_this) {
              return function(gMarker) {
                if (!gMarker.isDrawn) {
                  if (gMarker.doAdd) {
                    gMarker.setMap(_this.gMap);
                    return gMarker.isDrawn = true;
                  } else {
                    return deletes.push(gMarker);
                  }
                }
              };
            })(this));
            return deletes.forEach((function(_this) {
              return function(gMarker) {
                gMarker.isDrawn = false;
                return _this.remove(gMarker, true);
              };
            })(this));
          };
          MarkerManager.prototype.destroy = function() {
            return this.clear();
          };
          MarkerManager.prototype.clear = function() {
            this.gMarkers.each(function(gMarker) {
              return gMarker.setMap(null);
            });
            delete this.gMarkers;
            return this.gMarkers = new PropMap();
          };
          MarkerManager.prototype.handleOptDraw = function(gMarker, optDraw, doAdd) {
            if (optDraw === true) {
              if (doAdd) {
                gMarker.setMap(this.gMap);
              } else {
                gMarker.setMap(null);
              }
              return gMarker.isDrawn = true;
            } else {
              gMarker.isDrawn = false;
              return gMarker.doAdd = doAdd;
            }
          };
          MarkerManager.prototype.fit = function() {
            return FitHelper.fit(this.getGMarkers(), this.gMap);
          };
          MarkerManager.prototype.getGMarkers = function() {
            return this.gMarkers.values();
          };
          return MarkerManager;
        })();
        return MarkerManager;
      }]);
    }).call(this);
    ;
    (function() {
      var bind = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      };
      angular.module('uiGmapgoogle-maps.directives.api.managers').factory('uiGmapSpiderfierMarkerManager', ['uiGmapLogger', 'uiGmapFitHelper', 'uiGmapPropMap', 'uiGmapMarkerSpiderfier', function($log, FitHelper, PropMap, MarkerSpiderfier) {
        var SpiderfierMarkerManager;
        return SpiderfierMarkerManager = (function() {
          SpiderfierMarkerManager.type = 'SpiderfierMarkerManager';
          function SpiderfierMarkerManager(gMap, opt_markers, opt_options, opt_events, scope) {
            if (opt_markers == null) {
              opt_markers = {};
            }
            this.opt_options = opt_options != null ? opt_options : {};
            this.opt_events = opt_events;
            this.scope = scope;
            this.checkSync = bind(this.checkSync, this);
            this.isSpiderfied = bind(this.isSpiderfied, this);
            this.getGMarkers = bind(this.getGMarkers, this);
            this.fit = bind(this.fit, this);
            this.destroy = bind(this.destroy, this);
            this.attachEvents = bind(this.attachEvents, this);
            this.clear = bind(this.clear, this);
            this.draw = bind(this.draw, this);
            this.removeMany = bind(this.removeMany, this);
            this.remove = bind(this.remove, this);
            this.addMany = bind(this.addMany, this);
            this.update = bind(this.update, this);
            this.add = bind(this.add, this);
            this.type = SpiderfierMarkerManager.type;
            this.markerSpiderfier = new MarkerSpiderfier(gMap, this.opt_options);
            this.propMapGMarkers = new PropMap();
            this.attachEvents(this.opt_events, 'opt_events');
            this.noDrawOnSingleAddRemoves = true;
            $log.info(this);
          }
          SpiderfierMarkerManager.prototype.checkKey = function(gMarker) {
            var msg;
            if (gMarker.key == null) {
              msg = 'gMarker.key undefined and it is REQUIRED!!';
              return $log.error(msg);
            }
          };
          SpiderfierMarkerManager.prototype.add = function(gMarker) {
            gMarker.setMap(this.markerSpiderfier.map);
            this.checkKey(gMarker);
            this.markerSpiderfier.addMarker(gMarker, this.noDrawOnSingleAddRemoves);
            this.propMapGMarkers.put(gMarker.key, gMarker);
            return this.checkSync();
          };
          SpiderfierMarkerManager.prototype.update = function(gMarker) {
            this.remove(gMarker);
            return this.add(gMarker);
          };
          SpiderfierMarkerManager.prototype.addMany = function(gMarkers) {
            return gMarkers.forEach((function(_this) {
              return function(gMarker) {
                return _this.add(gMarker);
              };
            })(this));
          };
          SpiderfierMarkerManager.prototype.remove = function(gMarker) {
            var exists;
            this.checkKey(gMarker);
            exists = this.propMapGMarkers.get(gMarker.key);
            if (exists) {
              gMarker.setMap(null);
              this.markerSpiderfier.removeMarker(gMarker, this.noDrawOnSingleAddRemoves);
              this.propMapGMarkers.remove(gMarker.key);
            }
            return this.checkSync();
          };
          SpiderfierMarkerManager.prototype.removeMany = function(gMarkers) {
            return gMarkers.forEach((function(_this) {
              return function(gMarker) {
                return _this.remove(gMarker);
              };
            })(this));
          };
          SpiderfierMarkerManager.prototype.draw = function() {};
          SpiderfierMarkerManager.prototype.clear = function() {
            return this.removeMany(this.getGMarkers());
          };
          SpiderfierMarkerManager.prototype.attachEvents = function(options, optionsName) {
            if (angular.isDefined(options) && (options != null) && angular.isObject(options)) {
              return _.each(options, (function(_this) {
                return function(eventHandler, eventName) {
                  if (options.hasOwnProperty(eventName) && angular.isFunction(options[eventName])) {
                    $log.info(optionsName + ": Attaching event: " + eventName + " to markerSpiderfier");
                    return _this.markerSpiderfier.addListener(eventName, function() {
                      if (eventName === 'spiderfy' || eventName === 'unspiderfy') {
                        return _this.scope.$evalAsync(options[eventName].apply(options, arguments));
                      } else {
                        return _this.scope.$evalAsync(options[eventName].apply(options, [arguments[0], eventName, arguments[0].model, arguments]));
                      }
                    });
                  }
                };
              })(this));
            }
          };
          SpiderfierMarkerManager.prototype.clearEvents = function(options, optionsName) {
            var eventHandler,
                eventName;
            if (angular.isDefined(options) && (options != null) && angular.isObject(options)) {
              for (eventName in options) {
                eventHandler = options[eventName];
                if (options.hasOwnProperty(eventName) && angular.isFunction(options[eventName])) {
                  $log.info(optionsName + ": Clearing event: " + eventName + " to markerSpiderfier");
                  this.markerSpiderfier.clearListeners(eventName);
                }
              }
            }
          };
          SpiderfierMarkerManager.prototype.destroy = function() {
            this.clearEvents(this.opt_events, 'opt_events');
            return this.clear();
          };
          SpiderfierMarkerManager.prototype.fit = function() {
            return FitHelper.fit(this.getGMarkers(), this.markerSpiderfier.map);
          };
          SpiderfierMarkerManager.prototype.getGMarkers = function() {
            return this.markerSpiderfier.getMarkers();
          };
          SpiderfierMarkerManager.prototype.isSpiderfied = function() {
            return _.find(this.getGMarkers(), function(gMarker) {
              return (gMarker != null ? gMarker._omsData : void 0) != null;
            });
          };
          SpiderfierMarkerManager.prototype.checkSync = function() {};
          return SpiderfierMarkerManager;
        })();
      }]);
    }).call(this);
    ;
    (function() {
      angular.module('uiGmapgoogle-maps').factory('uiGmapadd-events', ['$timeout', function($timeout) {
        var addEvent,
            addEvents;
        addEvent = function(target, eventName, handler) {
          return google.maps.event.addListener(target, eventName, function() {
            handler.apply(this, arguments);
            return $timeout((function() {}), true);
          });
        };
        addEvents = function(target, eventName, handler) {
          var remove;
          if (handler) {
            return addEvent(target, eventName, handler);
          }
          remove = [];
          angular.forEach(eventName, function(_handler, key) {
            return remove.push(addEvent(target, key, _handler));
          });
          return function() {
            angular.forEach(remove, function(listener) {
              return google.maps.event.removeListener(listener);
            });
            return remove = null;
          };
        };
        return addEvents;
      }]);
    }).call(this);
    ;
    (function() {
      angular.module('uiGmapgoogle-maps').factory('uiGmaparray-sync', ['uiGmapadd-events', function(mapEvents) {
        return function(mapArray, scope, pathEval, pathChangedFn) {
          var geojsonArray,
              geojsonHandlers,
              geojsonWatcher,
              isSetFromScope,
              legacyHandlers,
              legacyWatcher,
              mapArrayListener,
              scopePath,
              watchListener;
          isSetFromScope = false;
          scopePath = scope.$eval(pathEval);
          if (!scope["static"]) {
            legacyHandlers = {
              set_at: function(index) {
                var value;
                if (isSetFromScope) {
                  return;
                }
                value = mapArray.getAt(index);
                if (!value) {
                  return;
                }
                if (!value.lng || !value.lat) {
                  return scopePath[index] = value;
                } else {
                  scopePath[index].latitude = value.lat();
                  return scopePath[index].longitude = value.lng();
                }
              },
              insert_at: function(index) {
                var value;
                if (isSetFromScope) {
                  return;
                }
                value = mapArray.getAt(index);
                if (!value) {
                  return;
                }
                if (!value.lng || !value.lat) {
                  return scopePath.splice(index, 0, value);
                } else {
                  return scopePath.splice(index, 0, {
                    latitude: value.lat(),
                    longitude: value.lng()
                  });
                }
              },
              remove_at: function(index) {
                if (isSetFromScope) {
                  return;
                }
                return scopePath.splice(index, 1);
              }
            };
            geojsonArray;
            if (scopePath.type === 'Polygon') {
              geojsonArray = scopePath.coordinates[0];
            } else if (scopePath.type === 'LineString') {
              geojsonArray = scopePath.coordinates;
            }
            geojsonHandlers = {
              set_at: function(index) {
                var value;
                if (isSetFromScope) {
                  return;
                }
                value = mapArray.getAt(index);
                if (!(value && value.lng && value.lat)) {
                  return;
                }
                geojsonArray[index][1] = value.lat();
                return geojsonArray[index][0] = value.lng();
              },
              insert_at: function(index) {
                var value;
                if (isSetFromScope) {
                  return;
                }
                value = mapArray.getAt(index);
                if (!value) {
                  return;
                }
                if (!value.lng || !value.lat) {
                  return;
                }
                return geojsonArray.splice(index, 0, [value.lng(), value.lat()]);
              },
              remove_at: function(index) {
                if (isSetFromScope) {
                  return;
                }
                return geojsonArray.splice(index, 1);
              }
            };
            mapArrayListener = mapEvents(mapArray, angular.isUndefined(scopePath.type) ? legacyHandlers : geojsonHandlers);
          }
          legacyWatcher = function(newPath) {
            var changed,
                i,
                l,
                newLength,
                newValue,
                oldArray,
                oldLength,
                oldValue;
            isSetFromScope = true;
            oldArray = mapArray;
            changed = false;
            if (newPath) {
              i = 0;
              oldLength = oldArray.getLength();
              newLength = newPath.length;
              l = Math.min(oldLength, newLength);
              newValue = void 0;
              while (i < l) {
                oldValue = oldArray.getAt(i);
                newValue = newPath[i];
                if (typeof newValue.equals === 'function') {
                  if (!newValue.equals(oldValue)) {
                    oldArray.setAt(i, newValue);
                    changed = true;
                  }
                } else {
                  if ((oldValue.lat() !== newValue.latitude) || (oldValue.lng() !== newValue.longitude)) {
                    oldArray.setAt(i, new google.maps.LatLng(newValue.latitude, newValue.longitude));
                    changed = true;
                  }
                }
                i++;
              }
              while (i < newLength) {
                newValue = newPath[i];
                if (typeof newValue.lat === 'function' && typeof newValue.lng === 'function') {
                  oldArray.push(newValue);
                } else {
                  oldArray.push(new google.maps.LatLng(newValue.latitude, newValue.longitude));
                }
                changed = true;
                i++;
              }
              while (i < oldLength) {
                oldArray.pop();
                changed = true;
                i++;
              }
            }
            isSetFromScope = false;
            if (changed) {
              return pathChangedFn(oldArray);
            }
          };
          geojsonWatcher = function(newPath) {
            var array,
                changed,
                i,
                l,
                newLength,
                newValue,
                oldArray,
                oldLength,
                oldValue;
            isSetFromScope = true;
            oldArray = mapArray;
            changed = false;
            if (newPath) {
              array;
              if (scopePath.type === 'Polygon') {
                array = newPath.coordinates[0];
              } else if (scopePath.type === 'LineString') {
                array = newPath.coordinates;
              }
              i = 0;
              oldLength = oldArray.getLength();
              newLength = array.length;
              l = Math.min(oldLength, newLength);
              newValue = void 0;
              while (i < l) {
                oldValue = oldArray.getAt(i);
                newValue = array[i];
                if ((oldValue.lat() !== newValue[1]) || (oldValue.lng() !== newValue[0])) {
                  oldArray.setAt(i, new google.maps.LatLng(newValue[1], newValue[0]));
                  changed = true;
                }
                i++;
              }
              while (i < newLength) {
                newValue = array[i];
                oldArray.push(new google.maps.LatLng(newValue[1], newValue[0]));
                changed = true;
                i++;
              }
              while (i < oldLength) {
                oldArray.pop();
                changed = true;
                i++;
              }
            }
            isSetFromScope = false;
            if (changed) {
              return pathChangedFn(oldArray);
            }
          };
          watchListener;
          if (!scope["static"]) {
            if (angular.isUndefined(scopePath.type)) {
              watchListener = scope.$watchCollection(pathEval, legacyWatcher);
            } else {
              watchListener = scope.$watch(pathEval, geojsonWatcher, true);
            }
          }
          return function() {
            if (mapArrayListener) {
              mapArrayListener();
              mapArrayListener = null;
            }
            if (watchListener) {
              watchListener();
              return watchListener = null;
            }
          };
        };
      }]);
    }).call(this);
    ;
    (function() {
      angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapChromeFixes", ['$timeout', function($timeout) {
        return {maybeRepaint: function(el) {
            if (el) {
              el.style.opacity = 0.9;
              return $timeout(function() {
                return el.style.opacity = 1;
              });
            }
          }};
      }]);
    }).call(this);
    ;
    (function() {
      angular.module('uiGmapgoogle-maps').service('uiGmapObjectIterators', function() {
        var _ignores,
            _iterators,
            _slapForEach,
            _slapMap;
        _ignores = ['length', 'forEach', 'map'];
        _iterators = [];
        _slapForEach = function(object) {
          object.forEach = function(cb) {
            return _.each(_.omit(object, _ignores), function(val) {
              if (!_.isFunction(val)) {
                return cb(val);
              }
            });
          };
          return object;
        };
        _iterators.push(_slapForEach);
        _slapMap = function(object) {
          object.map = function(cb) {
            return _.map(_.omit(object, _ignores), function(val) {
              if (!_.isFunction(val)) {
                return cb(val);
              }
            });
          };
          return object;
        };
        _iterators.push(_slapMap);
        return {
          slapMap: _slapMap,
          slapForEach: _slapForEach,
          slapAll: function(object) {
            _iterators.forEach(function(it) {
              return it(object);
            });
            return object;
          }
        };
      });
    }).call(this);
    ;
    (function() {
      var bind = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      },
          extend = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;
      angular.module('uiGmapgoogle-maps.directives.api.options.builders').service('uiGmapCommonOptionsBuilder', ['uiGmapBaseObject', 'uiGmapLogger', 'uiGmapModelKey', function(BaseObject, $log, ModelKey) {
        var CommonOptionsBuilder;
        return CommonOptionsBuilder = (function(superClass) {
          extend(CommonOptionsBuilder, superClass);
          function CommonOptionsBuilder() {
            this.watchProps = bind(this.watchProps, this);
            this.buildOpts = bind(this.buildOpts, this);
            return CommonOptionsBuilder.__super__.constructor.apply(this, arguments);
          }
          CommonOptionsBuilder.prototype.props = ['clickable', 'draggable', 'editable', 'visible', {
            prop: 'stroke',
            isColl: true
          }];
          CommonOptionsBuilder.prototype.getCorrectModel = function(scope) {
            if (angular.isDefined(scope != null ? scope.model : void 0)) {
              return scope.model;
            } else {
              return scope;
            }
          };
          CommonOptionsBuilder.prototype.buildOpts = function(customOpts, cachedEval, forEachOpts) {
            var model,
                opts,
                stroke;
            if (customOpts == null) {
              customOpts = {};
            }
            if (forEachOpts == null) {
              forEachOpts = {};
            }
            if (!this.scope) {
              $log.error('this.scope not defined in CommonOptionsBuilder can not buildOpts');
              return;
            }
            if (!this.gMap) {
              $log.error('this.map not defined in CommonOptionsBuilder can not buildOpts');
              return;
            }
            model = this.getCorrectModel(this.scope);
            stroke = this.scopeOrModelVal('stroke', this.scope, model);
            opts = angular.extend(customOpts, this.DEFAULTS, {
              map: this.gMap,
              strokeColor: stroke != null ? stroke.color : void 0,
              strokeOpacity: stroke != null ? stroke.opacity : void 0,
              strokeWeight: stroke != null ? stroke.weight : void 0
            });
            angular.forEach(angular.extend(forEachOpts, {
              clickable: true,
              draggable: false,
              editable: false,
              "static": false,
              fit: false,
              visible: true,
              zIndex: 0,
              icons: []
            }), (function(_this) {
              return function(defaultValue, key) {
                var val;
                val = cachedEval ? cachedEval[key] : _this.scopeOrModelVal(key, _this.scope, model);
                if (angular.isUndefined(val)) {
                  return opts[key] = defaultValue;
                } else {
                  return opts[key] = model[key];
                }
              };
            })(this));
            if (opts["static"]) {
              opts.editable = false;
            }
            return opts;
          };
          CommonOptionsBuilder.prototype.watchProps = function(props) {
            if (props == null) {
              props = this.props;
            }
            return props.forEach((function(_this) {
              return function(prop) {
                if ((_this.attrs[prop] != null) || (_this.attrs[prop != null ? prop.prop : void 0] != null)) {
                  if (prop != null ? prop.isColl : void 0) {
                    return _this.scope.$watchCollection(prop.prop, _this.setMyOptions);
                  } else {
                    return _this.scope.$watch(prop, _this.setMyOptions);
                  }
                }
              };
            })(this));
          };
          return CommonOptionsBuilder;
        })(ModelKey);
      }]);
    }).call(this);
    ;
    (function() {
      var extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      },
          hasProp = {}.hasOwnProperty;
      angular.module('uiGmapgoogle-maps.directives.api.options.builders').factory('uiGmapPolylineOptionsBuilder', ['uiGmapCommonOptionsBuilder', function(CommonOptionsBuilder) {
        var PolylineOptionsBuilder;
        return PolylineOptionsBuilder = (function(superClass) {
          extend(PolylineOptionsBuilder, superClass);
          function PolylineOptionsBuilder() {
            return PolylineOptionsBuilder.__super__.constructor.apply(this, arguments);
          }
          PolylineOptionsBuilder.prototype.buildOpts = function(pathPoints, cachedEval) {
            return PolylineOptionsBuilder.__super__.buildOpts.call(this, {path: pathPoints}, cachedEval, {geodesic: false});
          };
          return PolylineOptionsBuilder;
        })(CommonOptionsBuilder);
      }]).factory('uiGmapShapeOptionsBuilder', ['uiGmapCommonOptionsBuilder', function(CommonOptionsBuilder) {
        var ShapeOptionsBuilder;
        return ShapeOptionsBuilder = (function(superClass) {
          extend(ShapeOptionsBuilder, superClass);
          function ShapeOptionsBuilder() {
            return ShapeOptionsBuilder.__super__.constructor.apply(this, arguments);
          }
          ShapeOptionsBuilder.prototype.buildOpts = function(customOpts, cachedEval, forEachOpts) {
            var fill,
                model;
            model = this.getCorrectModel(this.scope);
            fill = cachedEval ? cachedEval['fill'] : this.scopeOrModelVal('fill', this.scope, model);
            customOpts = angular.extend(customOpts, {
              fillColor: fill != null ? fill.color : void 0,
              fillOpacity: fill != null ? fill.opacity : void 0
            });
            return ShapeOptionsBuilder.__super__.buildOpts.call(this, customOpts, cachedEval, forEachOpts);
          };
          return ShapeOptionsBuilder;
        })(CommonOptionsBuilder);
      }]).factory('uiGmapPolygonOptionsBuilder', ['uiGmapShapeOptionsBuilder', function(ShapeOptionsBuilder) {
        var PolygonOptionsBuilder;
        return PolygonOptionsBuilder = (function(superClass) {
          extend(PolygonOptionsBuilder, superClass);
          function PolygonOptionsBuilder() {
            return PolygonOptionsBuilder.__super__.constructor.apply(this, arguments);
          }
          PolygonOptionsBuilder.prototype.buildOpts = function(pathPoints, cachedEval) {
            return PolygonOptionsBuilder.__super__.buildOpts.call(this, {path: pathPoints}, cachedEval, {geodesic: false});
          };
          return PolygonOptionsBuilder;
        })(ShapeOptionsBuilder);
      }]).factory('uiGmapRectangleOptionsBuilder', ['uiGmapShapeOptionsBuilder', function(ShapeOptionsBuilder) {
        var RectangleOptionsBuilder;
        return RectangleOptionsBuilder = (function(superClass) {
          extend(RectangleOptionsBuilder, superClass);
          function RectangleOptionsBuilder() {
            return RectangleOptionsBuilder.__super__.constructor.apply(this, arguments);
          }
          RectangleOptionsBuilder.prototype.buildOpts = function(bounds, cachedEval) {
            return RectangleOptionsBuilder.__super__.buildOpts.call(this, {bounds: bounds}, cachedEval);
          };
          return RectangleOptionsBuilder;
        })(ShapeOptionsBuilder);
      }]).factory('uiGmapCircleOptionsBuilder', ['uiGmapShapeOptionsBuilder', function(ShapeOptionsBuilder) {
        var CircleOptionsBuilder;
        return CircleOptionsBuilder = (function(superClass) {
          extend(CircleOptionsBuilder, superClass);
          function CircleOptionsBuilder() {
            return CircleOptionsBuilder.__super__.constructor.apply(this, arguments);
          }
          CircleOptionsBuilder.prototype.buildOpts = function(center, radius, cachedEval) {
            return CircleOptionsBuilder.__super__.buildOpts.call(this, {
              center: center,
              radius: radius
            }, cachedEval);
          };
          return CircleOptionsBuilder;
        })(ShapeOptionsBuilder);
      }]);
    }).call(this);
    ;
    (function() {
      angular.module('uiGmapgoogle-maps.directives.api.options').service('uiGmapMarkerOptions', ['uiGmapLogger', 'uiGmapGmapUtil', function($log, GmapUtil) {
        return _.extend(GmapUtil, {
          createOptions: function(coords, icon, defaults, map) {
            var opts;
            if (defaults == null) {
              defaults = {};
            }
            opts = angular.extend({}, defaults, {
              position: defaults.position != null ? defaults.position : GmapUtil.getCoords(coords),
              visible: defaults.visible != null ? defaults.visible : GmapUtil.validateCoords(coords)
            });
            if ((defaults.icon != null) || (icon != null)) {
              opts = angular.extend(opts, {icon: defaults.icon != null ? defaults.icon : icon});
            }
            if (map != null) {
              opts.map = map;
            }
            return opts;
          },
          isLabel: function(options) {
            if (options == null) {
              return false;
            }
            return (options.labelContent != null) || (options.labelAnchor != null) || (options.labelClass != null) || (options.labelStyle != null) || (options.labelVisible != null);
          }
        });
      }]);
    }).call(this);
    ;
    (function() {
      var bind = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      },
          extend = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;
      angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapBasePolyChildModel', ['uiGmapLogger', '$timeout', 'uiGmaparray-sync', 'uiGmapGmapUtil', 'uiGmapEventsHelper', function($log, $timeout, arraySync, GmapUtil, EventsHelper) {
        return function(Builder, gFactory) {
          var BasePolyChildModel;
          return BasePolyChildModel = (function(superClass) {
            extend(BasePolyChildModel, superClass);
            BasePolyChildModel.include(GmapUtil);
            function BasePolyChildModel(arg) {
              var create,
                  gObjectChangeCb,
                  ref;
              this.scope = arg.scope, this.attrs = arg.attrs, this.gMap = arg.gMap, this.defaults = arg.defaults, this.model = arg.model, gObjectChangeCb = arg.gObjectChangeCb, this.isScopeModel = (ref = arg.isScopeModel) != null ? ref : false;
              this.clean = bind(this.clean, this);
              if (this.isScopeModel) {
                this.clonedModel = _.clone(this.model, true);
              }
              this.isDragging = false;
              this.internalEvents = {
                dragend: (function(_this) {
                  return function() {
                    return _.defer(function() {
                      return _this.isDragging = false;
                    });
                  };
                })(this),
                dragstart: (function(_this) {
                  return function() {
                    return _this.isDragging = true;
                  };
                })(this)
              };
              create = (function(_this) {
                return function() {
                  var maybeCachedEval;
                  if (_this.isDragging) {
                    return;
                  }
                  _this.pathPoints = _this.convertPathPoints(_this.scope.path);
                  if (_this.gObject != null) {
                    _this.clean();
                  }
                  if (_this.scope.model != null) {
                    maybeCachedEval = _this.scope;
                  }
                  if (_this.pathPoints.length > 0) {
                    _this.gObject = gFactory(_this.buildOpts(_this.pathPoints, maybeCachedEval));
                  }
                  if (_this.gObject) {
                    arraySync(_this.gObject.getPath(), _this.scope, 'path', function(pathPoints) {
                      _this.pathPoints = pathPoints;
                      if (gObjectChangeCb != null) {
                        return gObjectChangeCb();
                      }
                    });
                    if (angular.isDefined(_this.scope.events) && angular.isObject(_this.scope.events)) {
                      _this.listeners = _this.model ? EventsHelper.setEvents(_this.gObject, _this.scope, _this.model) : EventsHelper.setEvents(_this.gObject, _this.scope, _this.scope);
                    }
                    return _this.internalListeners = _this.model ? EventsHelper.setEvents(_this.gObject, {events: _this.internalEvents}, _this.model) : EventsHelper.setEvents(_this.gObject, {events: _this.internalEvents}, _this.scope);
                  }
                };
              })(this);
              create();
              this.scope.$watch('path', (function(_this) {
                return function(newValue, oldValue) {
                  if (!_.isEqual(newValue, oldValue) || !_this.gObject) {
                    return create();
                  }
                };
              })(this), true);
              if (!this.scope["static"] && angular.isDefined(this.scope.editable)) {
                this.scope.$watch('editable', (function(_this) {
                  return function(newValue, oldValue) {
                    var ref1;
                    if (newValue !== oldValue) {
                      newValue = !_this.isFalse(newValue);
                      return (ref1 = _this.gObject) != null ? ref1.setEditable(newValue) : void 0;
                    }
                  };
                })(this), true);
              }
              if (angular.isDefined(this.scope.draggable)) {
                this.scope.$watch('draggable', (function(_this) {
                  return function(newValue, oldValue) {
                    var ref1;
                    if (newValue !== oldValue) {
                      newValue = !_this.isFalse(newValue);
                      return (ref1 = _this.gObject) != null ? ref1.setDraggable(newValue) : void 0;
                    }
                  };
                })(this), true);
              }
              if (angular.isDefined(this.scope.visible)) {
                this.scope.$watch('visible', (function(_this) {
                  return function(newValue, oldValue) {
                    var ref1;
                    if (newValue !== oldValue) {
                      newValue = !_this.isFalse(newValue);
                    }
                    return (ref1 = _this.gObject) != null ? ref1.setVisible(newValue) : void 0;
                  };
                })(this), true);
              }
              if (angular.isDefined(this.scope.geodesic)) {
                this.scope.$watch('geodesic', (function(_this) {
                  return function(newValue, oldValue) {
                    var ref1;
                    if (newValue !== oldValue) {
                      newValue = !_this.isFalse(newValue);
                      return (ref1 = _this.gObject) != null ? ref1.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
                    }
                  };
                })(this), true);
              }
              if (angular.isDefined(this.scope.stroke) && angular.isDefined(this.scope.stroke.weight)) {
                this.scope.$watch('stroke.weight', (function(_this) {
                  return function(newValue, oldValue) {
                    var ref1;
                    if (newValue !== oldValue) {
                      return (ref1 = _this.gObject) != null ? ref1.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
                    }
                  };
                })(this), true);
              }
              if (angular.isDefined(this.scope.stroke) && angular.isDefined(this.scope.stroke.color)) {
                this.scope.$watch('stroke.color', (function(_this) {
                  return function(newValue, oldValue) {
                    var ref1;
                    if (newValue !== oldValue) {
                      return (ref1 = _this.gObject) != null ? ref1.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
                    }
                  };
                })(this), true);
              }
              if (angular.isDefined(this.scope.stroke) && angular.isDefined(this.scope.stroke.opacity)) {
                this.scope.$watch('stroke.opacity', (function(_this) {
                  return function(newValue, oldValue) {
                    var ref1;
                    if (newValue !== oldValue) {
                      return (ref1 = _this.gObject) != null ? ref1.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
                    }
                  };
                })(this), true);
              }
              if (angular.isDefined(this.scope.icons)) {
                this.scope.$watch('icons', (function(_this) {
                  return function(newValue, oldValue) {
                    var ref1;
                    if (newValue !== oldValue) {
                      return (ref1 = _this.gObject) != null ? ref1.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
                    }
                  };
                })(this), true);
              }
              this.scope.$on('$destroy', (function(_this) {
                return function() {
                  _this.clean();
                  return _this.scope = null;
                };
              })(this));
              if (angular.isDefined(this.scope.fill) && angular.isDefined(this.scope.fill.color)) {
                this.scope.$watch('fill.color', (function(_this) {
                  return function(newValue, oldValue) {
                    if (newValue !== oldValue) {
                      return _this.gObject.setOptions(_this.buildOpts(_this.gObject.getPath()));
                    }
                  };
                })(this));
              }
              if (angular.isDefined(this.scope.fill) && angular.isDefined(this.scope.fill.opacity)) {
                this.scope.$watch('fill.opacity', (function(_this) {
                  return function(newValue, oldValue) {
                    if (newValue !== oldValue) {
                      return _this.gObject.setOptions(_this.buildOpts(_this.gObject.getPath()));
                    }
                  };
                })(this));
              }
              if (angular.isDefined(this.scope.zIndex)) {
                this.scope.$watch('zIndex', (function(_this) {
                  return function(newValue, oldValue) {
                    if (newValue !== oldValue) {
                      return _this.gObject.setOptions(_this.buildOpts(_this.gObject.getPath()));
                    }
                  };
                })(this));
              }
            }
            BasePolyChildModel.prototype.clean = function() {
              var ref;
              EventsHelper.removeEvents(this.listeners);
              EventsHelper.removeEvents(this.internalListeners);
              if ((ref = this.gObject) != null) {
                ref.setMap(null);
              }
              return this.gObject = null;
            };
            return BasePolyChildModel;
          })(Builder);
        };
      }]);
    }).call(this);
    ;
    (function() {
      angular.module('uiGmapgoogle-maps.directives.api.models.child').factory('uiGmapDrawFreeHandChildModel', ['uiGmapLogger', '$q', function($log, $q) {
        var drawFreeHand,
            freeHandMgr;
        drawFreeHand = function(map, polys, done) {
          var move,
              poly;
          poly = new google.maps.Polyline({
            map: map,
            clickable: false
          });
          move = google.maps.event.addListener(map, 'mousemove', function(e) {
            return poly.getPath().push(e.latLng);
          });
          google.maps.event.addListenerOnce(map, 'mouseup', function(e) {
            var path;
            google.maps.event.removeListener(move);
            path = poly.getPath();
            poly.setMap(null);
            polys.push(new google.maps.Polygon({
              map: map,
              path: path
            }));
            poly = null;
            google.maps.event.clearListeners(map.getDiv(), 'mousedown');
            return done();
          });
          return void 0;
        };
        freeHandMgr = function(map1, scope) {
          var disableMap,
              enableMap;
          this.map = map1;
          disableMap = (function(_this) {
            return function() {
              var mapOptions;
              mapOptions = {
                draggable: false,
                disableDefaultUI: true,
                scrollwheel: false,
                disableDoubleClickZoom: false
              };
              $log.info('disabling map move');
              return _this.map.setOptions(mapOptions);
            };
          })(this);
          enableMap = (function(_this) {
            return function() {
              var mapOptions,
                  ref;
              mapOptions = {
                draggable: true,
                disableDefaultUI: false,
                scrollwheel: true,
                disableDoubleClickZoom: true
              };
              if ((ref = _this.deferred) != null) {
                ref.resolve();
              }
              return _.defer(function() {
                return _this.map.setOptions(_.extend(mapOptions, scope.options));
              });
            };
          })(this);
          this.engage = (function(_this) {
            return function(polys1) {
              _this.polys = polys1;
              _this.deferred = $q.defer();
              disableMap();
              $log.info('DrawFreeHandChildModel is engaged (drawing).');
              google.maps.event.addDomListener(_this.map.getDiv(), 'mousedown', function(e) {
                return drawFreeHand(_this.map, _this.polys, enableMap);
              });
              return _this.deferred.promise;
            };
          })(this);
          return this;
        };
        return freeHandMgr;
      }]);
    }).call(this);
    ;
    (function() {
      var bind = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      },
          extend = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;
      angular.module('uiGmapgoogle-maps.directives.api.models.child').factory('uiGmapMarkerChildModel', ['uiGmapModelKey', 'uiGmapGmapUtil', 'uiGmapLogger', 'uiGmapEventsHelper', 'uiGmapPropertyAction', 'uiGmapMarkerOptions', 'uiGmapIMarker', 'uiGmapMarkerManager', 'uiGmapPromise', function(ModelKey, GmapUtil, $log, EventsHelper, PropertyAction, MarkerOptions, IMarker, MarkerManager, uiGmapPromise) {
        var MarkerChildModel;
        MarkerChildModel = (function(superClass) {
          var destroy;
          extend(MarkerChildModel, superClass);
          MarkerChildModel.include(GmapUtil);
          MarkerChildModel.include(EventsHelper);
          MarkerChildModel.include(MarkerOptions);
          destroy = function(child) {
            if ((child != null ? child.gObject : void 0) != null) {
              child.removeEvents(child.externalListeners);
              child.removeEvents(child.internalListeners);
              if (child != null ? child.gObject : void 0) {
                if (child.removeFromManager) {
                  child.gManager.remove(child.gObject);
                }
                child.gObject.setMap(null);
                return child.gObject = null;
              }
            }
          };
          function MarkerChildModel(opts) {
            this.internalEvents = bind(this.internalEvents, this);
            this.setLabelOptions = bind(this.setLabelOptions, this);
            this.setOptions = bind(this.setOptions, this);
            this.setIcon = bind(this.setIcon, this);
            this.setCoords = bind(this.setCoords, this);
            this.isNotValid = bind(this.isNotValid, this);
            this.maybeSetScopeValue = bind(this.maybeSetScopeValue, this);
            this.createMarker = bind(this.createMarker, this);
            this.setMyScope = bind(this.setMyScope, this);
            this.updateModel = bind(this.updateModel, this);
            this.handleModelChanges = bind(this.handleModelChanges, this);
            this.destroy = bind(this.destroy, this);
            var action,
                ref,
                ref1,
                ref2,
                ref3,
                ref4,
                scope;
            scope = opts.scope, this.model = opts.model, this.keys = opts.keys, this.gMap = opts.gMap, this.defaults = (ref = opts.defaults) != null ? ref : {}, this.doClick = opts.doClick, this.gManager = opts.gManager, this.doDrawSelf = (ref1 = opts.doDrawSelf) != null ? ref1 : true, this.trackModel = (ref2 = opts.trackModel) != null ? ref2 : true, this.needRedraw = (ref3 = opts.needRedraw) != null ? ref3 : false, this.isScopeModel = (ref4 = opts.isScopeModel) != null ? ref4 : false;
            if (this.isScopeModel) {
              this.clonedModel = _.clone(this.model, true);
            }
            this.deferred = uiGmapPromise.defer();
            _.each(this.keys, (function(_this) {
              return function(v, k) {
                var keyValue;
                keyValue = _this.keys[k];
                if ((keyValue != null) && !_.isFunction(keyValue) && _.isString(keyValue)) {
                  return _this[k + 'Key'] = keyValue;
                }
              };
            })(this));
            this.idKey = this.idKeyKey || 'id';
            if (this.model[this.idKey] != null) {
              this.id = this.model[this.idKey];
            }
            MarkerChildModel.__super__.constructor.call(this, scope);
            this.scope.getGMarker = (function(_this) {
              return function() {
                return _this.gObject;
              };
            })(this);
            this.firstTime = true;
            if (this.trackModel) {
              this.scope.model = this.model;
              this.scope.$watch('model', (function(_this) {
                return function(newValue, oldValue) {
                  if (newValue !== oldValue) {
                    return _this.handleModelChanges(newValue, oldValue);
                  }
                };
              })(this), true);
            } else {
              action = new PropertyAction((function(_this) {
                return function(calledKey) {
                  if (_.isFunction(calledKey)) {
                    calledKey = 'all';
                  }
                  if (!_this.firstTime) {
                    return _this.setMyScope(calledKey, scope);
                  }
                };
              })(this), false);
              _.each(this.keys, function(v, k) {
                return scope.$watch(k, action.sic(k), true);
              });
            }
            this.scope.$on('$destroy', (function(_this) {
              return function() {
                return destroy(_this);
              };
            })(this));
            this.createMarker(this.model);
            $log.info(this);
          }
          MarkerChildModel.prototype.destroy = function(removeFromManager) {
            if (removeFromManager == null) {
              removeFromManager = true;
            }
            this.removeFromManager = removeFromManager;
            return this.scope.$destroy();
          };
          MarkerChildModel.prototype.handleModelChanges = function(newValue, oldValue) {
            var changes,
                ctr,
                len;
            changes = this.getChanges(newValue, oldValue, IMarker.keys);
            if (!this.firstTime) {
              ctr = 0;
              len = _.keys(changes).length;
              return _.each(changes, (function(_this) {
                return function(v, k) {
                  var doDraw;
                  ctr += 1;
                  doDraw = len === ctr;
                  _this.setMyScope(k, newValue, oldValue, false, true, doDraw);
                  return _this.needRedraw = true;
                };
              })(this));
            }
          };
          MarkerChildModel.prototype.updateModel = function(model) {
            if (this.isScopeModel) {
              this.clonedModel = _.clone(model, true);
            }
            return this.setMyScope('all', model, this.model);
          };
          MarkerChildModel.prototype.renderGMarker = function(doDraw, validCb) {
            var coords,
                isSpiderfied,
                ref;
            if (doDraw == null) {
              doDraw = true;
            }
            coords = this.getProp('coords', this.scope, this.model);
            if (((ref = this.gManager) != null ? ref.isSpiderfied : void 0) != null) {
              isSpiderfied = this.gManager.isSpiderfied();
            }
            if (coords != null) {
              if (!this.validateCoords(coords)) {
                $log.debug('MarkerChild does not have coords yet. They may be defined later.');
                return;
              }
              if (validCb != null) {
                validCb();
              }
              if (doDraw && this.gObject) {
                this.gManager.add(this.gObject);
              }
              if (isSpiderfied) {
                return this.gManager.markerSpiderfier.spiderListener(this.gObject, window.event);
              }
            } else {
              if (doDraw && this.gObject) {
                return this.gManager.remove(this.gObject);
              }
            }
          };
          MarkerChildModel.prototype.setMyScope = function(thingThatChanged, model, oldModel, isInit, doDraw) {
            var justCreated;
            if (oldModel == null) {
              oldModel = void 0;
            }
            if (isInit == null) {
              isInit = false;
            }
            if (doDraw == null) {
              doDraw = true;
            }
            if (model == null) {
              model = this.model;
            } else {
              this.model = model;
            }
            if (!this.gObject) {
              this.setOptions(this.scope, doDraw);
              justCreated = true;
            }
            switch (thingThatChanged) {
              case 'all':
                return _.each(this.keys, (function(_this) {
                  return function(v, k) {
                    return _this.setMyScope(k, model, oldModel, isInit, doDraw);
                  };
                })(this));
              case 'icon':
                return this.maybeSetScopeValue({
                  gSetter: this.setIcon,
                  doDraw: doDraw
                });
              case 'coords':
                return this.maybeSetScopeValue({
                  gSetter: this.setCoords,
                  doDraw: doDraw
                });
              case 'options':
                if (!justCreated) {
                  return this.createMarker(model, oldModel, isInit, doDraw);
                }
            }
          };
          MarkerChildModel.prototype.createMarker = function(model, oldModel, isInit, doDraw) {
            if (oldModel == null) {
              oldModel = void 0;
            }
            if (isInit == null) {
              isInit = false;
            }
            if (doDraw == null) {
              doDraw = true;
            }
            this.maybeSetScopeValue({
              gSetter: this.setOptions,
              doDraw: doDraw
            });
            return this.firstTime = false;
          };
          MarkerChildModel.prototype.maybeSetScopeValue = function(arg) {
            var doDraw,
                gSetter,
                ref;
            gSetter = arg.gSetter, doDraw = (ref = arg.doDraw) != null ? ref : true;
            if (gSetter != null) {
              gSetter(this.scope, doDraw);
            }
            if (this.doDrawSelf && doDraw) {
              return this.gManager.draw();
            }
          };
          MarkerChildModel.prototype.isNotValid = function(scope, doCheckGmarker) {
            var hasIdenticalScopes,
                hasNoGmarker;
            if (doCheckGmarker == null) {
              doCheckGmarker = true;
            }
            hasNoGmarker = !doCheckGmarker ? false : this.gObject === void 0;
            hasIdenticalScopes = !this.trackModel ? scope.$id !== this.scope.$id : false;
            return hasIdenticalScopes || hasNoGmarker;
          };
          MarkerChildModel.prototype.setCoords = function(scope, doDraw) {
            if (doDraw == null) {
              doDraw = true;
            }
            if (this.isNotValid(scope) || (this.gObject == null)) {
              return;
            }
            return this.renderGMarker(doDraw, (function(_this) {
              return function() {
                var newGValue,
                    newModelVal,
                    oldGValue;
                newModelVal = _this.getProp('coords', scope, _this.model);
                newGValue = _this.getCoords(newModelVal);
                oldGValue = _this.gObject.getPosition();
                if ((oldGValue != null) && (newGValue != null)) {
                  if (newGValue.lng() === oldGValue.lng() && newGValue.lat() === oldGValue.lat()) {
                    return;
                  }
                }
                _this.gObject.setPosition(newGValue);
                return _this.gObject.setVisible(_this.validateCoords(newModelVal));
              };
            })(this));
          };
          MarkerChildModel.prototype.setIcon = function(scope, doDraw) {
            if (doDraw == null) {
              doDraw = true;
            }
            if (this.isNotValid(scope) || (this.gObject == null)) {
              return;
            }
            return this.renderGMarker(doDraw, (function(_this) {
              return function() {
                var coords,
                    newValue,
                    oldValue;
                oldValue = _this.gObject.getIcon();
                newValue = _this.getProp('icon', scope, _this.model);
                if (oldValue === newValue) {
                  return;
                }
                _this.gObject.setIcon(newValue);
                coords = _this.getProp('coords', scope, _this.model);
                _this.gObject.setPosition(_this.getCoords(coords));
                return _this.gObject.setVisible(_this.validateCoords(coords));
              };
            })(this));
          };
          MarkerChildModel.prototype.setOptions = function(scope, doDraw) {
            var ref;
            if (doDraw == null) {
              doDraw = true;
            }
            if (this.isNotValid(scope, false)) {
              return;
            }
            this.renderGMarker(doDraw, (function(_this) {
              return function() {
                var _options,
                    coords,
                    icon;
                coords = _this.getProp('coords', scope, _this.model);
                icon = _this.getProp('icon', scope, _this.model);
                _options = _this.getProp('options', scope, _this.model);
                _this.opts = _this.createOptions(coords, icon, _options);
                if (_this.isLabel(_this.gObject) !== _this.isLabel(_this.opts) && (_this.gObject != null)) {
                  _this.gManager.remove(_this.gObject);
                  _this.gObject = void 0;
                }
                if (_this.gObject != null) {
                  _this.gObject.setOptions(_this.setLabelOptions(_this.opts));
                }
                if (!_this.gObject) {
                  if (_this.isLabel(_this.opts)) {
                    _this.gObject = new MarkerWithLabel(_this.setLabelOptions(_this.opts));
                  } else if (_this.opts.content) {
                    _this.gObject = new RichMarker(_this.opts);
                    _this.gObject.getIcon = _this.gObject.getContent;
                    _this.gObject.setIcon = _this.gObject.setContent;
                  } else {
                    _this.gObject = new google.maps.Marker(_this.opts);
                  }
                  _.extend(_this.gObject, {model: _this.model});
                }
                if (_this.externalListeners) {
                  _this.removeEvents(_this.externalListeners);
                }
                if (_this.internalListeners) {
                  _this.removeEvents(_this.internalListeners);
                }
                _this.externalListeners = _this.setEvents(_this.gObject, _this.scope, _this.model, ['dragend']);
                _this.internalListeners = _this.setEvents(_this.gObject, {
                  events: _this.internalEvents(),
                  $evalAsync: function() {}
                }, _this.model);
                if (_this.id != null) {
                  return _this.gObject.key = _this.id;
                }
              };
            })(this));
            if (this.gObject && (this.gObject.getMap() || this.gManager.type !== MarkerManager.type)) {
              this.deferred.resolve(this.gObject);
            } else {
              if (!this.gObject) {
                return this.deferred.reject('gObject is null');
              }
              if (!(((ref = this.gObject) != null ? ref.getMap() : void 0) && this.gManager.type === MarkerManager.type)) {
                $log.debug('gObject has no map yet');
                this.deferred.resolve(this.gObject);
              }
            }
            if (this.model[this.fitKey]) {
              return this.gManager.fit();
            }
          };
          MarkerChildModel.prototype.setLabelOptions = function(opts) {
            if (opts.labelAnchor) {
              opts.labelAnchor = this.getLabelPositionPoint(opts.labelAnchor);
            }
            return opts;
          };
          MarkerChildModel.prototype.internalEvents = function() {
            return {
              dragend: (function(_this) {
                return function(marker, eventName, model, mousearg) {
                  var events,
                      modelToSet,
                      newCoords;
                  modelToSet = _this.trackModel ? _this.scope.model : _this.model;
                  newCoords = _this.setCoordsFromEvent(_this.modelOrKey(modelToSet, _this.coordsKey), _this.gObject.getPosition());
                  modelToSet = _this.setVal(model, _this.coordsKey, newCoords);
                  events = _this.scope.events;
                  if ((events != null ? events.dragend : void 0) != null) {
                    events.dragend(marker, eventName, modelToSet, mousearg);
                  }
                  return _this.scope.$apply();
                };
              })(this),
              click: (function(_this) {
                return function(marker, eventName, model, mousearg) {
                  var click;
                  click = _this.getProp('click', _this.scope, _this.model);
                  if (_this.doClick && angular.isFunction(click)) {
                    return _this.scope.$evalAsync(click(marker, eventName, _this.model, mousearg));
                  }
                };
              })(this)
            };
          };
          return MarkerChildModel;
        })(ModelKey);
        return MarkerChildModel;
      }]);
    }).call(this);
    ;
    (function() {
      var extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      },
          hasProp = {}.hasOwnProperty;
      angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapPolygonChildModel', ['uiGmapBasePolyChildModel', 'uiGmapPolygonOptionsBuilder', function(BaseGen, Builder) {
        var PolygonChildModel,
            base,
            gFactory;
        gFactory = function(opts) {
          return new google.maps.Polygon(opts);
        };
        base = new BaseGen(Builder, gFactory);
        return PolygonChildModel = (function(superClass) {
          extend(PolygonChildModel, superClass);
          function PolygonChildModel() {
            return PolygonChildModel.__super__.constructor.apply(this, arguments);
          }
          return PolygonChildModel;
        })(base);
      }]);
    }).call(this);
    ;
    (function() {
      var extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      },
          hasProp = {}.hasOwnProperty;
      angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapPolylineChildModel', ['uiGmapBasePolyChildModel', 'uiGmapPolylineOptionsBuilder', function(BaseGen, Builder) {
        var PolylineChildModel,
            base,
            gFactory;
        gFactory = function(opts) {
          return new google.maps.Polyline(opts);
        };
        base = BaseGen(Builder, gFactory);
        return PolylineChildModel = (function(superClass) {
          extend(PolylineChildModel, superClass);
          function PolylineChildModel() {
            return PolylineChildModel.__super__.constructor.apply(this, arguments);
          }
          return PolylineChildModel;
        })(base);
      }]);
    }).call(this);
    ;
    (function() {
      var bind = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      },
          extend = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;
      angular.module('uiGmapgoogle-maps.directives.api.models.child').factory('uiGmapWindowChildModel', ['uiGmapBaseObject', 'uiGmapGmapUtil', 'uiGmapLogger', '$compile', '$http', '$templateCache', 'uiGmapChromeFixes', 'uiGmapEventsHelper', function(BaseObject, GmapUtil, $log, $compile, $http, $templateCache, ChromeFixes, EventsHelper) {
        var WindowChildModel;
        WindowChildModel = (function(superClass) {
          extend(WindowChildModel, superClass);
          WindowChildModel.include(GmapUtil);
          WindowChildModel.include(EventsHelper);
          function WindowChildModel(opts) {
            this.updateModel = bind(this.updateModel, this);
            this.destroy = bind(this.destroy, this);
            this.remove = bind(this.remove, this);
            this.getLatestPosition = bind(this.getLatestPosition, this);
            this.hideWindow = bind(this.hideWindow, this);
            this.showWindow = bind(this.showWindow, this);
            this.handleClick = bind(this.handleClick, this);
            this.watchOptions = bind(this.watchOptions, this);
            this.watchCoords = bind(this.watchCoords, this);
            this.createGWin = bind(this.createGWin, this);
            this.watchElement = bind(this.watchElement, this);
            this.watchAndDoShow = bind(this.watchAndDoShow, this);
            this.doShow = bind(this.doShow, this);
            var maybeMarker,
                ref,
                ref1,
                ref2,
                ref3;
            this.model = (ref = opts.model) != null ? ref : {}, this.scope = opts.scope, this.opts = opts.opts, this.isIconVisibleOnClick = opts.isIconVisibleOnClick, this.gMap = opts.gMap, this.markerScope = opts.markerScope, this.element = opts.element, this.needToManualDestroy = (ref1 = opts.needToManualDestroy) != null ? ref1 : false, this.markerIsVisibleAfterWindowClose = (ref2 = opts.markerIsVisibleAfterWindowClose) != null ? ref2 : true, this.isScopeModel = (ref3 = opts.isScopeModel) != null ? ref3 : false;
            if (this.isScopeModel) {
              this.clonedModel = _.clone(this.model, true);
            }
            this.getGmarker = function() {
              var ref4,
                  ref5;
              if (((ref4 = this.markerScope) != null ? ref4['getGMarker'] : void 0) != null) {
                return (ref5 = this.markerScope) != null ? ref5.getGMarker() : void 0;
              }
            };
            this.listeners = [];
            this.createGWin();
            maybeMarker = this.getGmarker();
            if (maybeMarker != null) {
              maybeMarker.setClickable(true);
            }
            this.watchElement();
            this.watchOptions();
            this.watchCoords();
            this.watchAndDoShow();
            this.scope.$on('$destroy', (function(_this) {
              return function() {
                return _this.destroy();
              };
            })(this));
            $log.info(this);
          }
          WindowChildModel.prototype.doShow = function(wasOpen) {
            if (this.scope.show === true || wasOpen) {
              return this.showWindow();
            } else {
              return this.hideWindow();
            }
          };
          WindowChildModel.prototype.watchAndDoShow = function() {
            if (this.model.show != null) {
              this.scope.show = this.model.show;
            }
            this.scope.$watch('show', this.doShow, true);
            return this.doShow();
          };
          WindowChildModel.prototype.watchElement = function() {
            return this.scope.$watch((function(_this) {
              return function() {
                var ref,
                    wasOpen;
                if (!(_this.element || _this.html)) {
                  return;
                }
                if (_this.html !== _this.element.html() && _this.gObject) {
                  if ((ref = _this.opts) != null) {
                    ref.content = void 0;
                  }
                  wasOpen = _this.gObject.isOpen();
                  _this.remove();
                  return _this.createGWin(wasOpen);
                }
              };
            })(this));
          };
          WindowChildModel.prototype.createGWin = function(isOpen) {
            var _opts,
                defaults,
                maybeMarker,
                ref,
                ref1;
            if (isOpen == null) {
              isOpen = false;
            }
            maybeMarker = this.getGmarker();
            defaults = {};
            if (this.opts != null) {
              if (this.scope.coords) {
                this.opts.position = this.getCoords(this.scope.coords);
              }
              defaults = this.opts;
            }
            if (this.element) {
              this.html = _.isObject(this.element) ? this.element.html() : this.element;
            }
            _opts = this.scope.options ? this.scope.options : defaults;
            this.opts = this.createWindowOptions(maybeMarker, this.markerScope || this.scope, this.html, _opts);
            if (this.opts != null) {
              if (!this.gObject) {
                if (this.opts.boxClass && (window.InfoBox && typeof window.InfoBox === 'function')) {
                  this.gObject = new window.InfoBox(this.opts);
                } else {
                  this.gObject = new google.maps.InfoWindow(this.opts);
                }
                this.listeners.push(google.maps.event.addListener(this.gObject, 'domready', function() {
                  return ChromeFixes.maybeRepaint(this.content);
                }));
                this.listeners.push(google.maps.event.addListener(this.gObject, 'closeclick', (function(_this) {
                  return function() {
                    if (maybeMarker) {
                      maybeMarker.setAnimation(_this.oldMarkerAnimation);
                      if (_this.markerIsVisibleAfterWindowClose) {
                        _.delay(function() {
                          maybeMarker.setVisible(false);
                          return maybeMarker.setVisible(_this.markerIsVisibleAfterWindowClose);
                        }, 250);
                      }
                    }
                    _this.gObject.close();
                    _this.model.show = false;
                    if (_this.scope.closeClick != null) {
                      return _this.scope.$evalAsync(_this.scope.closeClick());
                    } else {
                      return _this.scope.$evalAsync();
                    }
                  };
                })(this)));
              }
              this.gObject.setContent(this.opts.content);
              this.handleClick(((ref = this.scope) != null ? (ref1 = ref.options) != null ? ref1.forceClick : void 0 : void 0) || isOpen);
              return this.doShow(this.gObject.isOpen());
            }
          };
          WindowChildModel.prototype.watchCoords = function() {
            var scope;
            scope = this.markerScope != null ? this.markerScope : this.scope;
            return scope.$watch('coords', (function(_this) {
              return function(newValue, oldValue) {
                var pos;
                if (newValue !== oldValue) {
                  if (newValue == null) {
                    _this.hideWindow();
                  } else if (!_this.validateCoords(newValue)) {
                    $log.error("WindowChildMarker cannot render marker as scope.coords as no position on marker: " + (JSON.stringify(_this.model)));
                    return;
                  }
                  pos = _this.getCoords(newValue);
                  _this.doShow();
                  _this.gObject.setPosition(pos);
                  if (_this.opts) {
                    return _this.opts.position = pos;
                  }
                }
              };
            })(this), true);
          };
          WindowChildModel.prototype.watchOptions = function() {
            return this.scope.$watch('options', (function(_this) {
              return function(newValue, oldValue) {
                if (newValue !== oldValue) {
                  _this.opts = newValue;
                  if (_this.gObject != null) {
                    _this.gObject.setOptions(_this.opts);
                    if ((_this.opts.visible != null) && _this.opts.visible) {
                      return _this.showWindow();
                    } else if (_this.opts.visible != null) {
                      return _this.hideWindow();
                    }
                  }
                }
              };
            })(this), true);
          };
          WindowChildModel.prototype.handleClick = function(forceClick) {
            var click,
                maybeMarker;
            if (this.gObject == null) {
              return;
            }
            maybeMarker = this.getGmarker();
            click = (function(_this) {
              return function() {
                if (_this.gObject == null) {
                  _this.createGWin();
                }
                _this.showWindow();
                if (maybeMarker != null) {
                  _this.initialMarkerVisibility = maybeMarker.getVisible();
                  _this.oldMarkerAnimation = maybeMarker.getAnimation();
                  return maybeMarker.setVisible(_this.isIconVisibleOnClick);
                }
              };
            })(this);
            if (forceClick) {
              click();
            }
            if (maybeMarker) {
              return this.listeners = this.listeners.concat(this.setEvents(maybeMarker, {events: {click: click}}, this.model));
            }
          };
          WindowChildModel.prototype.showWindow = function() {
            var compiled,
                show,
                templateScope;
            if (this.gObject == null) {
              return;
            }
            templateScope = null;
            show = (function(_this) {
              return function() {
                var isOpen,
                    maybeMarker,
                    pos;
                if (!_this.gObject.isOpen()) {
                  maybeMarker = _this.getGmarker();
                  if ((_this.gObject != null) && (_this.gObject.getPosition != null)) {
                    pos = _this.gObject.getPosition();
                  }
                  if (maybeMarker) {
                    pos = maybeMarker.getPosition();
                  }
                  if (!pos) {
                    return;
                  }
                  _this.gObject.open(_this.gMap, maybeMarker);
                  isOpen = _this.gObject.isOpen();
                  if (_this.model.show !== isOpen) {
                    return _this.model.show = isOpen;
                  }
                }
              };
            })(this);
            if (this.scope.templateUrl) {
              $http.get(this.scope.templateUrl, {cache: $templateCache}).then((function(_this) {
                return function(content) {
                  var compiled;
                  templateScope = _this.scope.$new();
                  if (angular.isDefined(_this.scope.templateParameter)) {
                    templateScope.parameter = _this.scope.templateParameter;
                  }
                  compiled = $compile(content.data)(templateScope);
                  _this.gObject.setContent(compiled[0]);
                  return show();
                };
              })(this));
            } else if (this.scope.template) {
              templateScope = this.scope.$new();
              if (angular.isDefined(this.scope.templateParameter)) {
                templateScope.parameter = this.scope.templateParameter;
              }
              compiled = $compile(this.scope.template)(templateScope);
              this.gObject.setContent(compiled[0]);
              show();
            } else {
              show();
            }
            return this.scope.$on('destroy', function() {
              return templateScope.$destroy();
            });
          };
          WindowChildModel.prototype.hideWindow = function() {
            if ((this.gObject != null) && this.gObject.isOpen()) {
              return this.gObject.close();
            }
          };
          WindowChildModel.prototype.getLatestPosition = function(overridePos) {
            var maybeMarker;
            maybeMarker = this.getGmarker();
            if ((this.gObject != null) && (maybeMarker != null) && !overridePos) {
              return this.gObject.setPosition(maybeMarker.getPosition());
            } else {
              if (overridePos) {
                return this.gObject.setPosition(overridePos);
              }
            }
          };
          WindowChildModel.prototype.remove = function() {
            this.hideWindow();
            this.removeEvents(this.listeners);
            this.listeners.length = 0;
            delete this.gObject;
            return delete this.opts;
          };
          WindowChildModel.prototype.destroy = function(manualOverride) {
            var ref;
            if (manualOverride == null) {
              manualOverride = false;
            }
            this.remove();
            if (((this.scope != null) && !((ref = this.scope) != null ? ref.$$destroyed : void 0)) && (this.needToManualDestroy || manualOverride)) {
              return this.scope.$destroy();
            }
          };
          WindowChildModel.prototype.updateModel = function(model) {
            if (this.isScopeModel) {
              this.clonedModel = _.clone(model, true);
            }
            return _.extend(this.model, this.clonedModel || model);
          };
          return WindowChildModel;
        })(BaseObject);
        return WindowChildModel;
      }]);
    }).call(this);
    ;
    (function() {
      var bind = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      },
          extend = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;
      angular.module('uiGmapgoogle-maps.directives.api.models.parent').factory('uiGmapBasePolysParentModel', ['$timeout', 'uiGmapLogger', 'uiGmapModelKey', 'uiGmapModelsWatcher', 'uiGmapPropMap', 'uiGmap_async', 'uiGmapPromise', 'uiGmapFitHelper', function($timeout, $log, ModelKey, ModelsWatcher, PropMap, _async, uiGmapPromise, FitHelper) {
        return function(IPoly, PolyChildModel, gObjectName) {
          var BasePolysParentModel;
          return BasePolysParentModel = (function(superClass) {
            extend(BasePolysParentModel, superClass);
            BasePolysParentModel.include(ModelsWatcher);
            function BasePolysParentModel(scope, element, attrs, gMap1, defaults) {
              this.element = element;
              this.attrs = attrs;
              this.gMap = gMap1;
              this.defaults = defaults;
              this.maybeFit = bind(this.maybeFit, this);
              this.createChild = bind(this.createChild, this);
              this.pieceMeal = bind(this.pieceMeal, this);
              this.createAllNew = bind(this.createAllNew, this);
              this.watchIdKey = bind(this.watchIdKey, this);
              this.createChildScopes = bind(this.createChildScopes, this);
              this.watchDestroy = bind(this.watchDestroy, this);
              this.onDestroy = bind(this.onDestroy, this);
              this.rebuildAll = bind(this.rebuildAll, this);
              this.doINeedToWipe = bind(this.doINeedToWipe, this);
              this.watchModels = bind(this.watchModels, this);
              BasePolysParentModel.__super__.constructor.call(this, scope);
              this["interface"] = IPoly;
              this.$log = $log;
              this.plurals = new PropMap();
              _.each(IPoly.scopeKeys, (function(_this) {
                return function(name) {
                  return _this[name + 'Key'] = void 0;
                };
              })(this));
              this.models = void 0;
              this.firstTime = true;
              this.$log.info(this);
              this.createChildScopes();
            }
            BasePolysParentModel.prototype.watchModels = function(scope) {
              return scope.$watch('models', (function(_this) {
                return function(newValue, oldValue) {
                  if (newValue !== oldValue) {
                    if (_this.doINeedToWipe(newValue) || scope.doRebuildAll) {
                      return _this.rebuildAll(scope, true, true);
                    } else {
                      return _this.createChildScopes(false);
                    }
                  }
                };
              })(this), true);
            };
            BasePolysParentModel.prototype.doINeedToWipe = function(newValue) {
              var newValueIsEmpty;
              newValueIsEmpty = newValue != null ? newValue.length === 0 : true;
              return this.plurals.length > 0 && newValueIsEmpty;
            };
            BasePolysParentModel.prototype.rebuildAll = function(scope, doCreate, doDelete) {
              return this.onDestroy(doDelete).then((function(_this) {
                return function() {
                  if (doCreate) {
                    return _this.createChildScopes();
                  }
                };
              })(this));
            };
            BasePolysParentModel.prototype.onDestroy = function() {
              BasePolysParentModel.__super__.onDestroy.call(this, this.scope);
              return _async.promiseLock(this, uiGmapPromise.promiseTypes["delete"], void 0, void 0, (function(_this) {
                return function() {
                  return _async.each(_this.plurals.values(), function(child) {
                    return child.destroy(true);
                  }, _async.chunkSizeFrom(_this.scope.cleanchunk, false)).then(function() {
                    var ref;
                    return (ref = _this.plurals) != null ? ref.removeAll() : void 0;
                  });
                };
              })(this));
            };
            BasePolysParentModel.prototype.watchDestroy = function(scope) {
              return scope.$on('$destroy', (function(_this) {
                return function() {
                  return _this.rebuildAll(scope, false, true);
                };
              })(this));
            };
            BasePolysParentModel.prototype.createChildScopes = function(isCreatingFromScratch) {
              if (isCreatingFromScratch == null) {
                isCreatingFromScratch = true;
              }
              if (angular.isUndefined(this.scope.models)) {
                this.$log.error("No models to create " + gObjectName + "s from! I Need direct models!");
                return;
              }
              if ((this.gMap == null) || (this.scope.models == null)) {
                return;
              }
              this.watchIdKey(this.scope);
              if (isCreatingFromScratch) {
                return this.createAllNew(this.scope, false);
              } else {
                return this.pieceMeal(this.scope, false);
              }
            };
            BasePolysParentModel.prototype.watchIdKey = function(scope) {
              this.setIdKey(scope);
              return scope.$watch('idKey', (function(_this) {
                return function(newValue, oldValue) {
                  if (newValue !== oldValue && (newValue == null)) {
                    _this.idKey = newValue;
                    return _this.rebuildAll(scope, true, true);
                  }
                };
              })(this));
            };
            BasePolysParentModel.prototype.createAllNew = function(scope, isArray) {
              var maybeCanceled;
              if (isArray == null) {
                isArray = false;
              }
              this.models = scope.models;
              if (this.firstTime) {
                this.watchModels(scope);
                this.watchDestroy(scope);
              }
              if (this.didQueueInitPromise(this, scope)) {
                return;
              }
              maybeCanceled = null;
              return _async.promiseLock(this, uiGmapPromise.promiseTypes.create, 'createAllNew', (function(canceledMsg) {
                return maybeCanceled = canceledMsg;
              }), (function(_this) {
                return function() {
                  return _async.map(scope.models, function(model) {
                    var child;
                    child = _this.createChild(model, _this.gMap);
                    if (maybeCanceled) {
                      $log.debug('createNew should fall through safely');
                      child.isEnabled = false;
                    }
                    maybeCanceled;
                    return child.pathPoints.getArray();
                  }, _async.chunkSizeFrom(scope.chunk)).then(function(pathPoints) {
                    _this.maybeFit(pathPoints);
                    return _this.firstTime = false;
                  });
                };
              })(this));
            };
            BasePolysParentModel.prototype.pieceMeal = function(scope, isArray) {
              var maybeCanceled,
                  payload;
              if (isArray == null) {
                isArray = true;
              }
              if (scope.$$destroyed) {
                return;
              }
              maybeCanceled = null;
              payload = null;
              this.models = scope.models;
              if ((scope != null) && this.modelsLength() && this.plurals.length) {
                return _async.promiseLock(this, uiGmapPromise.promiseTypes.update, 'pieceMeal', (function(canceledMsg) {
                  return maybeCanceled = canceledMsg;
                }), (function(_this) {
                  return function() {
                    return uiGmapPromise.promise(function() {
                      return _this.figureOutState(_this.idKey, scope, _this.plurals, _this.modelKeyComparison);
                    }).then(function(state) {
                      payload = state;
                      if (payload.updates.length) {
                        _async.each(payload.updates, function(obj) {
                          _.extend(obj.child.scope, obj.model);
                          return obj.child.model = obj.model;
                        });
                      }
                      return _async.each(payload.removals, function(child) {
                        if (child != null) {
                          child.destroy();
                          _this.plurals.remove(child.model[_this.idKey]);
                          return maybeCanceled;
                        }
                      }, _async.chunkSizeFrom(scope.chunk));
                    }).then(function() {
                      return _async.each(payload.adds, function(modelToAdd) {
                        if (maybeCanceled) {
                          $log.debug('pieceMeal should fall through safely');
                        }
                        _this.createChild(modelToAdd, _this.gMap);
                        return maybeCanceled;
                      }, _async.chunkSizeFrom(scope.chunk)).then(function() {
                        return _this.maybeFit();
                      });
                    });
                  };
                })(this));
              } else {
                this.inProgress = false;
                return this.rebuildAll(this.scope, true, true);
              }
            };
            BasePolysParentModel.prototype.createChild = function(model, gMap) {
              var child,
                  childScope;
              childScope = this.scope.$new(false);
              this.setChildScope(IPoly.scopeKeys, childScope, model);
              childScope.$watch('model', (function(_this) {
                return function(newValue, oldValue) {
                  if (newValue !== oldValue) {
                    return _this.setChildScope(childScope, newValue);
                  }
                };
              })(this), true);
              childScope["static"] = this.scope["static"];
              child = new PolyChildModel({
                isScopeModel: true,
                scope: childScope,
                attrs: this.attrs,
                gMap: gMap,
                defaults: this.defaults,
                model: model,
                gObjectChangeCb: (function(_this) {
                  return function() {
                    return _this.maybeFit();
                  };
                })(this)
              });
              if (model[this.idKey] == null) {
                this.$log.error(gObjectName + " model has no id to assign a child to.\nThis is required for performance. Please assign id,\nor redirect id to a different key.");
                return;
              }
              this.plurals.put(model[this.idKey], child);
              return child;
            };
            BasePolysParentModel.prototype.maybeFit = function(pathPoints) {
              if (pathPoints == null) {
                pathPoints = this.plurals.map(function(p) {
                  return p.pathPoints;
                });
              }
              if (this.scope.fit) {
                pathPoints = _.flatten(pathPoints);
                return FitHelper.fit(pathPoints, this.gMap);
              }
            };
            return BasePolysParentModel;
          })(ModelKey);
        };
      }]);
    }).call(this);
    ;
    (function() {
      var extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      },
          hasProp = {}.hasOwnProperty;
      angular.module('uiGmapgoogle-maps.directives.api.models.parent').factory('uiGmapCircleParentModel', ['uiGmapLogger', '$timeout', 'uiGmapGmapUtil', 'uiGmapEventsHelper', 'uiGmapCircleOptionsBuilder', function($log, $timeout, GmapUtil, EventsHelper, Builder) {
        var CircleParentModel,
            _settingFromDirective;
        _settingFromDirective = function(scope, fn) {
          scope.settingFromDirective = true;
          fn();
          return $timeout(function() {
            return scope.settingFromDirective = false;
          });
        };
        return CircleParentModel = (function(superClass) {
          extend(CircleParentModel, superClass);
          CircleParentModel.include(GmapUtil);
          CircleParentModel.include(EventsHelper);
          function CircleParentModel(scope, element, attrs, gMap, DEFAULTS) {
            var clean,
                gObject,
                lastRadius;
            this.attrs = attrs;
            this.gMap = gMap;
            this.DEFAULTS = DEFAULTS;
            this.scope = scope;
            lastRadius = null;
            clean = (function(_this) {
              return function() {
                lastRadius = null;
                if (_this.listeners != null) {
                  _this.removeEvents(_this.listeners);
                  return _this.listeners = void 0;
                }
              };
            })(this);
            gObject = new google.maps.Circle(this.buildOpts(GmapUtil.getCoords(scope.center), scope.radius));
            this.setMyOptions = (function(_this) {
              return function(newVals, oldVals) {
                if (scope.settingFromDirective) {
                  return;
                }
                if (!(_.isEqual(newVals, oldVals) && newVals === oldVals && ((newVals != null) && (oldVals != null) ? newVals.coordinates === oldVals.coordinates : true))) {
                  return gObject.setOptions(_this.buildOpts(GmapUtil.getCoords(scope.center), scope.radius));
                }
              };
            })(this);
            this.props = this.props.concat([{
              prop: 'center',
              isColl: true
            }, {
              prop: 'fill',
              isColl: true
            }, 'radius', 'zIndex']);
            this.watchProps();
            if (this.scope.control != null) {
              this.scope.control.getCircle = function() {
                return gObject;
              };
            }
            clean();
            this.listeners = this.setEvents(gObject, scope, scope, ['radius_changed']) || [];
            this.listeners.push(google.maps.event.addListener(gObject, 'radius_changed', function() {
              var newRadius,
                  work;
              newRadius = gObject.getRadius();
              if (newRadius === lastRadius) {
                return;
              }
              lastRadius = newRadius;
              work = function() {
                return _settingFromDirective(scope, function() {
                  var ref,
                      ref1;
                  if (newRadius !== scope.radius) {
                    scope.radius = newRadius;
                  }
                  if (((ref = scope.events) != null ? ref.radius_changed : void 0) && _.isFunction((ref1 = scope.events) != null ? ref1.radius_changed : void 0)) {
                    return scope.events.radius_changed(gObject, 'radius_changed', scope, arguments);
                  }
                });
              };
              if (!angular.mock) {
                return scope.$evalAsync(function() {
                  return work();
                });
              } else {
                return work();
              }
            }));
            this.listeners.push(google.maps.event.addListener(gObject, 'center_changed', function() {
              return scope.$evalAsync(function() {
                return _settingFromDirective(scope, function() {
                  if (angular.isDefined(scope.center.type)) {
                    scope.center.coordinates[1] = gObject.getCenter().lat();
                    return scope.center.coordinates[0] = gObject.getCenter().lng();
                  } else {
                    scope.center.latitude = gObject.getCenter().lat();
                    return scope.center.longitude = gObject.getCenter().lng();
                  }
                });
              });
            }));
            scope.$on('$destroy', function() {
              clean();
              return gObject.setMap(null);
            });
            $log.info(this);
          }
          return CircleParentModel;
        })(Builder);
      }]);
    }).call(this);
    ;
    (function() {
      var extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      },
          hasProp = {}.hasOwnProperty;
      angular.module('uiGmapgoogle-maps.directives.api.models.parent').factory('uiGmapDrawingManagerParentModel', ['uiGmapLogger', '$timeout', 'uiGmapBaseObject', 'uiGmapEventsHelper', function($log, $timeout, BaseObject, EventsHelper) {
        var DrawingManagerParentModel;
        return DrawingManagerParentModel = (function(superClass) {
          extend(DrawingManagerParentModel, superClass);
          DrawingManagerParentModel.include(EventsHelper);
          function DrawingManagerParentModel(scope, element, attrs, map) {
            var gObject,
                listeners;
            this.scope = scope;
            this.attrs = attrs;
            this.map = map;
            gObject = new google.maps.drawing.DrawingManager(this.scope.options);
            gObject.setMap(this.map);
            listeners = void 0;
            if (this.scope.control != null) {
              this.scope.control.getDrawingManager = function() {
                return gObject;
              };
            }
            if (!this.scope["static"] && this.scope.options) {
              this.scope.$watch('options', function(newValue) {
                return gObject != null ? gObject.setOptions(newValue) : void 0;
              }, true);
            }
            if (this.scope.events != null) {
              listeners = this.setEvents(gObject, this.scope, this.scope);
              this.scope.$watch('events', (function(_this) {
                return function(newValue, oldValue) {
                  if (!_.isEqual(newValue, oldValue)) {
                    if (listeners != null) {
                      _this.removeEvents(listeners);
                    }
                    return listeners = _this.setEvents(gObject, _this.scope, _this.scope);
                  }
                };
              })(this));
            }
            this.scope.$on('$destroy', (function(_this) {
              return function() {
                if (listeners != null) {
                  _this.removeEvents(listeners);
                }
                gObject.setMap(null);
                return gObject = null;
              };
            })(this));
          }
          return DrawingManagerParentModel;
        })(BaseObject);
      }]);
    }).call(this);
    ;
    (function() {
      var bind = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      },
          extend = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;
      angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapIMarkerParentModel", ["uiGmapModelKey", "uiGmapLogger", function(ModelKey, Logger) {
        var IMarkerParentModel;
        IMarkerParentModel = (function(superClass) {
          extend(IMarkerParentModel, superClass);
          IMarkerParentModel.prototype.DEFAULTS = {};
          function IMarkerParentModel(scope1, element, attrs, map) {
            this.scope = scope1;
            this.element = element;
            this.attrs = attrs;
            this.map = map;
            this.onWatch = bind(this.onWatch, this);
            this.watch = bind(this.watch, this);
            this.validateScope = bind(this.validateScope, this);
            IMarkerParentModel.__super__.constructor.call(this, this.scope);
            this.$log = Logger;
            if (!this.validateScope(this.scope)) {
              throw new String("Unable to construct IMarkerParentModel due to invalid scope");
            }
            this.doClick = angular.isDefined(this.attrs.click);
            if (this.scope.options != null) {
              this.DEFAULTS = this.scope.options;
            }
            this.watch('coords', this.scope);
            this.watch('icon', this.scope);
            this.watch('options', this.scope);
            this.scope.$on("$destroy", (function(_this) {
              return function() {
                return _this.onDestroy(_this.scope);
              };
            })(this));
          }
          IMarkerParentModel.prototype.validateScope = function(scope) {
            var ret;
            if (scope == null) {
              this.$log.error(this.constructor.name + ": invalid scope used");
              return false;
            }
            ret = scope.coords != null;
            if (!ret) {
              this.$log.error(this.constructor.name + ": no valid coords attribute found");
              return false;
            }
            return ret;
          };
          IMarkerParentModel.prototype.watch = function(propNameToWatch, scope, equalityCheck) {
            if (equalityCheck == null) {
              equalityCheck = true;
            }
            return scope.$watch(propNameToWatch, (function(_this) {
              return function(newValue, oldValue) {
                if (!_.isEqual(newValue, oldValue)) {
                  return _this.onWatch(propNameToWatch, scope, newValue, oldValue);
                }
              };
            })(this), equalityCheck);
          };
          IMarkerParentModel.prototype.onWatch = function(propNameToWatch, scope, newValue, oldValue) {};
          return IMarkerParentModel;
        })(ModelKey);
        return IMarkerParentModel;
      }]);
    }).call(this);
    ;
    (function() {
      var extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      },
          hasProp = {}.hasOwnProperty;
      angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapIWindowParentModel", ["uiGmapModelKey", "uiGmapGmapUtil", "uiGmapLogger", function(ModelKey, GmapUtil, Logger) {
        var IWindowParentModel;
        return IWindowParentModel = (function(superClass) {
          extend(IWindowParentModel, superClass);
          IWindowParentModel.include(GmapUtil);
          function IWindowParentModel(scope, element, attrs, ctrls, $timeout, $compile, $http, $templateCache) {
            IWindowParentModel.__super__.constructor.call(this, scope);
            this.$log = Logger;
            this.$timeout = $timeout;
            this.$compile = $compile;
            this.$http = $http;
            this.$templateCache = $templateCache;
            this.DEFAULTS = {};
            if (scope.options != null) {
              this.DEFAULTS = scope.options;
            }
          }
          IWindowParentModel.prototype.getItem = function(scope, modelsPropToIterate, index) {
            if (modelsPropToIterate === 'models') {
              return scope[modelsPropToIterate][index];
            }
            return scope[modelsPropToIterate].get(index);
          };
          return IWindowParentModel;
        })(ModelKey);
      }]);
    }).call(this);
    ;
    (function() {
      var bind = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      },
          extend = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;
      angular.module('uiGmapgoogle-maps.directives.api.models.parent').factory('uiGmapLayerParentModel', ['uiGmapBaseObject', 'uiGmapLogger', '$timeout', function(BaseObject, Logger, $timeout) {
        var LayerParentModel;
        LayerParentModel = (function(superClass) {
          extend(LayerParentModel, superClass);
          function LayerParentModel(scope, element, attrs, gMap, onLayerCreated, $log) {
            this.scope = scope;
            this.element = element;
            this.attrs = attrs;
            this.gMap = gMap;
            this.onLayerCreated = onLayerCreated != null ? onLayerCreated : void 0;
            this.$log = $log != null ? $log : Logger;
            this.createGoogleLayer = bind(this.createGoogleLayer, this);
            if (this.attrs.type == null) {
              this.$log.info('type attribute for the layer directive is mandatory. Layer creation aborted!!');
              return;
            }
            this.createGoogleLayer();
            this.doShow = true;
            if (angular.isDefined(this.attrs.show)) {
              this.doShow = this.scope.show;
            }
            if (this.doShow && (this.gMap != null)) {
              this.gObject.setMap(this.gMap);
            }
            this.scope.$watch('show', (function(_this) {
              return function(newValue, oldValue) {
                if (newValue !== oldValue) {
                  _this.doShow = newValue;
                  if (newValue) {
                    return _this.gObject.setMap(_this.gMap);
                  } else {
                    return _this.gObject.setMap(null);
                  }
                }
              };
            })(this), true);
            this.scope.$watch('options', (function(_this) {
              return function(newValue, oldValue) {
                if (newValue !== oldValue && _this.doShow) {
                  return _this.gObject.setOptions(newValue);
                }
              };
            })(this), true);
            this.scope.$on('$destroy', (function(_this) {
              return function() {
                return _this.gObject.setMap(null);
              };
            })(this));
          }
          LayerParentModel.prototype.createGoogleLayer = function() {
            var base;
            if (this.attrs.options == null) {
              this.gObject = this.attrs.namespace === void 0 ? new google.maps[this.attrs.type]() : new google.maps[this.attrs.namespace][this.attrs.type]();
            } else {
              this.gObject = this.attrs.namespace === void 0 ? new google.maps[this.attrs.type](this.scope.options) : new google.maps[this.attrs.namespace][this.attrs.type](this.scope.options);
            }
            if ((this.gObject != null) && this.doShow) {
              this.gObject.setMap(this.gMap);
            }
            if ((this.gObject != null) && (this.onLayerCreated != null)) {
              return typeof(base = this.onLayerCreated(this.scope, this.gObject)) === "function" ? base(this.gObject) : void 0;
            }
          };
          return LayerParentModel;
        })(BaseObject);
        return LayerParentModel;
      }]);
    }).call(this);
    ;
    (function() {
      var bind = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      },
          extend = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;
      angular.module('uiGmapgoogle-maps.directives.api.models.parent').factory('uiGmapMapTypeParentModel', ['uiGmapBaseObject', 'uiGmapLogger', function(BaseObject, Logger) {
        var MapTypeParentModel;
        MapTypeParentModel = (function(superClass) {
          extend(MapTypeParentModel, superClass);
          function MapTypeParentModel(scope, element, attrs, gMap, $log) {
            this.scope = scope;
            this.element = element;
            this.attrs = attrs;
            this.gMap = gMap;
            this.$log = $log != null ? $log : Logger;
            this.hideOverlay = bind(this.hideOverlay, this);
            this.showOverlay = bind(this.showOverlay, this);
            this.refreshMapType = bind(this.refreshMapType, this);
            this.createMapType = bind(this.createMapType, this);
            if (this.attrs.options == null) {
              this.$log.info('options attribute for the map-type directive is mandatory. Map type creation aborted!!');
              return;
            }
            this.id = this.gMap.overlayMapTypesCount = this.gMap.overlayMapTypesCount + 1 || 0;
            this.doShow = true;
            this.createMapType();
            if (angular.isDefined(this.attrs.show)) {
              this.doShow = this.scope.show;
            }
            if (this.doShow && (this.gMap != null)) {
              this.showOverlay();
            }
            this.scope.$watch('show', (function(_this) {
              return function(newValue, oldValue) {
                if (newValue !== oldValue) {
                  _this.doShow = newValue;
                  if (newValue) {
                    return _this.showOverlay();
                  } else {
                    return _this.hideOverlay();
                  }
                }
              };
            })(this), true);
            this.scope.$watchCollection('options', (function(_this) {
              return function(newValue, oldValue) {
                var different,
                    mapTypeProps;
                if (!_.isEqual(newValue, oldValue)) {
                  mapTypeProps = ['tileSize', 'maxZoom', 'minZoom', 'name', 'alt'];
                  different = _.some(mapTypeProps, function(prop) {
                    return !oldValue || !newValue || !_.isEqual(newValue[prop], oldValue[prop]);
                  });
                  if (different) {
                    return _this.refreshMapType();
                  }
                }
              };
            })(this));
            if (angular.isDefined(this.attrs.refresh)) {
              this.scope.$watch('refresh', (function(_this) {
                return function(newValue, oldValue) {
                  if (!_.isEqual(newValue, oldValue)) {
                    return _this.refreshMapType();
                  }
                };
              })(this), true);
            }
            this.scope.$on('$destroy', (function(_this) {
              return function() {
                _this.hideOverlay();
                return _this.mapType = null;
              };
            })(this));
          }
          MapTypeParentModel.prototype.createMapType = function() {
            if (this.scope.options.getTile != null) {
              this.mapType = this.scope.options;
            } else if (this.scope.options.getTileUrl != null) {
              this.mapType = new google.maps.ImageMapType(this.scope.options);
            } else {
              this.$log.info('options should provide either getTile or getTileUrl methods. Map type creation aborted!!');
              return;
            }
            if (this.attrs.id && this.scope.id) {
              this.gMap.mapTypes.set(this.scope.id, this.mapType);
              if (!angular.isDefined(this.attrs.show)) {
                this.doShow = false;
              }
            }
            return this.mapType.layerId = this.id;
          };
          MapTypeParentModel.prototype.refreshMapType = function() {
            this.hideOverlay();
            this.mapType = null;
            this.createMapType();
            if (this.doShow && (this.gMap != null)) {
              return this.showOverlay();
            }
          };
          MapTypeParentModel.prototype.showOverlay = function() {
            return this.gMap.overlayMapTypes.push(this.mapType);
          };
          MapTypeParentModel.prototype.hideOverlay = function() {
            var found;
            found = false;
            return this.gMap.overlayMapTypes.forEach((function(_this) {
              return function(mapType, index) {
                if (!found && mapType.layerId === _this.id) {
                  found = true;
                  _this.gMap.overlayMapTypes.removeAt(index);
                }
              };
            })(this));
          };
          return MapTypeParentModel;
        })(BaseObject);
        return MapTypeParentModel;
      }]);
    }).call(this);
    ;
    (function() {
      var bind = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      },
          extend = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;
      angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapMarkersParentModel", ["uiGmapIMarkerParentModel", "uiGmapModelsWatcher", "uiGmapPropMap", "uiGmapMarkerChildModel", "uiGmap_async", "uiGmapClustererMarkerManager", "uiGmapMarkerManager", "$timeout", "uiGmapIMarker", "uiGmapPromise", "uiGmapGmapUtil", "uiGmapLogger", "uiGmapSpiderfierMarkerManager", function(IMarkerParentModel, ModelsWatcher, PropMap, MarkerChildModel, _async, ClustererMarkerManager, MarkerManager, $timeout, IMarker, uiGmapPromise, GmapUtil, $log, SpiderfierMarkerManager) {
        var MarkersParentModel,
            _setPlurals;
        _setPlurals = function(val, objToSet) {
          objToSet.plurals = new PropMap();
          objToSet.scope.plurals = objToSet.plurals;
          return objToSet;
        };
        MarkersParentModel = (function(superClass) {
          extend(MarkersParentModel, superClass);
          MarkersParentModel.include(GmapUtil);
          MarkersParentModel.include(ModelsWatcher);
          function MarkersParentModel(scope, element, attrs, map) {
            this.maybeExecMappedEvent = bind(this.maybeExecMappedEvent, this);
            this.onDestroy = bind(this.onDestroy, this);
            this.newChildMarker = bind(this.newChildMarker, this);
            this.pieceMeal = bind(this.pieceMeal, this);
            this.rebuildAll = bind(this.rebuildAll, this);
            this.createAllNew = bind(this.createAllNew, this);
            this.bindToTypeEvents = bind(this.bindToTypeEvents, this);
            this.createChildScopes = bind(this.createChildScopes, this);
            this.validateScope = bind(this.validateScope, this);
            this.onWatch = bind(this.onWatch, this);
            MarkersParentModel.__super__.constructor.call(this, scope, element, attrs, map);
            this["interface"] = IMarker;
            _setPlurals(new PropMap(), this);
            this.scope.pluralsUpdate = {updateCtr: 0};
            this.$log.info(this);
            this.doRebuildAll = this.scope.doRebuildAll != null ? this.scope.doRebuildAll : false;
            this.setIdKey(this.scope);
            this.scope.$watch('doRebuildAll', (function(_this) {
              return function(newValue, oldValue) {
                if (newValue !== oldValue) {
                  return _this.doRebuildAll = newValue;
                }
              };
            })(this));
            if (!this.modelsLength()) {
              this.modelsRendered = false;
            }
            this.scope.$watch('models', (function(_this) {
              return function(newValue, oldValue) {
                if (!_.isEqual(newValue, oldValue) || !_this.modelsRendered) {
                  if (newValue.length === 0 && oldValue.length === 0) {
                    return;
                  }
                  _this.modelsRendered = true;
                  return _this.onWatch('models', _this.scope, newValue, oldValue);
                }
              };
            })(this), !this.isTrue(attrs.modelsbyref));
            this.watch('doCluster', this.scope);
            this.watch('type', this.scope);
            this.watch('clusterOptions', this.scope);
            this.watch('clusterEvents', this.scope);
            this.watch('typeOptions', this.scope);
            this.watch('typeEvents', this.scope);
            this.watch('fit', this.scope);
            this.watch('idKey', this.scope);
            this.gManager = void 0;
            this.createAllNew(this.scope);
          }
          MarkersParentModel.prototype.onWatch = function(propNameToWatch, scope, newValue, oldValue) {
            if (propNameToWatch === "idKey" && newValue !== oldValue) {
              this.idKey = newValue;
            }
            if (this.doRebuildAll || (propNameToWatch === 'doCluster' || propNameToWatch === 'type')) {
              return this.rebuildAll(scope);
            } else {
              return this.pieceMeal(scope);
            }
          };
          MarkersParentModel.prototype.validateScope = function(scope) {
            var modelsNotDefined;
            modelsNotDefined = angular.isUndefined(scope.models) || scope.models === void 0;
            if (modelsNotDefined) {
              this.$log.error(this.constructor.name + ": no valid models attribute found");
            }
            return MarkersParentModel.__super__.validateScope.call(this, scope) || modelsNotDefined;
          };
          MarkersParentModel.prototype.createChildScopes = function(isCreatingFromScratch) {
            if ((this.gMap == null) || (this.scope.models == null)) {
              return;
            }
            if (isCreatingFromScratch) {
              return this.createAllNew(this.scope, false);
            } else {
              return this.pieceMeal(this.scope, false);
            }
          };
          MarkersParentModel.prototype.bindToTypeEvents = function(typeEvents, events) {
            var internalHandles,
                self;
            if (events == null) {
              events = ['click', 'mouseout', 'mouseover'];
            }
            self = this;
            if (!this.origTypeEvents) {
              this.origTypeEvents = {};
              _.each(events, (function(_this) {
                return function(eventName) {
                  return _this.origTypeEvents[eventName] = typeEvents != null ? typeEvents[eventName] : void 0;
                };
              })(this));
            } else {
              angular.extend(typeEvents, this.origTypeEvents);
            }
            internalHandles = {};
            _.each(events, function(eventName) {
              return internalHandles[eventName] = function(group) {
                return self.maybeExecMappedEvent(group, eventName);
              };
            });
            return angular.extend(typeEvents, internalHandles);
          };
          MarkersParentModel.prototype.createAllNew = function(scope) {
            var isSpiderfied,
                maybeCanceled,
                typeEvents,
                typeOptions;
            if (this.gManager != null) {
              if (this.gManager instanceof SpiderfierMarkerManager) {
                isSpiderfied = this.gManager.isSpiderfied();
              }
              this.gManager.clear();
              delete this.gManager;
            }
            typeEvents = scope.typeEvents || scope.clusterEvents;
            typeOptions = scope.typeOptions || scope.clusterOptions;
            if (scope.doCluster || scope.type === 'cluster') {
              if (typeEvents != null) {
                this.bindToTypeEvents(typeEvents);
              }
              this.gManager = new ClustererMarkerManager(this.map, void 0, typeOptions, typeEvents);
            } else if (scope.type === 'spider') {
              if (typeEvents != null) {
                this.bindToTypeEvents(typeEvents, ['spiderfy', 'unspiderfy']);
              }
              this.gManager = new SpiderfierMarkerManager(this.map, void 0, typeOptions, typeEvents, this.scope);
              if (isSpiderfied) {
                this.gManager.spiderfy();
              }
            } else {
              this.gManager = new MarkerManager(this.map);
            }
            if (this.didQueueInitPromise(this, scope)) {
              return;
            }
            maybeCanceled = null;
            return _async.promiseLock(this, uiGmapPromise.promiseTypes.create, 'createAllNew', (function(canceledMsg) {
              return maybeCanceled = canceledMsg;
            }), (function(_this) {
              return function() {
                return _async.each(scope.models, function(model) {
                  _this.newChildMarker(model, scope);
                  return maybeCanceled;
                }, _async.chunkSizeFrom(scope.chunk)).then(function() {
                  _this.modelsRendered = true;
                  if (scope.fit) {
                    _this.gManager.fit();
                  }
                  _this.gManager.draw();
                  return _this.scope.pluralsUpdate.updateCtr += 1;
                }, _async.chunkSizeFrom(scope.chunk));
              };
            })(this));
          };
          MarkersParentModel.prototype.rebuildAll = function(scope) {
            var ref;
            if (!scope.doRebuild && scope.doRebuild !== void 0) {
              return;
            }
            if ((ref = this.scope.plurals) != null ? ref.length : void 0) {
              return this.onDestroy(scope).then((function(_this) {
                return function() {
                  return _this.createAllNew(scope);
                };
              })(this));
            } else {
              return this.createAllNew(scope);
            }
          };
          MarkersParentModel.prototype.pieceMeal = function(scope) {
            var maybeCanceled,
                payload;
            if (scope.$$destroyed) {
              return;
            }
            maybeCanceled = null;
            payload = null;
            if (this.modelsLength() && this.scope.plurals.length) {
              return _async.promiseLock(this, uiGmapPromise.promiseTypes.update, 'pieceMeal', (function(canceledMsg) {
                return maybeCanceled = canceledMsg;
              }), (function(_this) {
                return function() {
                  return uiGmapPromise.promise((function() {
                    return _this.figureOutState(_this.idKey, scope, _this.scope.plurals, _this.modelKeyComparison);
                  })).then(function(state) {
                    payload = state;
                    return _async.each(payload.removals, function(child) {
                      if (child != null) {
                        if (child.destroy != null) {
                          child.destroy();
                        }
                        _this.scope.plurals.remove(child.id);
                        return maybeCanceled;
                      }
                    }, _async.chunkSizeFrom(scope.chunk));
                  }).then(function() {
                    return _async.each(payload.adds, function(modelToAdd) {
                      _this.newChildMarker(modelToAdd, scope);
                      return maybeCanceled;
                    }, _async.chunkSizeFrom(scope.chunk));
                  }).then(function() {
                    return _async.each(payload.updates, function(update) {
                      _this.updateChild(update.child, update.model);
                      return maybeCanceled;
                    }, _async.chunkSizeFrom(scope.chunk));
                  }).then(function() {
                    if (payload.adds.length > 0 || payload.removals.length > 0 || payload.updates.length > 0) {
                      scope.plurals = _this.scope.plurals;
                      if (scope.fit) {
                        _this.gManager.fit();
                      }
                      _this.gManager.draw();
                    }
                    return _this.scope.pluralsUpdate.updateCtr += 1;
                  });
                };
              })(this));
            } else {
              this.inProgress = false;
              return this.rebuildAll(scope);
            }
          };
          MarkersParentModel.prototype.newChildMarker = function(model, scope) {
            var child,
                childScope,
                keys;
            if (!model) {
              throw 'model undefined';
            }
            if (model[this.idKey] == null) {
              this.$log.error("Marker model has no id to assign a child to. This is required for performance. Please assign id, or redirect id to a different key.");
              return;
            }
            this.$log.info('child', child, 'markers', this.scope.markerModels);
            childScope = scope.$new(false);
            childScope.events = scope.events;
            keys = {};
            IMarker.scopeKeys.forEach(function(k) {
              return keys[k] = scope[k];
            });
            child = new MarkerChildModel({
              scope: childScope,
              model: model,
              keys: keys,
              gMap: this.map,
              defaults: this.DEFAULTS,
              doClick: this.doClick,
              gManager: this.gManager,
              doDrawSelf: false,
              isScopeModel: true
            });
            this.scope.plurals.put(model[this.idKey], child);
            return child;
          };
          MarkersParentModel.prototype.onDestroy = function(scope) {
            MarkersParentModel.__super__.onDestroy.call(this, scope);
            return _async.promiseLock(this, uiGmapPromise.promiseTypes["delete"], void 0, void 0, (function(_this) {
              return function() {
                return _async.each(_this.scope.plurals.values(), function(model) {
                  if (model != null) {
                    return model.destroy(false);
                  }
                }, _async.chunkSizeFrom(_this.scope.cleanchunk, false)).then(function() {
                  if (_this.gManager != null) {
                    _this.gManager.destroy();
                  }
                  _this.plurals.removeAll();
                  if (_this.plurals !== _this.scope.plurals) {
                    console.error('plurals out of sync for MarkersParentModel');
                  }
                  return _this.scope.pluralsUpdate.updateCtr += 1;
                });
              };
            })(this));
          };
          MarkersParentModel.prototype.maybeExecMappedEvent = function(group, fnName) {
            var pair,
                typeEvents;
            if (this.scope.$$destroyed) {
              return;
            }
            typeEvents = this.scope.typeEvents || this.scope.clusterEvents;
            if (_.isFunction(typeEvents != null ? typeEvents[fnName] : void 0)) {
              pair = this.mapTypeToPlurals(group);
              if (this.origTypeEvents[fnName]) {
                return this.origTypeEvents[fnName](pair.group, pair.mapped);
              }
            }
          };
          MarkersParentModel.prototype.mapTypeToPlurals = function(group) {
            var arrayToMap,
                mapped,
                ref;
            if (_.isArray(group)) {
              arrayToMap = group;
            } else if (_.isFunction(group.getMarkers)) {
              arrayToMap = group.getMarkers();
            }
            if (arrayToMap == null) {
              $log.error("Unable to map event as we cannot find the array group to map");
              return;
            }
            if ((ref = this.scope.plurals.values()) != null ? ref.length : void 0) {
              mapped = arrayToMap.map((function(_this) {
                return function(g) {
                  return _this.scope.plurals.get(g.key).model;
                };
              })(this));
            } else {
              mapped = [];
            }
            return {
              cluster: group,
              mapped: mapped,
              group: group
            };
          };
          MarkersParentModel.prototype.getItem = function(scope, modelsPropToIterate, index) {
            if (modelsPropToIterate === 'models') {
              return scope[modelsPropToIterate][index];
            }
            return scope[modelsPropToIterate].get(index);
          };
          return MarkersParentModel;
        })(IMarkerParentModel);
        return MarkersParentModel;
      }]);
    }).call(this);
    ;
    (function() {
      ['Polygon', 'Polyline'].forEach(function(name) {
        return angular.module('uiGmapgoogle-maps.directives.api.models.parent').factory("uiGmap" + name + "sParentModel", ['uiGmapBasePolysParentModel', "uiGmap" + name + "ChildModel", "uiGmapI" + name, function(BasePolysParentModel, ChildModel, IPoly) {
          return BasePolysParentModel(IPoly, ChildModel, name);
        }]);
      });
    }).call(this);
    ;
    (function() {
      var extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      },
          hasProp = {}.hasOwnProperty;
      angular.module('uiGmapgoogle-maps.directives.api.models.parent').factory('uiGmapRectangleParentModel', ['uiGmapLogger', 'uiGmapGmapUtil', 'uiGmapEventsHelper', 'uiGmapRectangleOptionsBuilder', function($log, GmapUtil, EventsHelper, Builder) {
        var RectangleParentModel;
        return RectangleParentModel = (function(superClass) {
          extend(RectangleParentModel, superClass);
          RectangleParentModel.include(GmapUtil);
          RectangleParentModel.include(EventsHelper);
          function RectangleParentModel(scope, element, attrs, gMap, DEFAULTS) {
            var bounds,
                clear,
                createBounds,
                dragging,
                fit,
                gObject,
                init,
                listeners,
                myListeners,
                settingBoundsFromScope,
                updateBounds;
            this.scope = scope;
            this.attrs = attrs;
            this.gMap = gMap;
            this.DEFAULTS = DEFAULTS;
            bounds = void 0;
            dragging = false;
            myListeners = [];
            listeners = void 0;
            fit = (function(_this) {
              return function() {
                if (_this.isTrue(_this.attrs.fit)) {
                  return _this.fitMapBounds(_this.gMap, bounds);
                }
              };
            })(this);
            createBounds = (function(_this) {
              return function() {
                var ref,
                    ref1,
                    ref2;
                if ((_this.scope.bounds != null) && (((ref = _this.scope.bounds) != null ? ref.sw : void 0) != null) && (((ref1 = _this.scope.bounds) != null ? ref1.ne : void 0) != null) && _this.validateBoundPoints(_this.scope.bounds)) {
                  bounds = _this.convertBoundPoints(_this.scope.bounds);
                  return $log.info("new new bounds created: " + (JSON.stringify(bounds)));
                } else if ((_this.scope.bounds.getNorthEast != null) && (_this.scope.bounds.getSouthWest != null)) {
                  return bounds = _this.scope.bounds;
                } else {
                  if (_this.scope.bounds != null) {
                    return $log.error("Invalid bounds for newValue: " + (JSON.stringify((ref2 = _this.scope) != null ? ref2.bounds : void 0)));
                  }
                }
              };
            })(this);
            createBounds();
            gObject = new google.maps.Rectangle(this.buildOpts(bounds));
            $log.info("gObject (rectangle) created: " + gObject);
            settingBoundsFromScope = false;
            updateBounds = (function(_this) {
              return function() {
                var b,
                    ne,
                    sw;
                b = gObject.getBounds();
                ne = b.getNorthEast();
                sw = b.getSouthWest();
                if (settingBoundsFromScope) {
                  return;
                }
                return _this.scope.$evalAsync(function(s) {
                  if ((s.bounds != null) && (s.bounds.sw != null) && (s.bounds.ne != null)) {
                    s.bounds.ne = {
                      latitude: ne.lat(),
                      longitude: ne.lng()
                    };
                    s.bounds.sw = {
                      latitude: sw.lat(),
                      longitude: sw.lng()
                    };
                  }
                  if ((s.bounds.getNorthEast != null) && (s.bounds.getSouthWest != null)) {
                    return s.bounds = b;
                  }
                });
              };
            })(this);
            init = (function(_this) {
              return function() {
                fit();
                _this.removeEvents(myListeners);
                myListeners.push(google.maps.event.addListener(gObject, 'dragstart', function() {
                  return dragging = true;
                }));
                myListeners.push(google.maps.event.addListener(gObject, 'dragend', function() {
                  dragging = false;
                  return updateBounds();
                }));
                return myListeners.push(google.maps.event.addListener(gObject, 'bounds_changed', function() {
                  if (dragging) {
                    return;
                  }
                  return updateBounds();
                }));
              };
            })(this);
            clear = (function(_this) {
              return function() {
                _this.removeEvents(myListeners);
                if (listeners != null) {
                  _this.removeEvents(listeners);
                }
                return gObject.setMap(null);
              };
            })(this);
            if (bounds != null) {
              init();
            }
            this.scope.$watch('bounds', (function(newValue, oldValue) {
              var isNew;
              if (_.isEqual(newValue, oldValue) && (bounds != null) || dragging) {
                return;
              }
              settingBoundsFromScope = true;
              if (newValue == null) {
                clear();
                return;
              }
              if (bounds == null) {
                isNew = true;
              } else {
                fit();
              }
              createBounds();
              gObject.setBounds(bounds);
              settingBoundsFromScope = false;
              if (isNew && (bounds != null)) {
                return init();
              }
            }), true);
            this.setMyOptions = (function(_this) {
              return function(newVals, oldVals) {
                if (!_.isEqual(newVals, oldVals)) {
                  if ((bounds != null) && (newVals != null)) {
                    return gObject.setOptions(_this.buildOpts(bounds));
                  }
                }
              };
            })(this);
            this.props.push('bounds');
            this.watchProps(this.props);
            if (this.attrs.events != null) {
              listeners = this.setEvents(gObject, this.scope, this.scope);
              this.scope.$watch('events', (function(_this) {
                return function(newValue, oldValue) {
                  if (!_.isEqual(newValue, oldValue)) {
                    if (listeners != null) {
                      _this.removeEvents(listeners);
                    }
                    return listeners = _this.setEvents(gObject, _this.scope, _this.scope);
                  }
                };
              })(this));
            }
            this.scope.$on('$destroy', function() {
              return clear();
            });
            $log.info(this);
          }
          return RectangleParentModel;
        })(Builder);
      }]);
    }).call(this);
    ;
    (function() {
      var bind = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      },
          extend = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;
      angular.module('uiGmapgoogle-maps.directives.api.models.parent').factory('uiGmapSearchBoxParentModel', ['uiGmapBaseObject', 'uiGmapLogger', 'uiGmapEventsHelper', function(BaseObject, Logger, EventsHelper) {
        var SearchBoxParentModel;
        SearchBoxParentModel = (function(superClass) {
          extend(SearchBoxParentModel, superClass);
          SearchBoxParentModel.include(EventsHelper);
          function SearchBoxParentModel(scope, element, attrs, gMap, ctrlPosition, template, $log) {
            var controlDiv;
            this.scope = scope;
            this.element = element;
            this.attrs = attrs;
            this.gMap = gMap;
            this.ctrlPosition = ctrlPosition;
            this.template = template;
            this.$log = $log != null ? $log : Logger;
            this.setVisibility = bind(this.setVisibility, this);
            this.getBounds = bind(this.getBounds, this);
            this.setBounds = bind(this.setBounds, this);
            this.createSearchBox = bind(this.createSearchBox, this);
            this.addToParentDiv = bind(this.addToParentDiv, this);
            this.addAsMapControl = bind(this.addAsMapControl, this);
            this.init = bind(this.init, this);
            if (this.attrs.template == null) {
              this.$log.error('template attribute for the search-box directive is mandatory. Places Search Box creation aborted!!');
              return;
            }
            if (angular.isUndefined(this.scope.options)) {
              this.scope.options = {};
              this.scope.options.visible = true;
            }
            if (angular.isUndefined(this.scope.options.visible)) {
              this.scope.options.visible = true;
            }
            if (angular.isUndefined(this.scope.options.autocomplete)) {
              this.scope.options.autocomplete = false;
            }
            this.visible = this.scope.options.visible;
            this.autocomplete = this.scope.options.autocomplete;
            controlDiv = angular.element('<div></div>');
            controlDiv.append(this.template);
            this.input = controlDiv.find('input')[0];
            this.init();
          }
          SearchBoxParentModel.prototype.init = function() {
            this.createSearchBox();
            this.scope.$watch('options', (function(_this) {
              return function(newValue, oldValue) {
                if (angular.isObject(newValue)) {
                  if (newValue.bounds != null) {
                    _this.setBounds(newValue.bounds);
                  }
                  if (newValue.visible != null) {
                    if (_this.visible !== newValue.visible) {
                      return _this.setVisibility(newValue.visible);
                    }
                  }
                }
              };
            })(this), true);
            if (this.attrs.parentdiv != null) {
              this.addToParentDiv();
            } else {
              this.addAsMapControl();
            }
            if (!this.visible) {
              this.setVisibility(this.visible);
            }
            if (this.autocomplete) {
              this.listener = google.maps.event.addListener(this.gObject, 'place_changed', (function(_this) {
                return function() {
                  return _this.places = _this.gObject.getPlace();
                };
              })(this));
            } else {
              this.listener = google.maps.event.addListener(this.gObject, 'places_changed', (function(_this) {
                return function() {
                  return _this.places = _this.gObject.getPlaces();
                };
              })(this));
            }
            this.listeners = this.setEvents(this.gObject, this.scope, this.scope);
            this.$log.info(this);
            this.scope.$on('$stateChangeSuccess', (function(_this) {
              return function() {
                if (_this.attrs.parentdiv != null) {
                  return _this.addToParentDiv();
                }
              };
            })(this));
            return this.scope.$on('$destroy', (function(_this) {
              return function() {
                return _this.gObject = null;
              };
            })(this));
          };
          SearchBoxParentModel.prototype.addAsMapControl = function() {
            return this.gMap.controls[google.maps.ControlPosition[this.ctrlPosition]].push(this.input);
          };
          SearchBoxParentModel.prototype.addToParentDiv = function() {
            var ref;
            this.parentDiv = angular.element(document.getElementById(this.scope.parentdiv));
            if ((ref = this.parentDiv) != null ? ref.length : void 0) {
              return this.parentDiv.append(this.input);
            }
          };
          SearchBoxParentModel.prototype.createSearchBox = function() {
            if (this.autocomplete) {
              return this.gObject = new google.maps.places.Autocomplete(this.input, this.scope.options);
            } else {
              return this.gObject = new google.maps.places.SearchBox(this.input, this.scope.options);
            }
          };
          SearchBoxParentModel.prototype.setBounds = function(bounds) {
            if (angular.isUndefined(bounds.isEmpty)) {
              this.$log.error('Error: SearchBoxParentModel setBounds. Bounds not an instance of LatLngBounds.');
            } else {
              if (bounds.isEmpty() === false) {
                if (this.gObject != null) {
                  return this.gObject.setBounds(bounds);
                }
              }
            }
          };
          SearchBoxParentModel.prototype.getBounds = function() {
            return this.gObject.getBounds();
          };
          SearchBoxParentModel.prototype.setVisibility = function(val) {
            if (this.attrs.parentdiv != null) {
              if (val === false) {
                this.parentDiv.addClass("ng-hide");
              } else {
                this.parentDiv.removeClass("ng-hide");
              }
            } else {
              if (val === false) {
                this.gMap.controls[google.maps.ControlPosition[this.ctrlPosition]].clear();
              } else {
                this.gMap.controls[google.maps.ControlPosition[this.ctrlPosition]].push(this.input);
              }
            }
            return this.visible = val;
          };
          return SearchBoxParentModel;
        })(BaseObject);
        return SearchBoxParentModel;
      }]);
    }).call(this);
    ;
    (function() {
      var bind = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      },
          extend = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;
      angular.module('uiGmapgoogle-maps.directives.api.models.parent').factory('uiGmapWindowsParentModel', ['uiGmapIWindowParentModel', 'uiGmapModelsWatcher', 'uiGmapPropMap', 'uiGmapWindowChildModel', 'uiGmapLinked', 'uiGmap_async', 'uiGmapLogger', '$timeout', '$compile', '$http', '$templateCache', '$interpolate', 'uiGmapPromise', 'uiGmapIWindow', 'uiGmapGmapUtil', function(IWindowParentModel, ModelsWatcher, PropMap, WindowChildModel, Linked, _async, $log, $timeout, $compile, $http, $templateCache, $interpolate, uiGmapPromise, IWindow, GmapUtil) {
        var WindowsParentModel;
        WindowsParentModel = (function(superClass) {
          extend(WindowsParentModel, superClass);
          WindowsParentModel.include(ModelsWatcher);
          function WindowsParentModel(scope, element, attrs, ctrls, gMap1, markersScope) {
            this.gMap = gMap1;
            this.markersScope = markersScope;
            this.modelKeyComparison = bind(this.modelKeyComparison, this);
            this.interpolateContent = bind(this.interpolateContent, this);
            this.setChildScope = bind(this.setChildScope, this);
            this.createWindow = bind(this.createWindow, this);
            this.setContentKeys = bind(this.setContentKeys, this);
            this.pieceMeal = bind(this.pieceMeal, this);
            this.createAllNew = bind(this.createAllNew, this);
            this.watchIdKey = bind(this.watchIdKey, this);
            this.createChildScopes = bind(this.createChildScopes, this);
            this.watchOurScope = bind(this.watchOurScope, this);
            this.watchDestroy = bind(this.watchDestroy, this);
            this.onDestroy = bind(this.onDestroy, this);
            this.rebuildAll = bind(this.rebuildAll, this);
            this.doINeedToWipe = bind(this.doINeedToWipe, this);
            this.watchModels = bind(this.watchModels, this);
            this.go = bind(this.go, this);
            WindowsParentModel.__super__.constructor.call(this, scope, element, attrs, ctrls, $timeout, $compile, $http, $templateCache);
            this["interface"] = IWindow;
            this.plurals = new PropMap();
            _.each(IWindow.scopeKeys, (function(_this) {
              return function(name) {
                return _this[name + 'Key'] = void 0;
              };
            })(this));
            this.linked = new Linked(scope, element, attrs, ctrls);
            this.contentKeys = void 0;
            this.isIconVisibleOnClick = void 0;
            this.firstTime = true;
            this.firstWatchModels = true;
            this.$log.info(self);
            this.parentScope = void 0;
            this.go(scope);
          }
          WindowsParentModel.prototype.go = function(scope) {
            this.watchOurScope(scope);
            this.doRebuildAll = this.scope.doRebuildAll != null ? this.scope.doRebuildAll : false;
            scope.$watch('doRebuildAll', (function(_this) {
              return function(newValue, oldValue) {
                if (newValue !== oldValue) {
                  return _this.doRebuildAll = newValue;
                }
              };
            })(this));
            return this.createChildScopes();
          };
          WindowsParentModel.prototype.watchModels = function(scope) {
            var itemToWatch;
            itemToWatch = this.markersScope != null ? 'pluralsUpdate' : 'models';
            return scope.$watch(itemToWatch, (function(_this) {
              return function(newValue, oldValue) {
                var doScratch;
                if (!_.isEqual(newValue, oldValue) || _this.firstWatchModels) {
                  _this.firstWatchModels = false;
                  if (_this.doRebuildAll || _this.doINeedToWipe(scope.models)) {
                    return _this.rebuildAll(scope, true, true);
                  } else {
                    doScratch = _this.plurals.length === 0;
                    if (_this.existingPieces != null) {
                      return _.last(_this.existingPieces._content).then(function() {
                        return _this.createChildScopes(doScratch);
                      });
                    } else {
                      return _this.createChildScopes(doScratch);
                    }
                  }
                }
              };
            })(this), true);
          };
          WindowsParentModel.prototype.doINeedToWipe = function(newValue) {
            var newValueIsEmpty;
            newValueIsEmpty = newValue != null ? newValue.length === 0 : true;
            return this.plurals.length > 0 && newValueIsEmpty;
          };
          WindowsParentModel.prototype.rebuildAll = function(scope, doCreate, doDelete) {
            return this.onDestroy(doDelete).then((function(_this) {
              return function() {
                if (doCreate) {
                  return _this.createChildScopes();
                }
              };
            })(this));
          };
          WindowsParentModel.prototype.onDestroy = function(scope) {
            WindowsParentModel.__super__.onDestroy.call(this, this.scope);
            return _async.promiseLock(this, uiGmapPromise.promiseTypes["delete"], void 0, void 0, (function(_this) {
              return function() {
                return _async.each(_this.plurals.values(), function(child) {
                  return child.destroy(true);
                }, _async.chunkSizeFrom(_this.scope.cleanchunk, false)).then(function() {
                  var ref;
                  return (ref = _this.plurals) != null ? ref.removeAll() : void 0;
                });
              };
            })(this));
          };
          WindowsParentModel.prototype.watchDestroy = function(scope) {
            return scope.$on('$destroy', (function(_this) {
              return function() {
                _this.firstWatchModels = true;
                _this.firstTime = true;
                return _this.rebuildAll(scope, false, true);
              };
            })(this));
          };
          WindowsParentModel.prototype.watchOurScope = function(scope) {
            return _.each(IWindow.scopeKeys, (function(_this) {
              return function(name) {
                var nameKey;
                nameKey = name + 'Key';
                return _this[nameKey] = typeof scope[name] === 'function' ? scope[name]() : scope[name];
              };
            })(this));
          };
          WindowsParentModel.prototype.createChildScopes = function(isCreatingFromScratch) {
            var modelsNotDefined,
                ref,
                ref1;
            if (isCreatingFromScratch == null) {
              isCreatingFromScratch = true;
            }
            this.isIconVisibleOnClick = true;
            if (angular.isDefined(this.linked.attrs.isiconvisibleonclick)) {
              this.isIconVisibleOnClick = this.linked.scope.isIconVisibleOnClick;
            }
            modelsNotDefined = angular.isUndefined(this.linked.scope.models);
            if (modelsNotDefined && (this.markersScope === void 0 || (((ref = this.markersScope) != null ? ref.plurals : void 0) === void 0 || ((ref1 = this.markersScope) != null ? ref1.models : void 0) === void 0))) {
              this.$log.error('No models to create windows from! Need direct models or models derived from markers!');
              return;
            }
            if (this.gMap != null) {
              if (this.linked.scope.models != null) {
                this.watchIdKey(this.linked.scope);
                if (isCreatingFromScratch) {
                  return this.createAllNew(this.linked.scope, false);
                } else {
                  return this.pieceMeal(this.linked.scope, false);
                }
              } else {
                this.parentScope = this.markersScope;
                this.watchIdKey(this.parentScope);
                if (isCreatingFromScratch) {
                  return this.createAllNew(this.markersScope, true, 'plurals', false);
                } else {
                  return this.pieceMeal(this.markersScope, true, 'plurals', false);
                }
              }
            }
          };
          WindowsParentModel.prototype.watchIdKey = function(scope) {
            this.setIdKey(scope);
            return scope.$watch('idKey', (function(_this) {
              return function(newValue, oldValue) {
                if (newValue !== oldValue && (newValue == null)) {
                  _this.idKey = newValue;
                  return _this.rebuildAll(scope, true, true);
                }
              };
            })(this));
          };
          WindowsParentModel.prototype.createAllNew = function(scope, hasGMarker, modelsPropToIterate, isArray) {
            var maybeCanceled;
            if (modelsPropToIterate == null) {
              modelsPropToIterate = 'models';
            }
            if (isArray == null) {
              isArray = false;
            }
            if (this.firstTime) {
              this.watchModels(scope);
              this.watchDestroy(scope);
            }
            this.setContentKeys(scope.models);
            if (this.didQueueInitPromise(this, scope)) {
              return;
            }
            maybeCanceled = null;
            return _async.promiseLock(this, uiGmapPromise.promiseTypes.create, 'createAllNew', (function(canceledMsg) {
              return maybeCanceled = canceledMsg;
            }), (function(_this) {
              return function() {
                return _async.each(scope.models, function(model) {
                  var gMarker,
                      ref;
                  gMarker = hasGMarker ? (ref = _this.getItem(scope, modelsPropToIterate, model[_this.idKey])) != null ? ref.gObject : void 0 : void 0;
                  if (!maybeCanceled) {
                    if (!gMarker && _this.markersScope) {
                      $log.error('Unable to get gMarker from markersScope!');
                    }
                    _this.createWindow(model, gMarker, _this.gMap);
                  }
                  return maybeCanceled;
                }, _async.chunkSizeFrom(scope.chunk)).then(function() {
                  return _this.firstTime = false;
                });
              };
            })(this));
          };
          WindowsParentModel.prototype.pieceMeal = function(scope, hasGMarker, modelsPropToIterate, isArray) {
            var maybeCanceled,
                payload;
            if (modelsPropToIterate == null) {
              modelsPropToIterate = 'models';
            }
            if (isArray == null) {
              isArray = true;
            }
            if (scope.$$destroyed) {
              return;
            }
            maybeCanceled = null;
            payload = null;
            if ((scope != null) && this.modelsLength() && this.plurals.length) {
              return _async.promiseLock(this, uiGmapPromise.promiseTypes.update, 'pieceMeal', (function(canceledMsg) {
                return maybeCanceled = canceledMsg;
              }), (function(_this) {
                return function() {
                  return uiGmapPromise.promise((function() {
                    return _this.figureOutState(_this.idKey, scope, _this.plurals, _this.modelKeyComparison);
                  })).then(function(state) {
                    payload = state;
                    return _async.each(payload.removals, function(child) {
                      if (child != null) {
                        _this.plurals.remove(child.id);
                        if (child.destroy != null) {
                          child.destroy(true);
                        }
                        return maybeCanceled;
                      }
                    }, _async.chunkSizeFrom(scope.chunk));
                  }).then(function() {
                    return _async.each(payload.adds, function(modelToAdd) {
                      var gMarker,
                          ref;
                      gMarker = (ref = _this.getItem(scope, modelsPropToIterate, modelToAdd[_this.idKey])) != null ? ref.gObject : void 0;
                      if (!gMarker) {
                        throw 'Gmarker undefined';
                      }
                      _this.createWindow(modelToAdd, gMarker, _this.gMap);
                      return maybeCanceled;
                    });
                  }).then(function() {
                    return _async.each(payload.updates, function(update) {
                      _this.updateChild(update.child, update.model);
                      return maybeCanceled;
                    }, _async.chunkSizeFrom(scope.chunk));
                  });
                };
              })(this));
            } else {
              $log.debug('pieceMeal: rebuildAll');
              return this.rebuildAll(this.scope, true, true);
            }
          };
          WindowsParentModel.prototype.setContentKeys = function(models) {
            if (this.modelsLength(models)) {
              return this.contentKeys = Object.keys(models[0]);
            }
          };
          WindowsParentModel.prototype.createWindow = function(model, gMarker, gMap) {
            var child,
                childScope,
                fakeElement,
                opts,
                ref,
                ref1;
            childScope = this.linked.scope.$new(false);
            this.setChildScope(childScope, model);
            childScope.$watch('model', (function(_this) {
              return function(newValue, oldValue) {
                if (newValue !== oldValue) {
                  return _this.setChildScope(childScope, newValue);
                }
              };
            })(this), true);
            fakeElement = {html: (function(_this) {
                return function() {
                  return _this.interpolateContent(_this.linked.element.html(), model);
                };
              })(this)};
            this.DEFAULTS = this.scopeOrModelVal(this.optionsKey, this.scope, model) || {};
            opts = this.createWindowOptions(gMarker, childScope, fakeElement.html(), this.DEFAULTS);
            child = new WindowChildModel({
              model: model,
              scope: childScope,
              opts: opts,
              isIconVisibleOnClick: this.isIconVisibleOnClick,
              gMap: gMap,
              markerScope: (ref = this.markersScope) != null ? (ref1 = ref.plurals.get(model[this.idKey])) != null ? ref1.scope : void 0 : void 0,
              element: fakeElement,
              needToManualDestroy: false,
              markerIsVisibleAfterWindowClose: true,
              isScopeModel: true
            });
            if (model[this.idKey] == null) {
              this.$log.error('Window model has no id to assign a child to. This is required for performance. Please assign id, or redirect id to a different key.');
              return;
            }
            this.plurals.put(model[this.idKey], child);
            return child;
          };
          WindowsParentModel.prototype.setChildScope = function(childScope, model) {
            _.each(IWindow.scopeKeys, (function(_this) {
              return function(name) {
                var nameKey,
                    newValue;
                nameKey = name + 'Key';
                newValue = _this[nameKey] === 'self' ? model : model[_this[nameKey]];
                if (newValue !== childScope[name]) {
                  return childScope[name] = newValue;
                }
              };
            })(this));
            return childScope.model = model;
          };
          WindowsParentModel.prototype.interpolateContent = function(content, model) {
            var exp,
                i,
                interpModel,
                key,
                len,
                ref;
            if (this.contentKeys === void 0 || this.contentKeys.length === 0) {
              return;
            }
            exp = $interpolate(content);
            interpModel = {};
            ref = this.contentKeys;
            for (i = 0, len = ref.length; i < len; i++) {
              key = ref[i];
              interpModel[key] = model[key];
            }
            return exp(interpModel);
          };
          WindowsParentModel.prototype.modelKeyComparison = function(model1, model2) {
            var isEqual,
                scope;
            scope = this.scope.coords != null ? this.scope : this.parentScope;
            if (scope == null) {
              throw 'No scope or parentScope set!';
            }
            isEqual = GmapUtil.equalCoords(this.evalModelHandle(model1, scope.coords), this.evalModelHandle(model2, scope.coords));
            if (!isEqual) {
              return isEqual;
            }
            isEqual = _.every(_.without(this["interface"].scopeKeys, 'coords'), (function(_this) {
              return function(k) {
                return _this.evalModelHandle(model1, scope[k]) === _this.evalModelHandle(model2, scope[k]);
              };
            })(this));
            return isEqual;
          };
          return WindowsParentModel;
        })(IWindowParentModel);
        return WindowsParentModel;
      }]);
    }).call(this);
    ;
    (function() {
      angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapCircle", ["uiGmapICircle", "uiGmapCircleParentModel", function(ICircle, CircleParentModel) {
        return _.extend(ICircle, {link: function(scope, element, attrs, mapCtrl) {
            return mapCtrl.getScope().deferred.promise.then(function(gMap) {
              return new CircleParentModel(scope, element, attrs, gMap);
            });
          }});
      }]);
    }).call(this);
    ;
    (function() {
      var bind = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      },
          extend = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;
      angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapControl", ["uiGmapIControl", "$http", "$templateCache", "$compile", "$controller", 'uiGmapGoogleMapApi', function(IControl, $http, $templateCache, $compile, $controller, GoogleMapApi) {
        var Control;
        return Control = (function(superClass) {
          extend(Control, superClass);
          function Control() {
            this.link = bind(this.link, this);
            Control.__super__.constructor.call(this);
          }
          Control.prototype.link = function(scope, element, attrs, ctrl) {
            return GoogleMapApi.then((function(_this) {
              return function(maps) {
                var index,
                    position;
                if (angular.isUndefined(scope.template)) {
                  _this.$log.error('mapControl: could not find a valid template property');
                  return;
                }
                index = angular.isDefined(scope.index && !isNaN(parseInt(scope.index))) ? parseInt(scope.index) : void 0;
                position = angular.isDefined(scope.position) ? scope.position.toUpperCase().replace(/-/g, '_') : 'TOP_CENTER';
                if (!maps.ControlPosition[position]) {
                  _this.$log.error('mapControl: invalid position property');
                  return;
                }
                return IControl.mapPromise(scope, ctrl).then(function(map) {
                  var control,
                      controlDiv;
                  control = void 0;
                  controlDiv = angular.element('<div></div>');
                  return $http.get(scope.template, {cache: $templateCache}).success(function(template) {
                    var templateCtrl,
                        templateScope;
                    templateScope = scope.$new();
                    controlDiv.append(template);
                    if (angular.isDefined(scope.controller)) {
                      templateCtrl = $controller(scope.controller, {$scope: templateScope});
                      controlDiv.children().data('$ngControllerController', templateCtrl);
                    }
                    control = $compile(controlDiv.children())(templateScope);
                    if (index) {
                      return control[0].index = index;
                    }
                  }).error(function(error) {
                    return _this.$log.error('mapControl: template could not be found');
                  }).then(function() {
                    return map.controls[google.maps.ControlPosition[position]].push(control[0]);
                  });
                });
              };
            })(this));
          };
          return Control;
        })(IControl);
      }]);
    }).call(this);
    ;
    (function() {
      angular.module('uiGmapgoogle-maps.directives.api').service('uiGmapDragZoom', ['uiGmapCtrlHandle', 'uiGmapPropertyAction', function(CtrlHandle, PropertyAction) {
        return {
          restrict: 'EMA',
          transclude: true,
          template: '<div class="angular-google-map-dragzoom" ng-transclude style="display: none"></div>',
          require: '^' + 'uiGmapGoogleMap',
          scope: {
            keyboardkey: '=',
            options: '=',
            spec: '='
          },
          controller: ['$scope', '$element', function($scope, $element) {
            $scope.ctrlType = 'uiGmapDragZoom';
            return _.extend(this, CtrlHandle.handle($scope, $element));
          }],
          link: function(scope, element, attrs, ctrl) {
            return CtrlHandle.mapPromise(scope, ctrl).then(function(map) {
              var enableKeyDragZoom,
                  setKeyAction,
                  setOptionsAction;
              enableKeyDragZoom = function(opts) {
                return map.enableKeyDragZoom(opts);
              };
              setKeyAction = new PropertyAction(function(key, newVal) {
                if (newVal) {
                  return enableKeyDragZoom({key: newVal});
                } else {
                  return enableKeyDragZoom();
                }
              });
              setOptionsAction = new PropertyAction(function(key, newVal) {
                if (newVal) {
                  return enableKeyDragZoom(newVal);
                }
              });
              scope.$watch('keyboardkey', setKeyAction.sic('keyboardkey'));
              setKeyAction.sic(scope.keyboardkey);
              scope.$watch('options', setOptionsAction.sic('options'));
              return setOptionsAction.sic(scope.options);
            });
          }
        };
      }]);
    }).call(this);
    ;
    (function() {
      angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapDrawingManager", ["uiGmapIDrawingManager", "uiGmapDrawingManagerParentModel", function(IDrawingManager, DrawingManagerParentModel) {
        return _.extend(IDrawingManager, {link: function(scope, element, attrs, mapCtrl) {
            return mapCtrl.getScope().deferred.promise.then(function(map) {
              return new DrawingManagerParentModel(scope, element, attrs, map);
            });
          }});
      }]);
    }).call(this);
    ;
    (function() {
      var bind = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      },
          extend = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;
      angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapApiFreeDrawPolygons', ['uiGmapLogger', 'uiGmapBaseObject', 'uiGmapCtrlHandle', 'uiGmapDrawFreeHandChildModel', 'uiGmapLodash', function($log, BaseObject, CtrlHandle, DrawFreeHandChildModel, uiGmapLodash) {
        var FreeDrawPolygons;
        return FreeDrawPolygons = (function(superClass) {
          extend(FreeDrawPolygons, superClass);
          function FreeDrawPolygons() {
            this.link = bind(this.link, this);
            return FreeDrawPolygons.__super__.constructor.apply(this, arguments);
          }
          FreeDrawPolygons.include(CtrlHandle);
          FreeDrawPolygons.prototype.restrict = 'EMA';
          FreeDrawPolygons.prototype.replace = true;
          FreeDrawPolygons.prototype.require = '^' + 'uiGmapGoogleMap';
          FreeDrawPolygons.prototype.scope = {
            polygons: '=',
            draw: '='
          };
          FreeDrawPolygons.prototype.link = function(scope, element, attrs, ctrl) {
            return this.mapPromise(scope, ctrl).then((function(_this) {
              return function(map) {
                var freeHand,
                    listener;
                if (!scope.polygons) {
                  return $log.error('No polygons to bind to!');
                }
                if (!_.isArray(scope.polygons)) {
                  return $log.error('Free Draw Polygons must be of type Array!');
                }
                freeHand = new DrawFreeHandChildModel(map, ctrl.getScope());
                listener = void 0;
                return scope.draw = function() {
                  if (typeof listener === "function") {
                    listener();
                  }
                  return freeHand.engage(scope.polygons).then(function() {
                    var firstTime;
                    firstTime = true;
                    return listener = scope.$watchCollection('polygons', function(newValue, oldValue) {
                      var removals;
                      if (firstTime || newValue === oldValue) {
                        firstTime = false;
                        return;
                      }
                      removals = uiGmapLodash.differenceObjects(oldValue, newValue);
                      return removals.forEach(function(p) {
                        return p.setMap(null);
                      });
                    });
                  });
                };
              };
            })(this));
          };
          return FreeDrawPolygons;
        })(BaseObject);
      }]);
    }).call(this);
    ;
    (function() {
      angular.module("uiGmapgoogle-maps.directives.api").service("uiGmapICircle", [function() {
        var DEFAULTS;
        DEFAULTS = {};
        return {
          restrict: "EA",
          replace: true,
          require: '^' + 'uiGmapGoogleMap',
          scope: {
            center: "=center",
            radius: "=radius",
            stroke: "=stroke",
            fill: "=fill",
            clickable: "=",
            draggable: "=",
            editable: "=",
            geodesic: "=",
            icons: "=icons",
            visible: "=",
            events: "=",
            control: "=",
            zIndex: "=zindex"
          }
        };
      }]);
    }).call(this);
    ;
    (function() {
      var extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      },
          hasProp = {}.hasOwnProperty;
      angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapIControl", ["uiGmapBaseObject", "uiGmapLogger", "uiGmapCtrlHandle", function(BaseObject, Logger, CtrlHandle) {
        var IControl;
        return IControl = (function(superClass) {
          extend(IControl, superClass);
          IControl.extend(CtrlHandle);
          function IControl() {
            this.restrict = 'EA';
            this.replace = true;
            this.require = '^' + 'uiGmapGoogleMap';
            this.scope = {
              template: '@template',
              position: '@position',
              controller: '@controller',
              index: '@index'
            };
            this.$log = Logger;
          }
          IControl.prototype.link = function(scope, element, attrs, ctrl) {
            throw new Exception("Not implemented!!");
          };
          return IControl;
        })(BaseObject);
      }]);
    }).call(this);
    ;
    (function() {
      angular.module('uiGmapgoogle-maps.directives.api').service('uiGmapIDrawingManager', [function() {
        return {
          restrict: 'EA',
          replace: true,
          require: '^' + 'uiGmapGoogleMap',
          scope: {
            "static": '@',
            control: '=',
            options: '=',
            events: '='
          }
        };
      }]);
    }).call(this);
    ;
    (function() {
      var extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      },
          hasProp = {}.hasOwnProperty;
      angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapIMarker', ['uiGmapBaseObject', 'uiGmapCtrlHandle', function(BaseObject, CtrlHandle) {
        var IMarker;
        return IMarker = (function(superClass) {
          extend(IMarker, superClass);
          IMarker.scope = {
            coords: '=coords',
            icon: '=icon',
            click: '&click',
            options: '=options',
            events: '=events',
            fit: '=fit',
            idKey: '=idkey',
            control: '=control'
          };
          IMarker.scopeKeys = _.keys(IMarker.scope);
          IMarker.keys = IMarker.scopeKeys;
          IMarker.extend(CtrlHandle);
          function IMarker() {
            this.restrict = 'EMA';
            this.require = '^' + 'uiGmapGoogleMap';
            this.priority = -1;
            this.transclude = true;
            this.replace = true;
            this.scope = _.extend(this.scope || {}, IMarker.scope);
          }
          return IMarker;
        })(BaseObject);
      }]);
    }).call(this);
    ;
    (function() {
      var extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      },
          hasProp = {}.hasOwnProperty;
      angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapIPolygon', ['uiGmapGmapUtil', 'uiGmapBaseObject', 'uiGmapLogger', 'uiGmapCtrlHandle', function(GmapUtil, BaseObject, Logger, CtrlHandle) {
        var IPolygon;
        return IPolygon = (function(superClass) {
          extend(IPolygon, superClass);
          IPolygon.scope = {
            path: '=path',
            stroke: '=stroke',
            clickable: '=',
            draggable: '=',
            editable: '=',
            geodesic: '=',
            fill: '=',
            icons: '=icons',
            visible: '=',
            "static": '=',
            events: '=',
            zIndex: '=zindex',
            fit: '=',
            control: '=control'
          };
          IPolygon.scopeKeys = _.keys(IPolygon.scope);
          IPolygon.include(GmapUtil);
          IPolygon.extend(CtrlHandle);
          function IPolygon() {}
          IPolygon.prototype.restrict = 'EMA';
          IPolygon.prototype.replace = true;
          IPolygon.prototype.require = '^' + 'uiGmapGoogleMap';
          IPolygon.prototype.scope = IPolygon.scope;
          IPolygon.prototype.DEFAULTS = {};
          IPolygon.prototype.$log = Logger;
          return IPolygon;
        })(BaseObject);
      }]);
    }).call(this);
    ;
    (function() {
      var extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      },
          hasProp = {}.hasOwnProperty;
      angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapIPolyline', ['uiGmapGmapUtil', 'uiGmapBaseObject', 'uiGmapLogger', 'uiGmapCtrlHandle', function(GmapUtil, BaseObject, Logger, CtrlHandle) {
        var IPolyline;
        return IPolyline = (function(superClass) {
          extend(IPolyline, superClass);
          IPolyline.scope = {
            path: '=',
            stroke: '=',
            clickable: '=',
            draggable: '=',
            editable: '=',
            geodesic: '=',
            icons: '=',
            visible: '=',
            "static": '=',
            fit: '=',
            events: '=',
            zIndex: '=zindex'
          };
          IPolyline.scopeKeys = _.keys(IPolyline.scope);
          IPolyline.include(GmapUtil);
          IPolyline.extend(CtrlHandle);
          function IPolyline() {}
          IPolyline.prototype.restrict = 'EMA';
          IPolyline.prototype.replace = true;
          IPolyline.prototype.require = '^' + 'uiGmapGoogleMap';
          IPolyline.prototype.scope = IPolyline.scope;
          IPolyline.prototype.DEFAULTS = {};
          IPolyline.prototype.$log = Logger;
          return IPolyline;
        })(BaseObject);
      }]);
    }).call(this);
    ;
    (function() {
      angular.module('uiGmapgoogle-maps.directives.api').service('uiGmapIRectangle', [function() {
        'use strict';
        var DEFAULTS;
        DEFAULTS = {};
        return {
          restrict: 'EMA',
          require: '^' + 'uiGmapGoogleMap',
          replace: true,
          scope: {
            bounds: '=',
            stroke: '=',
            clickable: '=',
            draggable: '=',
            editable: '=',
            fill: '=',
            visible: '=',
            events: '='
          }
        };
      }]);
    }).call(this);
    ;
    (function() {
      var extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      },
          hasProp = {}.hasOwnProperty;
      angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapIWindow', ['uiGmapBaseObject', 'uiGmapChildEvents', 'uiGmapCtrlHandle', function(BaseObject, ChildEvents, CtrlHandle) {
        var IWindow;
        return IWindow = (function(superClass) {
          extend(IWindow, superClass);
          IWindow.scope = {
            coords: '=coords',
            template: '=template',
            templateUrl: '=templateurl',
            templateParameter: '=templateparameter',
            isIconVisibleOnClick: '=isiconvisibleonclick',
            closeClick: '&closeclick',
            options: '=options',
            control: '=control',
            show: '=show'
          };
          IWindow.scopeKeys = _.keys(IWindow.scope);
          IWindow.include(ChildEvents);
          IWindow.extend(CtrlHandle);
          function IWindow() {
            this.restrict = 'EMA';
            this.template = void 0;
            this.transclude = true;
            this.priority = -100;
            this.require = '^' + 'uiGmapGoogleMap';
            this.replace = true;
            this.scope = _.extend(this.scope || {}, IWindow.scope);
          }
          return IWindow;
        })(BaseObject);
      }]);
    }).call(this);
    ;
    (function() {
      var bind = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      },
          extend = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;
      angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapMap', ['$timeout', '$q', '$log', 'uiGmapGmapUtil', 'uiGmapBaseObject', 'uiGmapCtrlHandle', 'uiGmapIsReady', 'uiGmapuuid', 'uiGmapExtendGWin', 'uiGmapExtendMarkerClusterer', 'uiGmapGoogleMapsUtilV3', 'uiGmapGoogleMapApi', 'uiGmapEventsHelper', 'uiGmapGoogleMapObjectManager', function($timeout, $q, $log, uiGmapGmapUtil, uiGmapBaseObject, uiGmapCtrlHandle, uiGmapIsReady, uiGmapuuid, uiGmapExtendGWin, uiGmapExtendMarkerClusterer, uiGmapGoogleMapsUtilV3, uiGmapGoogleMapApi, uiGmapEventsHelper, uiGmapGoogleMapObjectManager) {
        var DEFAULTS,
            Map,
            initializeItems;
        DEFAULTS = void 0;
        initializeItems = [uiGmapGoogleMapsUtilV3, uiGmapExtendGWin, uiGmapExtendMarkerClusterer];
        return Map = (function(superClass) {
          extend(Map, superClass);
          Map.include(uiGmapGmapUtil);
          function Map() {
            this.link = bind(this.link, this);
            var ctrlFn;
            ctrlFn = function($scope) {
              var ctrlObj,
                  retCtrl;
              retCtrl = void 0;
              $scope.$on('$destroy', function() {
                return uiGmapIsReady.decrement();
              });
              ctrlObj = uiGmapCtrlHandle.handle($scope);
              $scope.ctrlType = 'Map';
              $scope.deferred.promise.then(function() {
                return initializeItems.forEach(function(i) {
                  return i.init();
                });
              });
              ctrlObj.getMap = function() {
                return $scope.map;
              };
              retCtrl = _.extend(this, ctrlObj);
              return retCtrl;
            };
            this.controller = ['$scope', ctrlFn];
          }
          Map.prototype.restrict = 'EMA';
          Map.prototype.transclude = true;
          Map.prototype.replace = false;
          Map.prototype.template = "<div class=\"angular-google-map\"><div class=\"angular-google-map-container\">\n</div><div ng-transclude style=\"display: none\"></div></div>";
          Map.prototype.scope = {
            center: '=',
            zoom: '=',
            dragging: '=',
            control: '=',
            options: '=',
            events: '=',
            eventOpts: '=',
            styles: '=',
            bounds: '=',
            update: '='
          };
          Map.prototype.link = function(scope, element, attrs) {
            var listeners,
                unbindCenterWatch;
            listeners = [];
            scope.$on('$destroy', function() {
              uiGmapEventsHelper.removeEvents(listeners);
              if (attrs.recycleMapInstance === 'true' && scope.map) {
                uiGmapGoogleMapObjectManager.recycleMapInstance(scope.map);
                return scope.map = null;
              }
            });
            scope.idleAndZoomChanged = false;
            if (scope.center == null) {
              unbindCenterWatch = scope.$watch('center', (function(_this) {
                return function() {
                  if (!scope.center) {
                    return;
                  }
                  unbindCenterWatch();
                  return _this.link(scope, element, attrs);
                };
              })(this));
              return;
            }
            return uiGmapGoogleMapApi.then((function(_this) {
              return function(maps) {
                var _gMap,
                    customListeners,
                    disabledEvents,
                    dragging,
                    el,
                    eventName,
                    getEventHandler,
                    mapOptions,
                    maybeHookToEvent,
                    opts,
                    ref,
                    resolveSpawned,
                    settingFromDirective,
                    spawned,
                    type,
                    updateCenter,
                    zoomPromise;
                DEFAULTS = {mapTypeId: maps.MapTypeId.ROADMAP};
                spawned = uiGmapIsReady.spawn();
                resolveSpawned = function() {
                  return spawned.deferred.resolve({
                    instance: spawned.instance,
                    map: _gMap
                  });
                };
                if (!_this.validateCoords(scope.center)) {
                  $log.error('angular-google-maps: could not find a valid center property');
                  return;
                }
                if (!angular.isDefined(scope.zoom)) {
                  $log.error('angular-google-maps: map zoom property not set');
                  return;
                }
                el = angular.element(element);
                el.addClass('angular-google-map');
                opts = {options: {}};
                if (attrs.options) {
                  opts.options = scope.options;
                }
                if (attrs.styles) {
                  opts.styles = scope.styles;
                }
                if (attrs.type) {
                  type = attrs.type.toUpperCase();
                  if (google.maps.MapTypeId.hasOwnProperty(type)) {
                    opts.mapTypeId = google.maps.MapTypeId[attrs.type.toUpperCase()];
                  } else {
                    $log.error("angular-google-maps: invalid map type '" + attrs.type + "'");
                  }
                }
                mapOptions = angular.extend({}, DEFAULTS, opts, {
                  center: _this.getCoords(scope.center),
                  zoom: scope.zoom,
                  bounds: scope.bounds
                });
                if (attrs.recycleMapInstance === 'true') {
                  _gMap = uiGmapGoogleMapObjectManager.createMapInstance(el.find('div')[1], mapOptions);
                } else {
                  _gMap = new google.maps.Map(el.find('div')[1], mapOptions);
                }
                _gMap['uiGmap_id'] = uiGmapuuid.generate();
                dragging = false;
                listeners.push(google.maps.event.addListenerOnce(_gMap, 'idle', function() {
                  scope.deferred.resolve(_gMap);
                  return resolveSpawned();
                }));
                disabledEvents = attrs.events && (((ref = scope.events) != null ? ref.blacklist : void 0) != null) ? scope.events.blacklist : [];
                if (_.isString(disabledEvents)) {
                  disabledEvents = [disabledEvents];
                }
                maybeHookToEvent = function(eventName, fn, prefn) {
                  if (!_.includes(disabledEvents, eventName)) {
                    if (prefn) {
                      prefn();
                    }
                    return listeners.push(google.maps.event.addListener(_gMap, eventName, function() {
                      var ref1;
                      if (!((ref1 = scope.update) != null ? ref1.lazy : void 0)) {
                        return fn();
                      }
                    }));
                  }
                };
                if (!_.includes(disabledEvents, 'all')) {
                  maybeHookToEvent('dragstart', function() {
                    dragging = true;
                    return scope.$evalAsync(function(s) {
                      if (s.dragging != null) {
                        return s.dragging = dragging;
                      }
                    });
                  });
                  maybeHookToEvent('dragend', function() {
                    dragging = false;
                    return scope.$evalAsync(function(s) {
                      if (s.dragging != null) {
                        return s.dragging = dragging;
                      }
                    });
                  });
                  updateCenter = function(c, s) {
                    if (c == null) {
                      c = _gMap.center;
                    }
                    if (s == null) {
                      s = scope;
                    }
                    if (_.includes(disabledEvents, 'center')) {
                      return;
                    }
                    if (angular.isDefined(s.center.type)) {
                      if (s.center.coordinates[1] !== c.lat()) {
                        s.center.coordinates[1] = c.lat();
                      }
                      if (s.center.coordinates[0] !== c.lng()) {
                        return s.center.coordinates[0] = c.lng();
                      }
                    } else {
                      if (s.center.latitude !== c.lat()) {
                        s.center.latitude = c.lat();
                      }
                      if (s.center.longitude !== c.lng()) {
                        return s.center.longitude = c.lng();
                      }
                    }
                  };
                  settingFromDirective = false;
                  maybeHookToEvent('idle', function() {
                    var b,
                        ne,
                        sw;
                    b = _gMap.getBounds();
                    ne = b.getNorthEast();
                    sw = b.getSouthWest();
                    settingFromDirective = true;
                    return scope.$evalAsync(function(s) {
                      updateCenter();
                      if (!_.isUndefined(s.bounds) && !_.includes(disabledEvents, 'bounds')) {
                        s.bounds.northeast = {
                          latitude: ne.lat(),
                          longitude: ne.lng()
                        };
                        s.bounds.southwest = {
                          latitude: sw.lat(),
                          longitude: sw.lng()
                        };
                      }
                      if (!_.includes(disabledEvents, 'zoom')) {
                        s.zoom = _gMap.zoom;
                        scope.idleAndZoomChanged = !scope.idleAndZoomChanged;
                      }
                      return settingFromDirective = false;
                    });
                  });
                }
                if (angular.isDefined(scope.events) && scope.events !== null && angular.isObject(scope.events)) {
                  getEventHandler = function(eventName) {
                    return function() {
                      return scope.events[eventName].apply(scope, [_gMap, eventName, arguments]);
                    };
                  };
                  customListeners = [];
                  for (eventName in scope.events) {
                    if (scope.events.hasOwnProperty(eventName) && angular.isFunction(scope.events[eventName])) {
                      customListeners.push(google.maps.event.addListener(_gMap, eventName, getEventHandler(eventName)));
                    }
                  }
                  listeners.concat(customListeners);
                }
                _gMap.getOptions = function() {
                  return mapOptions;
                };
                scope.map = _gMap;
                if ((attrs.control != null) && (scope.control != null)) {
                  scope.control.refresh = function(maybeCoords) {
                    var coords,
                        ref1,
                        ref2;
                    if (_gMap == null) {
                      return;
                    }
                    if (((typeof google !== "undefined" && google !== null ? (ref1 = google.maps) != null ? (ref2 = ref1.event) != null ? ref2.trigger : void 0 : void 0 : void 0) != null) && (_gMap != null)) {
                      google.maps.event.trigger(_gMap, 'resize');
                    }
                    if (((maybeCoords != null ? maybeCoords.latitude : void 0) != null) && ((maybeCoords != null ? maybeCoords.longitude : void 0) != null)) {
                      coords = _this.getCoords(maybeCoords);
                      if (_this.isTrue(attrs.pan)) {
                        return _gMap.panTo(coords);
                      } else {
                        return _gMap.setCenter(coords);
                      }
                    }
                  };
                  scope.control.getGMap = function() {
                    return _gMap;
                  };
                  scope.control.getMapOptions = function() {
                    return mapOptions;
                  };
                  scope.control.getCustomEventListeners = function() {
                    return customListeners;
                  };
                  scope.control.removeEvents = function(yourListeners) {
                    return uiGmapEventsHelper.removeEvents(yourListeners);
                  };
                }
                scope.$watch('center', function(newValue, oldValue) {
                  var coords;
                  if (newValue === oldValue || settingFromDirective) {
                    return;
                  }
                  coords = _this.getCoords(scope.center);
                  if (coords.lat() === _gMap.center.lat() && coords.lng() === _gMap.center.lng()) {
                    return;
                  }
                  if (!dragging) {
                    if (!_this.validateCoords(newValue)) {
                      $log.error("Invalid center for newValue: " + (JSON.stringify(newValue)));
                    }
                    if (_this.isTrue(attrs.pan) && scope.zoom === _gMap.zoom) {
                      return _gMap.panTo(coords);
                    } else {
                      return _gMap.setCenter(coords);
                    }
                  }
                }, true);
                zoomPromise = null;
                scope.$watch('zoom', function(newValue, oldValue) {
                  var ref1,
                      ref2;
                  if (newValue == null) {
                    return;
                  }
                  if (_.isEqual(newValue, oldValue) || (_gMap != null ? _gMap.getZoom() : void 0) === (scope != null ? scope.zoom : void 0) || settingFromDirective) {
                    return;
                  }
                  if (zoomPromise != null) {
                    $timeout.cancel(zoomPromise);
                  }
                  return zoomPromise = $timeout(function() {
                    return _gMap.setZoom(newValue);
                  }, ((ref1 = scope.eventOpts) != null ? (ref2 = ref1.debounce) != null ? ref2.zoomMs : void 0 : void 0) + 20, false);
                });
                scope.$watch('bounds', function(newValue, oldValue) {
                  var bounds,
                      ne,
                      ref1,
                      ref2,
                      ref3,
                      ref4,
                      sw;
                  if (newValue === oldValue) {
                    return;
                  }
                  if (((newValue != null ? (ref1 = newValue.northeast) != null ? ref1.latitude : void 0 : void 0) == null) || ((newValue != null ? (ref2 = newValue.northeast) != null ? ref2.longitude : void 0 : void 0) == null) || ((newValue != null ? (ref3 = newValue.southwest) != null ? ref3.latitude : void 0 : void 0) == null) || ((newValue != null ? (ref4 = newValue.southwest) != null ? ref4.longitude : void 0 : void 0) == null)) {
                    $log.error("Invalid map bounds for new value: " + (JSON.stringify(newValue)));
                    return;
                  }
                  ne = new google.maps.LatLng(newValue.northeast.latitude, newValue.northeast.longitude);
                  sw = new google.maps.LatLng(newValue.southwest.latitude, newValue.southwest.longitude);
                  bounds = new google.maps.LatLngBounds(sw, ne);
                  return _gMap.fitBounds(bounds);
                });
                return ['options', 'styles'].forEach(function(toWatch) {
                  return scope.$watch(toWatch, function(newValue, oldValue) {
                    if (_.isEqual(newValue, oldValue)) {
                      return;
                    }
                    if (toWatch === 'options') {
                      opts.options = newValue;
                    } else {
                      opts.options[toWatch] = newValue;
                    }
                    if (_gMap != null) {
                      return _gMap.setOptions(opts);
                    }
                  }, true);
                });
              };
            })(this));
          };
          return Map;
        })(uiGmapBaseObject);
      }]);
    }).call(this);
    ;
    (function() {
      var extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      },
          hasProp = {}.hasOwnProperty;
      angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapMarker", ["uiGmapIMarker", "uiGmapMarkerChildModel", "uiGmapMarkerManager", "uiGmapLogger", function(IMarker, MarkerChildModel, MarkerManager, $log) {
        var Marker;
        return Marker = (function(superClass) {
          extend(Marker, superClass);
          function Marker() {
            Marker.__super__.constructor.call(this);
            this.template = '<span class="angular-google-map-marker" ng-transclude></span>';
            $log.info(this);
          }
          Marker.prototype.controller = ['$scope', '$element', function($scope, $element) {
            $scope.ctrlType = 'Marker';
            return _.extend(this, IMarker.handle($scope, $element));
          }];
          Marker.prototype.link = function(scope, element, attrs, ctrl) {
            var mapPromise;
            mapPromise = IMarker.mapPromise(scope, ctrl);
            mapPromise.then(function(gMap) {
              var gManager,
                  keys,
                  m;
              gManager = new MarkerManager(gMap);
              keys = _.object(IMarker.keys, IMarker.keys);
              m = new MarkerChildModel({
                scope: scope,
                model: scope,
                keys: keys,
                gMap: gMap,
                doClick: true,
                gManager: gManager,
                doDrawSelf: false,
                trackModel: false
              });
              m.deferred.promise.then(function(gMarker) {
                return scope.deferred.resolve(gMarker);
              });
              if (scope.control != null) {
                return scope.control.getGMarkers = gManager.getGMarkers;
              }
            });
            return scope.$on('$destroy', function() {
              var gManager;
              if (typeof gManager !== "undefined" && gManager !== null) {
                gManager.clear();
              }
              return gManager = null;
            });
          };
          return Marker;
        })(IMarker);
      }]);
    }).call(this);
    ;
    (function() {
      var extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      },
          hasProp = {}.hasOwnProperty;
      angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapMarkers", ["uiGmapIMarker", "uiGmapPlural", "uiGmapMarkersParentModel", "uiGmap_sync", "uiGmapLogger", function(IMarker, Plural, MarkersParentModel, _sync, $log) {
        var Markers;
        return Markers = (function(superClass) {
          extend(Markers, superClass);
          function Markers() {
            Markers.__super__.constructor.call(this);
            this.template = '<span class="angular-google-map-markers" ng-transclude></span>';
            Plural.extend(this, {
              doCluster: '=?docluster',
              clusterOptions: '=clusteroptions',
              clusterEvents: '=clusterevents',
              modelsByRef: '=modelsbyref',
              type: '=?type',
              typeOptions: '=?typeoptions',
              typeEvents: '=?typeevents'
            });
            $log.info(this);
          }
          Markers.prototype.controller = ['$scope', '$element', function($scope, $element) {
            $scope.ctrlType = 'Markers';
            return _.extend(this, IMarker.handle($scope, $element));
          }];
          Markers.prototype.link = function(scope, element, attrs, ctrl) {
            var parentModel,
                ready;
            parentModel = void 0;
            ready = function() {
              return scope.deferred.resolve();
            };
            return IMarker.mapPromise(scope, ctrl).then(function(map) {
              var mapScope;
              mapScope = ctrl.getScope();
              mapScope.$watch('idleAndZoomChanged', function() {
                return _.defer(parentModel.gManager.draw);
              });
              parentModel = new MarkersParentModel(scope, element, attrs, map);
              Plural.link(scope, parentModel);
              if (scope.control != null) {
                scope.control.getGMarkers = function() {
                  var ref;
                  return (ref = parentModel.gManager) != null ? ref.getGMarkers() : void 0;
                };
                scope.control.getChildMarkers = function() {
                  return parentModel.plurals;
                };
              }
              return _.last(parentModel.existingPieces._content).then(function() {
                return ready();
              });
            });
          };
          return Markers;
        })(IMarker);
      }]);
    }).call(this);
    ;
    (function() {
      angular.module('uiGmapgoogle-maps.directives.api').service('uiGmapPlural', [function() {
        var _initControl;
        _initControl = function(scope, parent) {
          if (scope.control == null) {
            return;
          }
          scope.control.updateModels = function(models) {
            scope.models = models;
            return parent.createChildScopes(false);
          };
          scope.control.newModels = function(models) {
            scope.models = models;
            return parent.rebuildAll(scope, true, true);
          };
          scope.control.clean = function() {
            return parent.rebuildAll(scope, false, true);
          };
          scope.control.getPlurals = function() {
            return parent.plurals;
          };
          scope.control.getManager = function() {
            return parent.gManager;
          };
          scope.control.hasManager = function() {
            return (parent.gManager != null) === true;
          };
          return scope.control.managerDraw = function() {
            var ref;
            if (scope.control.hasManager()) {
              return (ref = scope.control.getManager()) != null ? ref.draw() : void 0;
            }
          };
        };
        return {
          extend: function(obj, obj2) {
            return _.extend(obj.scope || {}, obj2 || {}, {
              idKey: '=idkey',
              doRebuildAll: '=dorebuildall',
              models: '=models',
              chunk: '=chunk',
              cleanchunk: '=cleanchunk',
              control: '=control'
            });
          },
          link: function(scope, parent) {
            return _initControl(scope, parent);
          }
        };
      }]);
    }).call(this);
    ;
    (function() {
      var bind = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      },
          extend = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;
      angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapPolygon', ['uiGmapIPolygon', '$timeout', 'uiGmapPolygonChildModel', function(IPolygon, $timeout, PolygonChild) {
        var Polygon;
        return Polygon = (function(superClass) {
          extend(Polygon, superClass);
          function Polygon() {
            this.link = bind(this.link, this);
            return Polygon.__super__.constructor.apply(this, arguments);
          }
          Polygon.prototype.link = function(scope, element, attrs, mapCtrl) {
            var children,
                promise;
            children = [];
            promise = IPolygon.mapPromise(scope, mapCtrl);
            if (scope.control != null) {
              scope.control.getInstance = this;
              scope.control.polygons = children;
              scope.control.promise = promise;
            }
            return promise.then((function(_this) {
              return function(gMap) {
                return children.push(new PolygonChild({
                  scope: scope,
                  attrs: attrs,
                  gMap: gMap,
                  defaults: _this.DEFAULTS
                }));
              };
            })(this));
          };
          return Polygon;
        })(IPolygon);
      }]);
    }).call(this);
    ;
    (function() {
      var bind = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      },
          extend = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;
      angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapPolygons', ['uiGmapIPolygon', '$timeout', 'uiGmapPolygonsParentModel', 'uiGmapPlural', function(Interface, $timeout, ParentModel, Plural) {
        var Polygons;
        return Polygons = (function(superClass) {
          extend(Polygons, superClass);
          function Polygons() {
            this.link = bind(this.link, this);
            Polygons.__super__.constructor.call(this);
            Plural.extend(this);
            this.$log.info(this);
          }
          Polygons.prototype.link = function(scope, element, attrs, mapCtrl) {
            return mapCtrl.getScope().deferred.promise.then((function(_this) {
              return function(map) {
                if (angular.isUndefined(scope.path) || scope.path === null) {
                  _this.$log.warn('polygons: no valid path attribute found');
                }
                if (!scope.models) {
                  _this.$log.warn('polygons: no models found to create from');
                }
                return Plural.link(scope, new ParentModel(scope, element, attrs, map, _this.DEFAULTS));
              };
            })(this));
          };
          return Polygons;
        })(Interface);
      }]);
    }).call(this);
    ;
    (function() {
      var bind = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      },
          extend = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;
      angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapPolyline', ['uiGmapIPolyline', '$timeout', 'uiGmapPolylineChildModel', function(IPolyline, $timeout, PolylineChildModel) {
        var Polyline;
        return Polyline = (function(superClass) {
          extend(Polyline, superClass);
          function Polyline() {
            this.link = bind(this.link, this);
            return Polyline.__super__.constructor.apply(this, arguments);
          }
          Polyline.prototype.link = function(scope, element, attrs, mapCtrl) {
            return IPolyline.mapPromise(scope, mapCtrl).then((function(_this) {
              return function(gMap) {
                if (angular.isUndefined(scope.path) || scope.path === null || !_this.validatePath(scope.path)) {
                  _this.$log.warn('polyline: no valid path attribute found');
                }
                return new PolylineChildModel({
                  scope: scope,
                  attrs: attrs,
                  gMap: gMap,
                  defaults: _this.DEFAULTS
                });
              };
            })(this));
          };
          return Polyline;
        })(IPolyline);
      }]);
    }).call(this);
    ;
    (function() {
      var bind = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      },
          extend = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;
      angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapPolylines', ['uiGmapIPolyline', '$timeout', 'uiGmapPolylinesParentModel', 'uiGmapPlural', function(IPolyline, $timeout, PolylinesParentModel, Plural) {
        var Polylines;
        return Polylines = (function(superClass) {
          extend(Polylines, superClass);
          function Polylines() {
            this.link = bind(this.link, this);
            Polylines.__super__.constructor.call(this);
            Plural.extend(this);
            this.$log.info(this);
          }
          Polylines.prototype.link = function(scope, element, attrs, mapCtrl) {
            return mapCtrl.getScope().deferred.promise.then((function(_this) {
              return function(gMap) {
                if (angular.isUndefined(scope.path) || scope.path === null) {
                  _this.$log.warn('polylines: no valid path attribute found');
                }
                if (!scope.models) {
                  _this.$log.warn('polylines: no models found to create from');
                }
                return Plural.link(scope, new PolylinesParentModel(scope, element, attrs, gMap, _this.DEFAULTS));
              };
            })(this));
          };
          return Polylines;
        })(IPolyline);
      }]);
    }).call(this);
    ;
    (function() {
      angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapRectangle', ['uiGmapLogger', 'uiGmapGmapUtil', 'uiGmapIRectangle', 'uiGmapRectangleParentModel', function($log, GmapUtil, IRectangle, RectangleParentModel) {
        return _.extend(IRectangle, {link: function(scope, element, attrs, mapCtrl) {
            return mapCtrl.getScope().deferred.promise.then(function(gMap) {
              return new RectangleParentModel(scope, element, attrs, gMap);
            });
          }});
      }]);
    }).call(this);
    ;
    (function() {
      var bind = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      },
          extend = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;
      angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapWindow', ['uiGmapIWindow', 'uiGmapGmapUtil', 'uiGmapWindowChildModel', 'uiGmapLodash', 'uiGmapLogger', function(IWindow, GmapUtil, WindowChildModel, uiGmapLodash, $log) {
        var Window;
        return Window = (function(superClass) {
          extend(Window, superClass);
          Window.include(GmapUtil);
          function Window() {
            this.link = bind(this.link, this);
            Window.__super__.constructor.call(this);
            this.require = ['^' + 'uiGmapGoogleMap', '^?' + 'uiGmapMarker'];
            this.template = '<span class="angular-google-maps-window" ng-transclude></span>';
            $log.debug(this);
            this.childWindows = [];
          }
          Window.prototype.link = function(scope, element, attrs, ctrls) {
            var markerCtrl,
                markerScope;
            markerCtrl = ctrls.length > 1 && (ctrls[1] != null) ? ctrls[1] : void 0;
            markerScope = markerCtrl != null ? markerCtrl.getScope() : void 0;
            this.mapPromise = IWindow.mapPromise(scope, ctrls[0]);
            return this.mapPromise.then((function(_this) {
              return function(gMap) {
                var isIconVisibleOnClick;
                isIconVisibleOnClick = true;
                if (angular.isDefined(attrs.isiconvisibleonclick)) {
                  isIconVisibleOnClick = scope.isIconVisibleOnClick;
                }
                if (!markerCtrl) {
                  _this.init(scope, element, isIconVisibleOnClick, gMap);
                  return;
                }
                return markerScope.deferred.promise.then(function(gMarker) {
                  return _this.init(scope, element, isIconVisibleOnClick, gMap, markerScope);
                });
              };
            })(this));
          };
          Window.prototype.init = function(scope, element, isIconVisibleOnClick, gMap, markerScope) {
            var childWindow,
                defaults,
                gMarker,
                hasScopeCoords,
                opts;
            defaults = scope.options != null ? scope.options : {};
            hasScopeCoords = (scope != null) && this.validateCoords(scope.coords);
            if ((markerScope != null ? markerScope['getGMarker'] : void 0) != null) {
              gMarker = markerScope.getGMarker();
            }
            opts = hasScopeCoords ? this.createWindowOptions(gMarker, scope, element.html(), defaults) : defaults;
            if (gMap != null) {
              childWindow = new WindowChildModel({
                scope: scope,
                opts: opts,
                isIconVisibleOnClick: isIconVisibleOnClick,
                gMap: gMap,
                markerScope: markerScope,
                element: element
              });
              this.childWindows.push(childWindow);
              scope.$on('$destroy', (function(_this) {
                return function() {
                  _this.childWindows = uiGmapLodash.withoutObjects(_this.childWindows, [childWindow], function(child1, child2) {
                    return child1.scope.$id === child2.scope.$id;
                  });
                  return _this.childWindows.length = 0;
                };
              })(this));
            }
            if (scope.control != null) {
              scope.control.getGWindows = (function(_this) {
                return function() {
                  return _this.childWindows.map(function(child) {
                    return child.gObject;
                  });
                };
              })(this);
              scope.control.getChildWindows = (function(_this) {
                return function() {
                  return _this.childWindows;
                };
              })(this);
              scope.control.getPlurals = scope.control.getChildWindows;
              scope.control.showWindow = (function(_this) {
                return function() {
                  return _this.childWindows.map(function(child) {
                    return child.showWindow();
                  });
                };
              })(this);
              scope.control.hideWindow = (function(_this) {
                return function() {
                  return _this.childWindows.map(function(child) {
                    return child.hideWindow();
                  });
                };
              })(this);
            }
            if ((this.onChildCreation != null) && (childWindow != null)) {
              return this.onChildCreation(childWindow);
            }
          };
          return Window;
        })(IWindow);
      }]);
    }).call(this);
    ;
    (function() {
      var bind = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      },
          extend = function(child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key))
                child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;
      angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapWindows', ['uiGmapIWindow', 'uiGmapPlural', 'uiGmapWindowsParentModel', 'uiGmapPromise', 'uiGmapLogger', function(IWindow, Plural, WindowsParentModel, uiGmapPromise, $log) {
        var Windows;
        return Windows = (function(superClass) {
          extend(Windows, superClass);
          function Windows() {
            this.link = bind(this.link, this);
            Windows.__super__.constructor.call(this);
            this.require = ['^' + 'uiGmapGoogleMap', '^?' + 'uiGmapMarkers'];
            this.template = '<span class="angular-google-maps-windows" ng-transclude></span>';
            Plural.extend(this);
            $log.debug(this);
          }
          Windows.prototype.link = function(scope, element, attrs, ctrls) {
            var mapScope,
                markerCtrl,
                markerScope;
            mapScope = ctrls[0].getScope();
            markerCtrl = ctrls.length > 1 && (ctrls[1] != null) ? ctrls[1] : void 0;
            markerScope = markerCtrl != null ? markerCtrl.getScope() : void 0;
            return mapScope.deferred.promise.then((function(_this) {
              return function(map) {
                var promise,
                    ref;
                promise = (markerScope != null ? (ref = markerScope.deferred) != null ? ref.promise : void 0 : void 0) || uiGmapPromise.resolve();
                return promise.then(function() {
                  var pieces,
                      ref1;
                  pieces = (ref1 = _this.parentModel) != null ? ref1.existingPieces : void 0;
                  if (pieces) {
                    return pieces.then(function() {
                      return _this.init(scope, element, attrs, ctrls, map, markerScope);
                    });
                  } else {
                    return _this.init(scope, element, attrs, ctrls, map, markerScope);
                  }
                });
              };
            })(this));
          };
          Windows.prototype.init = function(scope, element, attrs, ctrls, map, additionalScope) {
            var parentModel;
            parentModel = new WindowsParentModel(scope, element, attrs, ctrls, map, additionalScope);
            Plural.link(scope, parentModel);
            if (scope.control != null) {
              scope.control.getGWindows = function() {
                return parentModel.plurals.map(function(child) {
                  return child.gObject;
                });
              };
              return scope.control.getChildWindows = function() {
                return parentModel.plurals;
              };
            }
          };
          return Windows;
        })(IWindow);
      }]);
    }).call(this);
    ;
    (function() {
      angular.module("uiGmapgoogle-maps").directive("uiGmapGoogleMap", ['uiGmapMap', function(uiGmapMap) {
        return new uiGmapMap();
      }]);
    }).call(this);
    ;
    (function() {
      angular.module('uiGmapgoogle-maps').directive('uiGmapMarker', ['$timeout', 'uiGmapMarker', function($timeout, Marker) {
        return new Marker($timeout);
      }]);
    }).call(this);
    ;
    (function() {
      angular.module('uiGmapgoogle-maps').directive('uiGmapMarkers', ['$timeout', 'uiGmapMarkers', function($timeout, Markers) {
        return new Markers($timeout);
      }]);
    }).call(this);
    ;
    (function() {
      angular.module('uiGmapgoogle-maps').directive('uiGmapPolygon', ['uiGmapPolygon', function(Polygon) {
        return new Polygon();
      }]);
    }).call(this);
    ;
    (function() {
      angular.module('uiGmapgoogle-maps').directive("uiGmapCircle", ["uiGmapCircle", function(Circle) {
        return Circle;
      }]);
    }).call(this);
    ;
    (function() {
      angular.module("uiGmapgoogle-maps").directive("uiGmapPolyline", ["uiGmapPolyline", function(Polyline) {
        return new Polyline();
      }]);
    }).call(this);
    ;
    (function() {
      angular.module('uiGmapgoogle-maps').directive('uiGmapPolylines', ['uiGmapPolylines', function(Polylines) {
        return new Polylines();
      }]);
    }).call(this);
    ;
    (function() {
      angular.module("uiGmapgoogle-maps").directive("uiGmapRectangle", ["uiGmapLogger", "uiGmapRectangle", function($log, Rectangle) {
        return Rectangle;
      }]);
    }).call(this);
    ;
    (function() {
      angular.module("uiGmapgoogle-maps").directive("uiGmapWindow", ["$timeout", "$compile", "$http", "$templateCache", "uiGmapWindow", function($timeout, $compile, $http, $templateCache, Window) {
        return new Window($timeout, $compile, $http, $templateCache);
      }]);
    }).call(this);
    ;
    (function() {
      angular.module("uiGmapgoogle-maps").directive("uiGmapWindows", ["$timeout", "$compile", "$http", "$templateCache", "$interpolate", "uiGmapWindows", function($timeout, $compile, $http, $templateCache, $interpolate, Windows) {
        return new Windows($timeout, $compile, $http, $templateCache, $interpolate);
      }]);
    }).call(this);
    ;
    (function() {
      var bind = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      };
      angular.module('uiGmapgoogle-maps').directive('uiGmapLayer', ['$timeout', 'uiGmapLogger', 'uiGmapLayerParentModel', function($timeout, Logger, LayerParentModel) {
        var Layer;
        Layer = (function() {
          function Layer() {
            this.link = bind(this.link, this);
            this.$log = Logger;
            this.restrict = 'EMA';
            this.require = '^' + 'uiGmapGoogleMap';
            this.priority = -1;
            this.transclude = true;
            this.template = '<span class=\'angular-google-map-layer\' ng-transclude></span>';
            this.replace = true;
            this.scope = {
              show: '=show',
              type: '=type',
              namespace: '=namespace',
              options: '=options',
              onCreated: '&oncreated'
            };
          }
          Layer.prototype.link = function(scope, element, attrs, mapCtrl) {
            return mapCtrl.getScope().deferred.promise.then((function(_this) {
              return function(map) {
                if (scope.onCreated != null) {
                  return new LayerParentModel(scope, element, attrs, map, scope.onCreated);
                } else {
                  return new LayerParentModel(scope, element, attrs, map);
                }
              };
            })(this));
          };
          return Layer;
        })();
        return new Layer();
      }]);
    }).call(this);
    ;
    (function() {
      angular.module("uiGmapgoogle-maps").directive("uiGmapMapControl", ["uiGmapControl", function(Control) {
        return new Control();
      }]);
    }).call(this);
    ;
    (function() {
      angular.module('uiGmapgoogle-maps').directive('uiGmapDragZoom', ['uiGmapDragZoom', function(DragZoom) {
        return DragZoom;
      }]);
    }).call(this);
    ;
    (function() {
      angular.module('uiGmapgoogle-maps').directive("uiGmapDrawingManager", ["uiGmapDrawingManager", function(DrawingManager) {
        return DrawingManager;
      }]);
    }).call(this);
    ;
    (function() {
      angular.module('uiGmapgoogle-maps').directive('uiGmapFreeDrawPolygons', ['uiGmapApiFreeDrawPolygons', function(FreeDrawPolygons) {
        return new FreeDrawPolygons();
      }]);
    }).call(this);
    ;
    (function() {
      var bind = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      };
      angular.module("uiGmapgoogle-maps").directive("uiGmapMapType", ["$timeout", "uiGmapLogger", "uiGmapMapTypeParentModel", function($timeout, Logger, MapTypeParentModel) {
        var MapType;
        MapType = (function() {
          function MapType() {
            this.link = bind(this.link, this);
            this.$log = Logger;
            this.restrict = "EMA";
            this.require = '^' + 'uiGmapGoogleMap';
            this.priority = -1;
            this.transclude = true;
            this.template = '<span class=\"angular-google-map-layer\" ng-transclude></span>';
            this.replace = true;
            this.scope = {
              show: "=show",
              options: '=options',
              refresh: '=refresh',
              id: '@'
            };
          }
          MapType.prototype.link = function(scope, element, attrs, mapCtrl) {
            return mapCtrl.getScope().deferred.promise.then((function(_this) {
              return function(map) {
                return new MapTypeParentModel(scope, element, attrs, map);
              };
            })(this));
          };
          return MapType;
        })();
        return new MapType();
      }]);
    }).call(this);
    ;
    (function() {
      angular.module('uiGmapgoogle-maps').directive('uiGmapPolygons', ['uiGmapPolygons', function(Polygons) {
        return new Polygons();
      }]);
    }).call(this);
    ;
    (function() {
      var bind = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      };
      angular.module('uiGmapgoogle-maps').directive('uiGmapSearchBox', ['uiGmapGoogleMapApi', 'uiGmapLogger', 'uiGmapSearchBoxParentModel', '$http', '$templateCache', '$compile', function(GoogleMapApi, Logger, SearchBoxParentModel, $http, $templateCache, $compile) {
        var SearchBox;
        SearchBox = (function() {
          SearchBox.prototype.require = 'ngModel';
          function SearchBox() {
            this.link = bind(this.link, this);
            this.$log = Logger;
            this.restrict = 'EMA';
            this.require = '^' + 'uiGmapGoogleMap';
            this.priority = -1;
            this.transclude = true;
            this.template = '<span class=\'angular-google-map-search\' ng-transclude></span>';
            this.replace = true;
            this.scope = {
              template: '=template',
              events: '=events',
              position: '=?position',
              options: '=?options',
              parentdiv: '=?parentdiv',
              ngModel: "=?"
            };
          }
          SearchBox.prototype.link = function(scope, element, attrs, mapCtrl) {
            return GoogleMapApi.then((function(_this) {
              return function(maps) {
                if (scope.template == null) {
                  $templateCache.put('uigmap-searchbox-default.tpl.html', '<input type="text">');
                  scope.template = 'uigmap-searchbox-default.tpl.html';
                }
                return $http.get(scope.template, {cache: $templateCache}).success(function(template) {
                  if (angular.isUndefined(scope.events)) {
                    _this.$log.error('searchBox: the events property is required');
                    return;
                  }
                  return mapCtrl.getScope().deferred.promise.then(function(map) {
                    var ctrlPosition;
                    ctrlPosition = angular.isDefined(scope.position) ? scope.position.toUpperCase().replace(/-/g, '_') : 'TOP_LEFT';
                    if (!maps.ControlPosition[ctrlPosition]) {
                      _this.$log.error('searchBox: invalid position property');
                      return;
                    }
                    return new SearchBoxParentModel(scope, element, attrs, map, ctrlPosition, $compile(template)(scope));
                  });
                });
              };
            })(this));
          };
          return SearchBox;
        })();
        return new SearchBox();
      }]);
    }).call(this);
    ;
    (function() {
      angular.module('uiGmapgoogle-maps').directive('uiGmapShow', ['$animate', 'uiGmapLogger', function($animate, $log) {
        return {
          scope: {
            'uiGmapShow': '=',
            'uiGmapAfterShow': '&',
            'uiGmapAfterHide': '&'
          },
          link: function(scope, element) {
            var angular_post_1_3_handle,
                angular_pre_1_3_handle,
                handle;
            angular_post_1_3_handle = function(animateAction, cb) {
              return $animate[animateAction](element, 'ng-hide').then(function() {
                return cb();
              });
            };
            angular_pre_1_3_handle = function(animateAction, cb) {
              return $animate[animateAction](element, 'ng-hide', cb);
            };
            handle = function(animateAction, cb) {
              if (angular.version.major > 1) {
                return $log.error("uiGmapShow is not supported for Angular Major greater than 1.\nYour Major is " + angular.version.major + "\"");
              }
              if (angular.version.major === 1 && angular.version.minor < 3) {
                return angular_pre_1_3_handle(animateAction, cb);
              }
              return angular_post_1_3_handle(animateAction, cb);
            };
            return scope.$watch('uiGmapShow', function(show) {
              if (show) {
                handle('removeClass', scope.uiGmapAfterShow);
              }
              if (!show) {
                return handle('addClass', scope.uiGmapAfterHide);
              }
            });
          }
        };
      }]);
    }).call(this);
    ;
    (function() {
      angular.module('uiGmapgoogle-maps').directive('uiGmapStreetViewPanorama', ['uiGmapGoogleMapApi', 'uiGmapLogger', 'uiGmapGmapUtil', 'uiGmapEventsHelper', function(GoogleMapApi, $log, GmapUtil, EventsHelper) {
        var name;
        name = 'uiGmapStreetViewPanorama';
        return {
          restrict: 'EMA',
          template: '<div class="angular-google-map-street-view-panorama"></div>',
          replace: true,
          scope: {
            focalcoord: '=',
            radius: '=?',
            events: '=?',
            options: '=?',
            control: '=?',
            povoptions: '=?',
            imagestatus: '='
          },
          link: function(scope, element, attrs) {
            return GoogleMapApi.then((function(_this) {
              return function(maps) {
                var clean,
                    create,
                    didCreateOptionsFromDirective,
                    firstTime,
                    handleSettings,
                    listeners,
                    opts,
                    pano,
                    povOpts,
                    sv;
                pano = void 0;
                sv = void 0;
                didCreateOptionsFromDirective = false;
                listeners = void 0;
                opts = null;
                povOpts = null;
                clean = function() {
                  EventsHelper.removeEvents(listeners);
                  if (pano != null) {
                    pano.unbind('position');
                    pano.setVisible(false);
                  }
                  if (sv != null) {
                    if ((sv != null ? sv.setVisible : void 0) != null) {
                      sv.setVisible(false);
                    }
                    return sv = void 0;
                  }
                };
                handleSettings = function(perspectivePoint, focalPoint) {
                  var heading;
                  heading = google.maps.geometry.spherical.computeHeading(perspectivePoint, focalPoint);
                  didCreateOptionsFromDirective = true;
                  scope.radius = scope.radius || 50;
                  povOpts = angular.extend({
                    heading: heading,
                    zoom: 1,
                    pitch: 0
                  }, scope.povoptions || {});
                  opts = opts = angular.extend({
                    navigationControl: false,
                    addressControl: false,
                    linksControl: false,
                    position: perspectivePoint,
                    pov: povOpts,
                    visible: true
                  }, scope.options || {});
                  return didCreateOptionsFromDirective = false;
                };
                create = function() {
                  var focalPoint;
                  if (!scope.focalcoord) {
                    $log.error(name + ": focalCoord needs to be defined");
                    return;
                  }
                  if (!scope.radius) {
                    $log.error(name + ": needs a radius to set the camera view from its focal target.");
                    return;
                  }
                  clean();
                  if (sv == null) {
                    sv = new google.maps.StreetViewService();
                  }
                  if (scope.events) {
                    listeners = EventsHelper.setEvents(sv, scope, scope);
                  }
                  focalPoint = GmapUtil.getCoords(scope.focalcoord);
                  return sv.getPanoramaByLocation(focalPoint, scope.radius, function(streetViewPanoramaData, status) {
                    var ele,
                        perspectivePoint,
                        ref;
                    if (scope.imagestatus != null) {
                      scope.imagestatus = status;
                    }
                    if (((ref = scope.events) != null ? ref.image_status_changed : void 0) != null) {
                      scope.events.image_status_changed(sv, 'image_status_changed', scope, status);
                    }
                    if (status === "OK") {
                      perspectivePoint = streetViewPanoramaData.location.latLng;
                      handleSettings(perspectivePoint, focalPoint);
                      ele = element[0];
                      return pano = new google.maps.StreetViewPanorama(ele, opts);
                    }
                  });
                };
                if (scope.control != null) {
                  scope.control.getOptions = function() {
                    return opts;
                  };
                  scope.control.getPovOptions = function() {
                    return povOpts;
                  };
                  scope.control.getGObject = function() {
                    return sv;
                  };
                  scope.control.getGPano = function() {
                    return pano;
                  };
                }
                scope.$watch('options', function(newValue, oldValue) {
                  if (newValue === oldValue || newValue === opts || didCreateOptionsFromDirective) {
                    return;
                  }
                  return create();
                });
                firstTime = true;
                scope.$watch('focalcoord', function(newValue, oldValue) {
                  if (newValue === oldValue && !firstTime) {
                    return;
                  }
                  if (newValue == null) {
                    return;
                  }
                  firstTime = false;
                  return create();
                });
                return scope.$on('$destroy', function() {
                  return clean();
                });
              };
            })(this));
          }
        };
      }]);
    }).call(this);
    ;
    angular.module('uiGmapgoogle-maps.wrapped').service('uiGmapuuid', function() {
      function UUID() {}
      UUID.generate = function() {
        var a = UUID._gri,
            b = UUID._ha;
        return b(a(32), 8) + "-" + b(a(16), 4) + "-" + b(16384 | a(12), 4) + "-" + b(32768 | a(14), 4) + "-" + b(a(48), 12);
      };
      UUID._gri = function(a) {
        return 0 > a ? NaN : 30 >= a ? 0 | Math.random() * (1 << a) : 53 >= a ? (0 | 1073741824 * Math.random()) + 1073741824 * (0 | Math.random() * (1 << a - 30)) : NaN;
      };
      UUID._ha = function(a, b) {
        for (var c = a.toString(16),
            d = b - c.length,
            e = "0"; 0 < d; d >>>= 1, e += e)
          d & 1 && (c = e + c);
        return c;
      };
      return UUID;
    });
    ;
    angular.module('uiGmapgoogle-maps.wrapped').service('uiGmapGoogleMapsUtilV3', function() {
      return {init: _.once(function() {
          +function() {
            function InfoBox(opt_opts) {
              opt_opts = opt_opts || {};
              google.maps.OverlayView.apply(this, arguments);
              this.content_ = opt_opts.content || "";
              this.disableAutoPan_ = opt_opts.disableAutoPan || false;
              this.maxWidth_ = opt_opts.maxWidth || 0;
              this.pixelOffset_ = opt_opts.pixelOffset || new google.maps.Size(0, 0);
              this.position_ = opt_opts.position || new google.maps.LatLng(0, 0);
              this.zIndex_ = opt_opts.zIndex || null;
              this.boxClass_ = opt_opts.boxClass || "infoBox";
              this.boxStyle_ = opt_opts.boxStyle || {};
              this.closeBoxMargin_ = opt_opts.closeBoxMargin || "2px";
              this.closeBoxURL_ = opt_opts.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif";
              if (opt_opts.closeBoxURL === "") {
                this.closeBoxURL_ = "";
              }
              this.infoBoxClearance_ = opt_opts.infoBoxClearance || new google.maps.Size(1, 1);
              if (typeof opt_opts.visible === "undefined") {
                if (typeof opt_opts.isHidden === "undefined") {
                  opt_opts.visible = true;
                } else {
                  opt_opts.visible = !opt_opts.isHidden;
                }
              }
              this.isHidden_ = !opt_opts.visible;
              this.alignBottom_ = opt_opts.alignBottom || false;
              this.pane_ = opt_opts.pane || "floatPane";
              this.enableEventPropagation_ = opt_opts.enableEventPropagation || false;
              this.div_ = null;
              this.closeListener_ = null;
              this.moveListener_ = null;
              this.contextListener_ = null;
              this.eventListeners_ = null;
              this.fixedWidthSet_ = null;
            }
            InfoBox.prototype = new google.maps.OverlayView();
            InfoBox.prototype.createInfoBoxDiv_ = function() {
              var i;
              var events;
              var bw;
              var me = this;
              var cancelHandler = function(e) {
                e.cancelBubble = true;
                if (e.stopPropagation) {
                  e.stopPropagation();
                }
              };
              var ignoreHandler = function(e) {
                e.returnValue = false;
                if (e.preventDefault) {
                  e.preventDefault();
                }
                if (!me.enableEventPropagation_) {
                  cancelHandler(e);
                }
              };
              if (!this.div_) {
                this.div_ = document.createElement("div");
                this.setBoxStyle_();
                if (typeof this.content_.nodeType === "undefined") {
                  this.div_.innerHTML = this.getCloseBoxImg_() + this.content_;
                } else {
                  this.div_.innerHTML = this.getCloseBoxImg_();
                  this.div_.appendChild(this.content_);
                }
                this.getPanes()[this.pane_].appendChild(this.div_);
                this.addClickHandler_();
                if (this.div_.style.width) {
                  this.fixedWidthSet_ = true;
                } else {
                  if (this.maxWidth_ !== 0 && this.div_.offsetWidth > this.maxWidth_) {
                    this.div_.style.width = this.maxWidth_;
                    this.div_.style.overflow = "auto";
                    this.fixedWidthSet_ = true;
                  } else {
                    bw = this.getBoxWidths_();
                    this.div_.style.width = (this.div_.offsetWidth - bw.left - bw.right) + "px";
                    this.fixedWidthSet_ = false;
                  }
                }
                this.panBox_(this.disableAutoPan_);
                if (!this.enableEventPropagation_) {
                  this.eventListeners_ = [];
                  events = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"];
                  for (i = 0; i < events.length; i++) {
                    this.eventListeners_.push(google.maps.event.addDomListener(this.div_, events[i], cancelHandler));
                  }
                  this.eventListeners_.push(google.maps.event.addDomListener(this.div_, "mouseover", function(e) {
                    this.style.cursor = "default";
                  }));
                }
                this.contextListener_ = google.maps.event.addDomListener(this.div_, "contextmenu", ignoreHandler);
                google.maps.event.trigger(this, "domready");
              }
            };
            InfoBox.prototype.getCloseBoxImg_ = function() {
              var img = "";
              if (this.closeBoxURL_ !== "") {
                img = "<img";
                img += " src='" + this.closeBoxURL_ + "'";
                img += " align=right";
                img += " style='";
                img += " position: relative;";
                img += " cursor: pointer;";
                img += " margin: " + this.closeBoxMargin_ + ";";
                img += "'>";
              }
              return img;
            };
            InfoBox.prototype.addClickHandler_ = function() {
              var closeBox;
              if (this.closeBoxURL_ !== "") {
                closeBox = this.div_.firstChild;
                this.closeListener_ = google.maps.event.addDomListener(closeBox, "click", this.getCloseClickHandler_());
              } else {
                this.closeListener_ = null;
              }
            };
            InfoBox.prototype.getCloseClickHandler_ = function() {
              var me = this;
              return function(e) {
                e.cancelBubble = true;
                if (e.stopPropagation) {
                  e.stopPropagation();
                }
                google.maps.event.trigger(me, "closeclick");
                me.close();
              };
            };
            InfoBox.prototype.panBox_ = function(disablePan) {
              var map;
              var bounds;
              var xOffset = 0,
                  yOffset = 0;
              if (!disablePan) {
                map = this.getMap();
                if (map instanceof google.maps.Map) {
                  if (!map.getBounds().contains(this.position_)) {
                    map.setCenter(this.position_);
                  }
                  bounds = map.getBounds();
                  var mapDiv = map.getDiv();
                  var mapWidth = mapDiv.offsetWidth;
                  var mapHeight = mapDiv.offsetHeight;
                  var iwOffsetX = this.pixelOffset_.width;
                  var iwOffsetY = this.pixelOffset_.height;
                  var iwWidth = this.div_.offsetWidth;
                  var iwHeight = this.div_.offsetHeight;
                  var padX = this.infoBoxClearance_.width;
                  var padY = this.infoBoxClearance_.height;
                  var pixPosition = this.getProjection().fromLatLngToContainerPixel(this.position_);
                  if (pixPosition.x < (-iwOffsetX + padX)) {
                    xOffset = pixPosition.x + iwOffsetX - padX;
                  } else if ((pixPosition.x + iwWidth + iwOffsetX + padX) > mapWidth) {
                    xOffset = pixPosition.x + iwWidth + iwOffsetX + padX - mapWidth;
                  }
                  if (this.alignBottom_) {
                    if (pixPosition.y < (-iwOffsetY + padY + iwHeight)) {
                      yOffset = pixPosition.y + iwOffsetY - padY - iwHeight;
                    } else if ((pixPosition.y + iwOffsetY + padY) > mapHeight) {
                      yOffset = pixPosition.y + iwOffsetY + padY - mapHeight;
                    }
                  } else {
                    if (pixPosition.y < (-iwOffsetY + padY)) {
                      yOffset = pixPosition.y + iwOffsetY - padY;
                    } else if ((pixPosition.y + iwHeight + iwOffsetY + padY) > mapHeight) {
                      yOffset = pixPosition.y + iwHeight + iwOffsetY + padY - mapHeight;
                    }
                  }
                  if (!(xOffset === 0 && yOffset === 0)) {
                    var c = map.getCenter();
                    map.panBy(xOffset, yOffset);
                  }
                }
              }
            };
            InfoBox.prototype.setBoxStyle_ = function() {
              var i,
                  boxStyle;
              if (this.div_) {
                this.div_.className = this.boxClass_;
                this.div_.style.cssText = "";
                boxStyle = this.boxStyle_;
                for (i in boxStyle) {
                  if (boxStyle.hasOwnProperty(i)) {
                    this.div_.style[i] = boxStyle[i];
                  }
                }
                this.div_.style.WebkitTransform = "translateZ(0)";
                if (typeof this.div_.style.opacity !== "undefined" && this.div_.style.opacity !== "") {
                  this.div_.style.MsFilter = "\"progid:DXImageTransform.Microsoft.Alpha(Opacity=" + (this.div_.style.opacity * 100) + ")\"";
                  this.div_.style.filter = "alpha(opacity=" + (this.div_.style.opacity * 100) + ")";
                }
                this.div_.style.position = "absolute";
                this.div_.style.visibility = 'hidden';
                if (this.zIndex_ !== null) {
                  this.div_.style.zIndex = this.zIndex_;
                }
              }
            };
            InfoBox.prototype.getBoxWidths_ = function() {
              var computedStyle;
              var bw = {
                top: 0,
                bottom: 0,
                left: 0,
                right: 0
              };
              var box = this.div_;
              if (document.defaultView && document.defaultView.getComputedStyle) {
                computedStyle = box.ownerDocument.defaultView.getComputedStyle(box, "");
                if (computedStyle) {
                  bw.top = parseInt(computedStyle.borderTopWidth, 10) || 0;
                  bw.bottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;
                  bw.left = parseInt(computedStyle.borderLeftWidth, 10) || 0;
                  bw.right = parseInt(computedStyle.borderRightWidth, 10) || 0;
                }
              } else if (document.documentElement.currentStyle) {
                if (box.currentStyle) {
                  bw.top = parseInt(box.currentStyle.borderTopWidth, 10) || 0;
                  bw.bottom = parseInt(box.currentStyle.borderBottomWidth, 10) || 0;
                  bw.left = parseInt(box.currentStyle.borderLeftWidth, 10) || 0;
                  bw.right = parseInt(box.currentStyle.borderRightWidth, 10) || 0;
                }
              }
              return bw;
            };
            InfoBox.prototype.onRemove = function() {
              if (this.div_) {
                this.div_.parentNode.removeChild(this.div_);
                this.div_ = null;
              }
            };
            InfoBox.prototype.draw = function() {
              this.createInfoBoxDiv_();
              var pixPosition = this.getProjection().fromLatLngToDivPixel(this.position_);
              this.div_.style.left = (pixPosition.x + this.pixelOffset_.width) + "px";
              if (this.alignBottom_) {
                this.div_.style.bottom = -(pixPosition.y + this.pixelOffset_.height) + "px";
              } else {
                this.div_.style.top = (pixPosition.y + this.pixelOffset_.height) + "px";
              }
              if (this.isHidden_) {
                this.div_.style.visibility = "hidden";
              } else {
                this.div_.style.visibility = "visible";
              }
            };
            InfoBox.prototype.setOptions = function(opt_opts) {
              if (typeof opt_opts.boxClass !== "undefined") {
                this.boxClass_ = opt_opts.boxClass;
                this.setBoxStyle_();
              }
              if (typeof opt_opts.boxStyle !== "undefined") {
                this.boxStyle_ = opt_opts.boxStyle;
                this.setBoxStyle_();
              }
              if (typeof opt_opts.content !== "undefined") {
                this.setContent(opt_opts.content);
              }
              if (typeof opt_opts.disableAutoPan !== "undefined") {
                this.disableAutoPan_ = opt_opts.disableAutoPan;
              }
              if (typeof opt_opts.maxWidth !== "undefined") {
                this.maxWidth_ = opt_opts.maxWidth;
              }
              if (typeof opt_opts.pixelOffset !== "undefined") {
                this.pixelOffset_ = opt_opts.pixelOffset;
              }
              if (typeof opt_opts.alignBottom !== "undefined") {
                this.alignBottom_ = opt_opts.alignBottom;
              }
              if (typeof opt_opts.position !== "undefined") {
                this.setPosition(opt_opts.position);
              }
              if (typeof opt_opts.zIndex !== "undefined") {
                this.setZIndex(opt_opts.zIndex);
              }
              if (typeof opt_opts.closeBoxMargin !== "undefined") {
                this.closeBoxMargin_ = opt_opts.closeBoxMargin;
              }
              if (typeof opt_opts.closeBoxURL !== "undefined") {
                this.closeBoxURL_ = opt_opts.closeBoxURL;
              }
              if (typeof opt_opts.infoBoxClearance !== "undefined") {
                this.infoBoxClearance_ = opt_opts.infoBoxClearance;
              }
              if (typeof opt_opts.isHidden !== "undefined") {
                this.isHidden_ = opt_opts.isHidden;
              }
              if (typeof opt_opts.visible !== "undefined") {
                this.isHidden_ = !opt_opts.visible;
              }
              if (typeof opt_opts.enableEventPropagation !== "undefined") {
                this.enableEventPropagation_ = opt_opts.enableEventPropagation;
              }
              if (this.div_) {
                this.draw();
              }
            };
            InfoBox.prototype.setContent = function(content) {
              this.content_ = content;
              if (this.div_) {
                if (this.closeListener_) {
                  google.maps.event.removeListener(this.closeListener_);
                  this.closeListener_ = null;
                }
                if (!this.fixedWidthSet_) {
                  this.div_.style.width = "";
                }
                if (typeof content.nodeType === "undefined") {
                  this.div_.innerHTML = this.getCloseBoxImg_() + content;
                } else {
                  this.div_.innerHTML = this.getCloseBoxImg_();
                  this.div_.appendChild(content);
                }
                if (!this.fixedWidthSet_) {
                  this.div_.style.width = this.div_.offsetWidth + "px";
                  if (typeof content.nodeType === "undefined") {
                    this.div_.innerHTML = this.getCloseBoxImg_() + content;
                  } else {
                    this.div_.innerHTML = this.getCloseBoxImg_();
                    this.div_.appendChild(content);
                  }
                }
                this.addClickHandler_();
              }
              google.maps.event.trigger(this, "content_changed");
            };
            InfoBox.prototype.setPosition = function(latlng) {
              this.position_ = latlng;
              if (this.div_) {
                this.draw();
              }
              google.maps.event.trigger(this, "position_changed");
            };
            InfoBox.prototype.setZIndex = function(index) {
              this.zIndex_ = index;
              if (this.div_) {
                this.div_.style.zIndex = index;
              }
              google.maps.event.trigger(this, "zindex_changed");
            };
            InfoBox.prototype.setVisible = function(isVisible) {
              this.isHidden_ = !isVisible;
              if (this.div_) {
                this.div_.style.visibility = (this.isHidden_ ? "hidden" : "visible");
              }
            };
            InfoBox.prototype.getContent = function() {
              return this.content_;
            };
            InfoBox.prototype.getPosition = function() {
              return this.position_;
            };
            InfoBox.prototype.getZIndex = function() {
              return this.zIndex_;
            };
            InfoBox.prototype.getVisible = function() {
              var isVisible;
              if ((typeof this.getMap() === "undefined") || (this.getMap() === null)) {
                isVisible = false;
              } else {
                isVisible = !this.isHidden_;
              }
              return isVisible;
            };
            InfoBox.prototype.show = function() {
              this.isHidden_ = false;
              if (this.div_) {
                this.div_.style.visibility = "visible";
              }
            };
            InfoBox.prototype.hide = function() {
              this.isHidden_ = true;
              if (this.div_) {
                this.div_.style.visibility = "hidden";
              }
            };
            InfoBox.prototype.open = function(map, anchor) {
              var me = this;
              if (anchor) {
                this.position_ = anchor.getPosition();
                this.moveListener_ = google.maps.event.addListener(anchor, "position_changed", function() {
                  me.setPosition(this.getPosition());
                });
              }
              this.setMap(map);
              if (this.div_) {
                this.panBox_();
              }
            };
            InfoBox.prototype.close = function() {
              var i;
              if (this.closeListener_) {
                google.maps.event.removeListener(this.closeListener_);
                this.closeListener_ = null;
              }
              if (this.eventListeners_) {
                for (i = 0; i < this.eventListeners_.length; i++) {
                  google.maps.event.removeListener(this.eventListeners_[i]);
                }
                this.eventListeners_ = null;
              }
              if (this.moveListener_) {
                google.maps.event.removeListener(this.moveListener_);
                this.moveListener_ = null;
              }
              if (this.contextListener_) {
                google.maps.event.removeListener(this.contextListener_);
                this.contextListener_ = null;
              }
              this.setMap(null);
            };
            (function() {
              var toPixels = function(widthValue) {
                var px;
                switch (widthValue) {
                  case "thin":
                    px = "2px";
                    break;
                  case "medium":
                    px = "4px";
                    break;
                  case "thick":
                    px = "6px";
                    break;
                  default:
                    px = widthValue;
                }
                return px;
              };
              var getBorderWidths = function(h) {
                var computedStyle;
                var bw = {};
                if (document.defaultView && document.defaultView.getComputedStyle) {
                  computedStyle = h.ownerDocument.defaultView.getComputedStyle(h, "");
                  if (computedStyle) {
                    bw.top = parseInt(computedStyle.borderTopWidth, 10) || 0;
                    bw.bottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;
                    bw.left = parseInt(computedStyle.borderLeftWidth, 10) || 0;
                    bw.right = parseInt(computedStyle.borderRightWidth, 10) || 0;
                    return bw;
                  }
                } else if (document.documentElement.currentStyle) {
                  if (h.currentStyle) {
                    bw.top = parseInt(toPixels(h.currentStyle.borderTopWidth), 10) || 0;
                    bw.bottom = parseInt(toPixels(h.currentStyle.borderBottomWidth), 10) || 0;
                    bw.left = parseInt(toPixels(h.currentStyle.borderLeftWidth), 10) || 0;
                    bw.right = parseInt(toPixels(h.currentStyle.borderRightWidth), 10) || 0;
                    return bw;
                  }
                }
                bw.top = parseInt(h.style["border-top-width"], 10) || 0;
                bw.bottom = parseInt(h.style["border-bottom-width"], 10) || 0;
                bw.left = parseInt(h.style["border-left-width"], 10) || 0;
                bw.right = parseInt(h.style["border-right-width"], 10) || 0;
                return bw;
              };
              var scroll = {
                x: 0,
                y: 0
              };
              var getScrollValue = function(e) {
                scroll.x = (typeof document.documentElement.scrollLeft !== "undefined" ? document.documentElement.scrollLeft : document.body.scrollLeft);
                scroll.y = (typeof document.documentElement.scrollTop !== "undefined" ? document.documentElement.scrollTop : document.body.scrollTop);
              };
              getScrollValue();
              var getMousePosition = function(e) {
                var posX = 0,
                    posY = 0;
                e = e || window.event;
                if (typeof e.pageX !== "undefined") {
                  posX = e.pageX;
                  posY = e.pageY;
                } else if (typeof e.clientX !== "undefined") {
                  posX = e.clientX + scroll.x;
                  posY = e.clientY + scroll.y;
                }
                return {
                  left: posX,
                  top: posY
                };
              };
              var getElementPosition = function(h) {
                var posX = h.offsetLeft;
                var posY = h.offsetTop;
                var parent = h.offsetParent;
                while (parent !== null) {
                  if (parent !== document.body && parent !== document.documentElement) {
                    posX -= parent.scrollLeft;
                    posY -= parent.scrollTop;
                  }
                  var m = parent;
                  var moffx = m.offsetLeft;
                  var moffy = m.offsetTop;
                  if (!moffx && !moffy && window.getComputedStyle) {
                    var matrix = document.defaultView.getComputedStyle(m, null).MozTransform || document.defaultView.getComputedStyle(m, null).WebkitTransform;
                    if (matrix) {
                      if (typeof matrix === "string") {
                        var parms = matrix.split(",");
                        moffx += parseInt(parms[4], 10) || 0;
                        moffy += parseInt(parms[5], 10) || 0;
                      }
                    }
                  }
                  posX += moffx;
                  posY += moffy;
                  parent = parent.offsetParent;
                }
                return {
                  left: posX,
                  top: posY
                };
              };
              var setVals = function(obj, vals) {
                if (obj && vals) {
                  for (var x in vals) {
                    if (vals.hasOwnProperty(x)) {
                      obj[x] = vals[x];
                    }
                  }
                }
                return obj;
              };
              var setOpacity = function(h, op) {
                if (typeof op !== "undefined") {
                  h.style.opacity = op;
                }
                if (typeof h.style.opacity !== "undefined" && h.style.opacity !== "") {
                  h.style.filter = "alpha(opacity=" + (h.style.opacity * 100) + ")";
                }
              };
              function DragZoom(map, opt_zoomOpts) {
                var me = this;
                var ov = new google.maps.OverlayView();
                ov.onAdd = function() {
                  me.init_(map, opt_zoomOpts);
                };
                ov.draw = function() {};
                ov.onRemove = function() {};
                ov.setMap(map);
                this.prjov_ = ov;
              }
              DragZoom.prototype.init_ = function(map, opt_zoomOpts) {
                var i;
                var me = this;
                this.map_ = map;
                opt_zoomOpts = opt_zoomOpts || {};
                this.key_ = opt_zoomOpts.key || "shift";
                this.key_ = this.key_.toLowerCase();
                this.borderWidths_ = getBorderWidths(this.map_.getDiv());
                this.veilDiv_ = [];
                for (i = 0; i < 4; i++) {
                  this.veilDiv_[i] = document.createElement("div");
                  this.veilDiv_[i].onselectstart = function() {
                    return false;
                  };
                  setVals(this.veilDiv_[i].style, {
                    backgroundColor: "gray",
                    opacity: 0.25,
                    cursor: "crosshair"
                  });
                  setVals(this.veilDiv_[i].style, opt_zoomOpts.paneStyle);
                  setVals(this.veilDiv_[i].style, opt_zoomOpts.veilStyle);
                  setVals(this.veilDiv_[i].style, {
                    position: "absolute",
                    overflow: "hidden",
                    display: "none"
                  });
                  if (this.key_ === "shift") {
                    this.veilDiv_[i].style.MozUserSelect = "none";
                  }
                  setOpacity(this.veilDiv_[i]);
                  if (this.veilDiv_[i].style.backgroundColor === "transparent") {
                    this.veilDiv_[i].style.backgroundColor = "white";
                    setOpacity(this.veilDiv_[i], 0);
                  }
                  this.map_.getDiv().appendChild(this.veilDiv_[i]);
                }
                this.noZoom_ = opt_zoomOpts.noZoom || false;
                this.visualEnabled_ = opt_zoomOpts.visualEnabled || false;
                this.visualClass_ = opt_zoomOpts.visualClass || "";
                this.visualPosition_ = opt_zoomOpts.visualPosition || google.maps.ControlPosition.LEFT_TOP;
                this.visualPositionOffset_ = opt_zoomOpts.visualPositionOffset || new google.maps.Size(35, 0);
                this.visualPositionIndex_ = opt_zoomOpts.visualPositionIndex || null;
                this.visualSprite_ = opt_zoomOpts.visualSprite || "http" + (document.location.protocol === "https:" ? "s" : "") + "://maps.gstatic.com/mapfiles/ftr/controls/dragzoom_btn.png";
                this.visualSize_ = opt_zoomOpts.visualSize || new google.maps.Size(20, 20);
                this.visualTips_ = opt_zoomOpts.visualTips || {};
                this.visualTips_.off = this.visualTips_.off || "Turn on drag zoom mode";
                this.visualTips_.on = this.visualTips_.on || "Turn off drag zoom mode";
                this.boxDiv_ = document.createElement("div");
                setVals(this.boxDiv_.style, {border: "4px solid #736AFF"});
                setVals(this.boxDiv_.style, opt_zoomOpts.boxStyle);
                setVals(this.boxDiv_.style, {
                  position: "absolute",
                  display: "none"
                });
                setOpacity(this.boxDiv_);
                this.map_.getDiv().appendChild(this.boxDiv_);
                this.boxBorderWidths_ = getBorderWidths(this.boxDiv_);
                this.listeners_ = [google.maps.event.addDomListener(document, "keydown", function(e) {
                  me.onKeyDown_(e);
                }), google.maps.event.addDomListener(document, "keyup", function(e) {
                  me.onKeyUp_(e);
                }), google.maps.event.addDomListener(this.veilDiv_[0], "mousedown", function(e) {
                  me.onMouseDown_(e);
                }), google.maps.event.addDomListener(this.veilDiv_[1], "mousedown", function(e) {
                  me.onMouseDown_(e);
                }), google.maps.event.addDomListener(this.veilDiv_[2], "mousedown", function(e) {
                  me.onMouseDown_(e);
                }), google.maps.event.addDomListener(this.veilDiv_[3], "mousedown", function(e) {
                  me.onMouseDown_(e);
                }), google.maps.event.addDomListener(document, "mousedown", function(e) {
                  me.onMouseDownDocument_(e);
                }), google.maps.event.addDomListener(document, "mousemove", function(e) {
                  me.onMouseMove_(e);
                }), google.maps.event.addDomListener(document, "mouseup", function(e) {
                  me.onMouseUp_(e);
                }), google.maps.event.addDomListener(window, "scroll", getScrollValue)];
                this.hotKeyDown_ = false;
                this.mouseDown_ = false;
                this.dragging_ = false;
                this.startPt_ = null;
                this.endPt_ = null;
                this.mapWidth_ = null;
                this.mapHeight_ = null;
                this.mousePosn_ = null;
                this.mapPosn_ = null;
                if (this.visualEnabled_) {
                  this.buttonDiv_ = this.initControl_(this.visualPositionOffset_);
                  if (this.visualPositionIndex_ !== null) {
                    this.buttonDiv_.index = this.visualPositionIndex_;
                  }
                  this.map_.controls[this.visualPosition_].push(this.buttonDiv_);
                  this.controlIndex_ = this.map_.controls[this.visualPosition_].length - 1;
                }
              };
              DragZoom.prototype.initControl_ = function(offset) {
                var control;
                var image;
                var me = this;
                control = document.createElement("div");
                control.className = this.visualClass_;
                control.style.position = "relative";
                control.style.overflow = "hidden";
                control.style.height = this.visualSize_.height + "px";
                control.style.width = this.visualSize_.width + "px";
                control.title = this.visualTips_.off;
                image = document.createElement("img");
                image.src = this.visualSprite_;
                image.style.position = "absolute";
                image.style.left = -(this.visualSize_.width * 2) + "px";
                image.style.top = 0 + "px";
                control.appendChild(image);
                control.onclick = function(e) {
                  me.hotKeyDown_ = !me.hotKeyDown_;
                  if (me.hotKeyDown_) {
                    me.buttonDiv_.firstChild.style.left = -(me.visualSize_.width * 0) + "px";
                    me.buttonDiv_.title = me.visualTips_.on;
                    me.activatedByControl_ = true;
                    google.maps.event.trigger(me, "activate");
                  } else {
                    me.buttonDiv_.firstChild.style.left = -(me.visualSize_.width * 2) + "px";
                    me.buttonDiv_.title = me.visualTips_.off;
                    google.maps.event.trigger(me, "deactivate");
                  }
                  me.onMouseMove_(e);
                };
                control.onmouseover = function() {
                  me.buttonDiv_.firstChild.style.left = -(me.visualSize_.width * 1) + "px";
                };
                control.onmouseout = function() {
                  if (me.hotKeyDown_) {
                    me.buttonDiv_.firstChild.style.left = -(me.visualSize_.width * 0) + "px";
                    me.buttonDiv_.title = me.visualTips_.on;
                  } else {
                    me.buttonDiv_.firstChild.style.left = -(me.visualSize_.width * 2) + "px";
                    me.buttonDiv_.title = me.visualTips_.off;
                  }
                };
                control.ondragstart = function() {
                  return false;
                };
                setVals(control.style, {
                  cursor: "pointer",
                  marginTop: offset.height + "px",
                  marginLeft: offset.width + "px"
                });
                return control;
              };
              DragZoom.prototype.isHotKeyDown_ = function(e) {
                var isHot;
                e = e || window.event;
                isHot = (e.shiftKey && this.key_ === "shift") || (e.altKey && this.key_ === "alt") || (e.ctrlKey && this.key_ === "ctrl");
                if (!isHot) {
                  switch (e.keyCode) {
                    case 16:
                      if (this.key_ === "shift") {
                        isHot = true;
                      }
                      break;
                    case 17:
                      if (this.key_ === "ctrl") {
                        isHot = true;
                      }
                      break;
                    case 18:
                      if (this.key_ === "alt") {
                        isHot = true;
                      }
                      break;
                  }
                }
                return isHot;
              };
              DragZoom.prototype.isMouseOnMap_ = function() {
                var mousePosn = this.mousePosn_;
                if (mousePosn) {
                  var mapPosn = this.mapPosn_;
                  var mapDiv = this.map_.getDiv();
                  return mousePosn.left > mapPosn.left && mousePosn.left < (mapPosn.left + mapDiv.offsetWidth) && mousePosn.top > mapPosn.top && mousePosn.top < (mapPosn.top + mapDiv.offsetHeight);
                } else {
                  return false;
                }
              };
              DragZoom.prototype.setVeilVisibility_ = function() {
                var i;
                if (this.map_ && this.hotKeyDown_ && this.isMouseOnMap_()) {
                  var mapDiv = this.map_.getDiv();
                  this.mapWidth_ = mapDiv.offsetWidth - (this.borderWidths_.left + this.borderWidths_.right);
                  this.mapHeight_ = mapDiv.offsetHeight - (this.borderWidths_.top + this.borderWidths_.bottom);
                  if (this.activatedByControl_) {
                    var left = parseInt(this.buttonDiv_.style.left, 10) + this.visualPositionOffset_.width;
                    var top = parseInt(this.buttonDiv_.style.top, 10) + this.visualPositionOffset_.height;
                    var width = this.visualSize_.width;
                    var height = this.visualSize_.height;
                    this.veilDiv_[0].style.top = "0px";
                    this.veilDiv_[0].style.left = "0px";
                    this.veilDiv_[0].style.width = left + "px";
                    this.veilDiv_[0].style.height = this.mapHeight_ + "px";
                    this.veilDiv_[1].style.top = "0px";
                    this.veilDiv_[1].style.left = (left + width) + "px";
                    this.veilDiv_[1].style.width = (this.mapWidth_ - (left + width)) + "px";
                    this.veilDiv_[1].style.height = this.mapHeight_ + "px";
                    this.veilDiv_[2].style.top = "0px";
                    this.veilDiv_[2].style.left = left + "px";
                    this.veilDiv_[2].style.width = width + "px";
                    this.veilDiv_[2].style.height = top + "px";
                    this.veilDiv_[3].style.top = (top + height) + "px";
                    this.veilDiv_[3].style.left = left + "px";
                    this.veilDiv_[3].style.width = width + "px";
                    this.veilDiv_[3].style.height = (this.mapHeight_ - (top + height)) + "px";
                    for (i = 0; i < this.veilDiv_.length; i++) {
                      this.veilDiv_[i].style.display = "block";
                    }
                  } else {
                    this.veilDiv_[0].style.left = "0px";
                    this.veilDiv_[0].style.top = "0px";
                    this.veilDiv_[0].style.width = this.mapWidth_ + "px";
                    this.veilDiv_[0].style.height = this.mapHeight_ + "px";
                    for (i = 1; i < this.veilDiv_.length; i++) {
                      this.veilDiv_[i].style.width = "0px";
                      this.veilDiv_[i].style.height = "0px";
                    }
                    for (i = 0; i < this.veilDiv_.length; i++) {
                      this.veilDiv_[i].style.display = "block";
                    }
                  }
                } else {
                  for (i = 0; i < this.veilDiv_.length; i++) {
                    this.veilDiv_[i].style.display = "none";
                  }
                }
              };
              DragZoom.prototype.onKeyDown_ = function(e) {
                if (this.map_ && !this.hotKeyDown_ && this.isHotKeyDown_(e)) {
                  this.mapPosn_ = getElementPosition(this.map_.getDiv());
                  this.hotKeyDown_ = true;
                  this.activatedByControl_ = false;
                  this.setVeilVisibility_();
                  google.maps.event.trigger(this, "activate");
                }
              };
              DragZoom.prototype.getMousePoint_ = function(e) {
                var mousePosn = getMousePosition(e);
                var p = new google.maps.Point();
                p.x = mousePosn.left - this.mapPosn_.left - this.borderWidths_.left;
                p.y = mousePosn.top - this.mapPosn_.top - this.borderWidths_.top;
                p.x = Math.min(p.x, this.mapWidth_);
                p.y = Math.min(p.y, this.mapHeight_);
                p.x = Math.max(p.x, 0);
                p.y = Math.max(p.y, 0);
                return p;
              };
              DragZoom.prototype.onMouseDown_ = function(e) {
                if (this.map_ && this.hotKeyDown_) {
                  this.mapPosn_ = getElementPosition(this.map_.getDiv());
                  this.dragging_ = true;
                  this.startPt_ = this.endPt_ = this.getMousePoint_(e);
                  this.boxDiv_.style.width = this.boxDiv_.style.height = "0px";
                  var prj = this.prjov_.getProjection();
                  var latlng = prj.fromContainerPixelToLatLng(this.startPt_);
                  google.maps.event.trigger(this, "dragstart", latlng);
                }
              };
              DragZoom.prototype.onMouseDownDocument_ = function(e) {
                this.mouseDown_ = true;
              };
              DragZoom.prototype.onMouseMove_ = function(e) {
                this.mousePosn_ = getMousePosition(e);
                if (this.dragging_) {
                  this.endPt_ = this.getMousePoint_(e);
                  var left = Math.min(this.startPt_.x, this.endPt_.x);
                  var top = Math.min(this.startPt_.y, this.endPt_.y);
                  var width = Math.abs(this.startPt_.x - this.endPt_.x);
                  var height = Math.abs(this.startPt_.y - this.endPt_.y);
                  var boxWidth = Math.max(0, width - (this.boxBorderWidths_.left + this.boxBorderWidths_.right));
                  var boxHeight = Math.max(0, height - (this.boxBorderWidths_.top + this.boxBorderWidths_.bottom));
                  this.veilDiv_[0].style.top = "0px";
                  this.veilDiv_[0].style.left = "0px";
                  this.veilDiv_[0].style.width = left + "px";
                  this.veilDiv_[0].style.height = this.mapHeight_ + "px";
                  this.veilDiv_[1].style.top = "0px";
                  this.veilDiv_[1].style.left = (left + width) + "px";
                  this.veilDiv_[1].style.width = (this.mapWidth_ - (left + width)) + "px";
                  this.veilDiv_[1].style.height = this.mapHeight_ + "px";
                  this.veilDiv_[2].style.top = "0px";
                  this.veilDiv_[2].style.left = left + "px";
                  this.veilDiv_[2].style.width = width + "px";
                  this.veilDiv_[2].style.height = top + "px";
                  this.veilDiv_[3].style.top = (top + height) + "px";
                  this.veilDiv_[3].style.left = left + "px";
                  this.veilDiv_[3].style.width = width + "px";
                  this.veilDiv_[3].style.height = (this.mapHeight_ - (top + height)) + "px";
                  this.boxDiv_.style.top = top + "px";
                  this.boxDiv_.style.left = left + "px";
                  this.boxDiv_.style.width = boxWidth + "px";
                  this.boxDiv_.style.height = boxHeight + "px";
                  this.boxDiv_.style.display = "block";
                  google.maps.event.trigger(this, "drag", new google.maps.Point(left, top + height), new google.maps.Point(left + width, top), this.prjov_.getProjection());
                } else if (!this.mouseDown_) {
                  this.mapPosn_ = getElementPosition(this.map_.getDiv());
                  this.setVeilVisibility_();
                }
              };
              DragZoom.prototype.onMouseUp_ = function(e) {
                var z;
                var me = this;
                this.mouseDown_ = false;
                if (this.dragging_) {
                  if ((this.getMousePoint_(e).x === this.startPt_.x) && (this.getMousePoint_(e).y === this.startPt_.y)) {
                    this.onKeyUp_(e);
                    return;
                  }
                  var left = Math.min(this.startPt_.x, this.endPt_.x);
                  var top = Math.min(this.startPt_.y, this.endPt_.y);
                  var width = Math.abs(this.startPt_.x - this.endPt_.x);
                  var height = Math.abs(this.startPt_.y - this.endPt_.y);
                  var kGoogleCenteringBug = true;
                  if (kGoogleCenteringBug) {
                    left += this.borderWidths_.left;
                    top += this.borderWidths_.top;
                  }
                  var prj = this.prjov_.getProjection();
                  var sw = prj.fromContainerPixelToLatLng(new google.maps.Point(left, top + height));
                  var ne = prj.fromContainerPixelToLatLng(new google.maps.Point(left + width, top));
                  var bnds = new google.maps.LatLngBounds(sw, ne);
                  if (this.noZoom_) {
                    this.boxDiv_.style.display = "none";
                  } else {
                    z = this.map_.getZoom();
                    this.map_.fitBounds(bnds);
                    if (this.map_.getZoom() < z) {
                      this.map_.setZoom(z);
                    }
                    var swPt = prj.fromLatLngToContainerPixel(sw);
                    var nePt = prj.fromLatLngToContainerPixel(ne);
                    if (kGoogleCenteringBug) {
                      swPt.x -= this.borderWidths_.left;
                      swPt.y -= this.borderWidths_.top;
                      nePt.x -= this.borderWidths_.left;
                      nePt.y -= this.borderWidths_.top;
                    }
                    this.boxDiv_.style.left = swPt.x + "px";
                    this.boxDiv_.style.top = nePt.y + "px";
                    this.boxDiv_.style.width = (Math.abs(nePt.x - swPt.x) - (this.boxBorderWidths_.left + this.boxBorderWidths_.right)) + "px";
                    this.boxDiv_.style.height = (Math.abs(nePt.y - swPt.y) - (this.boxBorderWidths_.top + this.boxBorderWidths_.bottom)) + "px";
                    setTimeout(function() {
                      me.boxDiv_.style.display = "none";
                    }, 1000);
                  }
                  this.dragging_ = false;
                  this.onMouseMove_(e);
                  google.maps.event.trigger(this, "dragend", bnds);
                  if (!this.isHotKeyDown_(e)) {
                    this.onKeyUp_(e);
                  }
                }
              };
              DragZoom.prototype.onKeyUp_ = function(e) {
                var i;
                var left,
                    top,
                    width,
                    height,
                    prj,
                    sw,
                    ne;
                var bnds = null;
                if (this.map_ && this.hotKeyDown_) {
                  this.hotKeyDown_ = false;
                  if (this.dragging_) {
                    this.boxDiv_.style.display = "none";
                    this.dragging_ = false;
                    left = Math.min(this.startPt_.x, this.endPt_.x);
                    top = Math.min(this.startPt_.y, this.endPt_.y);
                    width = Math.abs(this.startPt_.x - this.endPt_.x);
                    height = Math.abs(this.startPt_.y - this.endPt_.y);
                    prj = this.prjov_.getProjection();
                    sw = prj.fromContainerPixelToLatLng(new google.maps.Point(left, top + height));
                    ne = prj.fromContainerPixelToLatLng(new google.maps.Point(left + width, top));
                    bnds = new google.maps.LatLngBounds(sw, ne);
                  }
                  for (i = 0; i < this.veilDiv_.length; i++) {
                    this.veilDiv_[i].style.display = "none";
                  }
                  if (this.visualEnabled_) {
                    this.buttonDiv_.firstChild.style.left = -(this.visualSize_.width * 2) + "px";
                    this.buttonDiv_.title = this.visualTips_.off;
                    this.buttonDiv_.style.display = "";
                  }
                  google.maps.event.trigger(this, "deactivate", bnds);
                }
              };
              google.maps.Map.prototype.enableKeyDragZoom = function(opt_zoomOpts) {
                this.dragZoom_ = new DragZoom(this, opt_zoomOpts);
              };
              google.maps.Map.prototype.disableKeyDragZoom = function() {
                var i;
                var d = this.dragZoom_;
                if (d) {
                  for (i = 0; i < d.listeners_.length; ++i) {
                    google.maps.event.removeListener(d.listeners_[i]);
                  }
                  this.getDiv().removeChild(d.boxDiv_);
                  for (i = 0; i < d.veilDiv_.length; i++) {
                    this.getDiv().removeChild(d.veilDiv_[i]);
                  }
                  if (d.visualEnabled_) {
                    this.controls[d.visualPosition_].removeAt(d.controlIndex_);
                  }
                  d.prjov_.setMap(null);
                  this.dragZoom_ = null;
                }
              };
              google.maps.Map.prototype.keyDragZoomEnabled = function() {
                return this.dragZoom_ !== null;
              };
              google.maps.Map.prototype.getDragZoomObject = function() {
                return this.dragZoom_;
              };
            })();
            function ClusterIcon(cluster, styles) {
              cluster.getMarkerClusterer().extend(ClusterIcon, google.maps.OverlayView);
              this.cluster_ = cluster;
              this.className_ = cluster.getMarkerClusterer().getClusterClass();
              this.styles_ = styles;
              this.center_ = null;
              this.div_ = null;
              this.sums_ = null;
              this.visible_ = false;
              this.setMap(cluster.getMap());
            }
            ClusterIcon.prototype.onAdd = function() {
              var cClusterIcon = this;
              var cMouseDownInCluster;
              var cDraggingMapByCluster;
              this.div_ = document.createElement("div");
              this.div_.className = this.className_;
              if (this.visible_) {
                this.show();
              }
              this.getPanes().overlayMouseTarget.appendChild(this.div_);
              this.boundsChangedListener_ = google.maps.event.addListener(this.getMap(), "bounds_changed", function() {
                cDraggingMapByCluster = cMouseDownInCluster;
              });
              google.maps.event.addDomListener(this.div_, "mousedown", function() {
                cMouseDownInCluster = true;
                cDraggingMapByCluster = false;
              });
              google.maps.event.addDomListener(this.div_, "click", function(e) {
                cMouseDownInCluster = false;
                if (!cDraggingMapByCluster) {
                  var theBounds;
                  var mz;
                  var mc = cClusterIcon.cluster_.getMarkerClusterer();
                  google.maps.event.trigger(mc, "click", cClusterIcon.cluster_);
                  google.maps.event.trigger(mc, "clusterclick", cClusterIcon.cluster_);
                  if (mc.getZoomOnClick()) {
                    mz = mc.getMaxZoom();
                    theBounds = cClusterIcon.cluster_.getBounds();
                    mc.getMap().fitBounds(theBounds);
                    setTimeout(function() {
                      mc.getMap().fitBounds(theBounds);
                      if (mz !== null && (mc.getMap().getZoom() > mz)) {
                        mc.getMap().setZoom(mz + 1);
                      }
                    }, 100);
                  }
                  e.cancelBubble = true;
                  if (e.stopPropagation) {
                    e.stopPropagation();
                  }
                }
              });
              google.maps.event.addDomListener(this.div_, "mouseover", function() {
                var mc = cClusterIcon.cluster_.getMarkerClusterer();
                google.maps.event.trigger(mc, "mouseover", cClusterIcon.cluster_);
              });
              google.maps.event.addDomListener(this.div_, "mouseout", function() {
                var mc = cClusterIcon.cluster_.getMarkerClusterer();
                google.maps.event.trigger(mc, "mouseout", cClusterIcon.cluster_);
              });
            };
            ClusterIcon.prototype.onRemove = function() {
              if (this.div_ && this.div_.parentNode) {
                this.hide();
                google.maps.event.removeListener(this.boundsChangedListener_);
                google.maps.event.clearInstanceListeners(this.div_);
                this.div_.parentNode.removeChild(this.div_);
                this.div_ = null;
              }
            };
            ClusterIcon.prototype.draw = function() {
              if (this.visible_) {
                var pos = this.getPosFromLatLng_(this.center_);
                this.div_.style.top = pos.y + "px";
                this.div_.style.left = pos.x + "px";
              }
            };
            ClusterIcon.prototype.hide = function() {
              if (this.div_) {
                this.div_.style.display = "none";
              }
              this.visible_ = false;
            };
            ClusterIcon.prototype.show = function() {
              if (this.div_) {
                var img = "";
                var bp = this.backgroundPosition_.split(" ");
                var spriteH = parseInt(bp[0].trim(), 10);
                var spriteV = parseInt(bp[1].trim(), 10);
                var pos = this.getPosFromLatLng_(this.center_);
                this.div_.style.cssText = this.createCss(pos);
                img = "<img src='" + this.url_ + "' style='position: absolute; top: " + spriteV + "px; left: " + spriteH + "px; ";
                if (!this.cluster_.getMarkerClusterer().enableRetinaIcons_) {
                  img += "clip: rect(" + (-1 * spriteV) + "px, " + ((-1 * spriteH) + this.width_) + "px, " + ((-1 * spriteV) + this.height_) + "px, " + (-1 * spriteH) + "px);";
                }
                img += "'>";
                this.div_.innerHTML = img + "<div style='" + "position: absolute;" + "top: " + this.anchorText_[0] + "px;" + "left: " + this.anchorText_[1] + "px;" + "color: " + this.textColor_ + ";" + "font-size: " + this.textSize_ + "px;" + "font-family: " + this.fontFamily_ + ";" + "font-weight: " + this.fontWeight_ + ";" + "font-style: " + this.fontStyle_ + ";" + "text-decoration: " + this.textDecoration_ + ";" + "text-align: center;" + "width: " + this.width_ + "px;" + "line-height:" + this.height_ + "px;" + "'>" + this.sums_.text + "</div>";
                if (typeof this.sums_.title === "undefined" || this.sums_.title === "") {
                  this.div_.title = this.cluster_.getMarkerClusterer().getTitle();
                } else {
                  this.div_.title = this.sums_.title;
                }
                this.div_.style.display = "";
              }
              this.visible_ = true;
            };
            ClusterIcon.prototype.useStyle = function(sums) {
              this.sums_ = sums;
              var index = Math.max(0, sums.index - 1);
              index = Math.min(this.styles_.length - 1, index);
              var style = this.styles_[index];
              this.url_ = style.url;
              this.height_ = style.height;
              this.width_ = style.width;
              this.anchorText_ = style.anchorText || [0, 0];
              this.anchorIcon_ = style.anchorIcon || [parseInt(this.height_ / 2, 10), parseInt(this.width_ / 2, 10)];
              this.textColor_ = style.textColor || "black";
              this.textSize_ = style.textSize || 11;
              this.textDecoration_ = style.textDecoration || "none";
              this.fontWeight_ = style.fontWeight || "bold";
              this.fontStyle_ = style.fontStyle || "normal";
              this.fontFamily_ = style.fontFamily || "Arial,sans-serif";
              this.backgroundPosition_ = style.backgroundPosition || "0 0";
            };
            ClusterIcon.prototype.setCenter = function(center) {
              this.center_ = center;
            };
            ClusterIcon.prototype.createCss = function(pos) {
              var style = [];
              style.push("cursor: pointer;");
              style.push("position: absolute; top: " + pos.y + "px; left: " + pos.x + "px;");
              style.push("width: " + this.width_ + "px; height: " + this.height_ + "px;");
              return style.join("");
            };
            ClusterIcon.prototype.getPosFromLatLng_ = function(latlng) {
              var pos = this.getProjection().fromLatLngToDivPixel(latlng);
              pos.x -= this.anchorIcon_[1];
              pos.y -= this.anchorIcon_[0];
              pos.x = parseInt(pos.x, 10);
              pos.y = parseInt(pos.y, 10);
              return pos;
            };
            function Cluster(mc) {
              this.markerClusterer_ = mc;
              this.map_ = mc.getMap();
              this.gridSize_ = mc.getGridSize();
              this.minClusterSize_ = mc.getMinimumClusterSize();
              this.averageCenter_ = mc.getAverageCenter();
              this.markers_ = [];
              this.center_ = null;
              this.bounds_ = null;
              this.clusterIcon_ = new ClusterIcon(this, mc.getStyles());
            }
            Cluster.prototype.getSize = function() {
              return this.markers_.length;
            };
            Cluster.prototype.getMarkers = function() {
              return this.markers_;
            };
            Cluster.prototype.getCenter = function() {
              return this.center_;
            };
            Cluster.prototype.getMap = function() {
              return this.map_;
            };
            Cluster.prototype.getMarkerClusterer = function() {
              return this.markerClusterer_;
            };
            Cluster.prototype.getBounds = function() {
              var i;
              var bounds = new google.maps.LatLngBounds(this.center_, this.center_);
              var markers = this.getMarkers();
              for (i = 0; i < markers.length; i++) {
                bounds.extend(markers[i].getPosition());
              }
              return bounds;
            };
            Cluster.prototype.remove = function() {
              this.clusterIcon_.setMap(null);
              this.markers_ = [];
              delete this.markers_;
            };
            Cluster.prototype.addMarker = function(marker) {
              var i;
              var mCount;
              var mz;
              if (this.isMarkerAlreadyAdded_(marker)) {
                return false;
              }
              if (!this.center_) {
                this.center_ = marker.getPosition();
                this.calculateBounds_();
              } else {
                if (this.averageCenter_) {
                  var l = this.markers_.length + 1;
                  var lat = (this.center_.lat() * (l - 1) + marker.getPosition().lat()) / l;
                  var lng = (this.center_.lng() * (l - 1) + marker.getPosition().lng()) / l;
                  this.center_ = new google.maps.LatLng(lat, lng);
                  this.calculateBounds_();
                }
              }
              marker.isAdded = true;
              this.markers_.push(marker);
              mCount = this.markers_.length;
              mz = this.markerClusterer_.getMaxZoom();
              if (mz !== null && this.map_.getZoom() > mz) {
                if (marker.getMap() !== this.map_) {
                  marker.setMap(this.map_);
                }
              } else if (mCount < this.minClusterSize_) {
                if (marker.getMap() !== this.map_) {
                  marker.setMap(this.map_);
                }
              } else if (mCount === this.minClusterSize_) {
                for (i = 0; i < mCount; i++) {
                  this.markers_[i].setMap(null);
                }
              } else {
                marker.setMap(null);
              }
              this.updateIcon_();
              return true;
            };
            Cluster.prototype.isMarkerInClusterBounds = function(marker) {
              return this.bounds_.contains(marker.getPosition());
            };
            Cluster.prototype.calculateBounds_ = function() {
              var bounds = new google.maps.LatLngBounds(this.center_, this.center_);
              this.bounds_ = this.markerClusterer_.getExtendedBounds(bounds);
            };
            Cluster.prototype.updateIcon_ = function() {
              var mCount = this.markers_.length;
              var mz = this.markerClusterer_.getMaxZoom();
              if (mz !== null && this.map_.getZoom() > mz) {
                this.clusterIcon_.hide();
                return;
              }
              if (mCount < this.minClusterSize_) {
                this.clusterIcon_.hide();
                return;
              }
              var numStyles = this.markerClusterer_.getStyles().length;
              var sums = this.markerClusterer_.getCalculator()(this.markers_, numStyles);
              this.clusterIcon_.setCenter(this.center_);
              this.clusterIcon_.useStyle(sums);
              this.clusterIcon_.show();
            };
            Cluster.prototype.isMarkerAlreadyAdded_ = function(marker) {
              var i;
              if (this.markers_.indexOf) {
                return this.markers_.indexOf(marker) !== -1;
              } else {
                for (i = 0; i < this.markers_.length; i++) {
                  if (marker === this.markers_[i]) {
                    return true;
                  }
                }
              }
              return false;
            };
            function MarkerClusterer(map, opt_markers, opt_options) {
              this.extend(MarkerClusterer, google.maps.OverlayView);
              opt_markers = opt_markers || [];
              opt_options = opt_options || {};
              this.markers_ = [];
              this.clusters_ = [];
              this.listeners_ = [];
              this.activeMap_ = null;
              this.ready_ = false;
              this.gridSize_ = opt_options.gridSize || 60;
              this.minClusterSize_ = opt_options.minimumClusterSize || 2;
              this.maxZoom_ = opt_options.maxZoom || null;
              this.styles_ = opt_options.styles || [];
              this.title_ = opt_options.title || "";
              this.zoomOnClick_ = true;
              if (opt_options.zoomOnClick !== undefined) {
                this.zoomOnClick_ = opt_options.zoomOnClick;
              }
              this.averageCenter_ = false;
              if (opt_options.averageCenter !== undefined) {
                this.averageCenter_ = opt_options.averageCenter;
              }
              this.ignoreHidden_ = false;
              if (opt_options.ignoreHidden !== undefined) {
                this.ignoreHidden_ = opt_options.ignoreHidden;
              }
              this.enableRetinaIcons_ = false;
              if (opt_options.enableRetinaIcons !== undefined) {
                this.enableRetinaIcons_ = opt_options.enableRetinaIcons;
              }
              this.imagePath_ = opt_options.imagePath || MarkerClusterer.IMAGE_PATH;
              this.imageExtension_ = opt_options.imageExtension || MarkerClusterer.IMAGE_EXTENSION;
              this.imageSizes_ = opt_options.imageSizes || MarkerClusterer.IMAGE_SIZES;
              this.calculator_ = opt_options.calculator || MarkerClusterer.CALCULATOR;
              this.batchSize_ = opt_options.batchSize || MarkerClusterer.BATCH_SIZE;
              this.batchSizeIE_ = opt_options.batchSizeIE || MarkerClusterer.BATCH_SIZE_IE;
              this.clusterClass_ = opt_options.clusterClass || "cluster";
              if (navigator.userAgent.toLowerCase().indexOf("msie") !== -1) {
                this.batchSize_ = this.batchSizeIE_;
              }
              this.setupStyles_();
              this.addMarkers(opt_markers, true);
              this.setMap(map);
            }
            MarkerClusterer.prototype.onAdd = function() {
              var cMarkerClusterer = this;
              this.activeMap_ = this.getMap();
              this.ready_ = true;
              this.repaint();
              this.listeners_ = [google.maps.event.addListener(this.getMap(), "zoom_changed", function() {
                cMarkerClusterer.resetViewport_(false);
                if (this.getZoom() === (this.get("minZoom") || 0) || this.getZoom() === this.get("maxZoom")) {
                  google.maps.event.trigger(this, "idle");
                }
              }), google.maps.event.addListener(this.getMap(), "idle", function() {
                cMarkerClusterer.redraw_();
              })];
            };
            MarkerClusterer.prototype.onRemove = function() {
              var i;
              for (i = 0; i < this.markers_.length; i++) {
                if (this.markers_[i].getMap() !== this.activeMap_) {
                  this.markers_[i].setMap(this.activeMap_);
                }
              }
              for (i = 0; i < this.clusters_.length; i++) {
                this.clusters_[i].remove();
              }
              this.clusters_ = [];
              for (i = 0; i < this.listeners_.length; i++) {
                google.maps.event.removeListener(this.listeners_[i]);
              }
              this.listeners_ = [];
              this.activeMap_ = null;
              this.ready_ = false;
            };
            MarkerClusterer.prototype.draw = function() {};
            MarkerClusterer.prototype.setupStyles_ = function() {
              var i,
                  size;
              if (this.styles_.length > 0) {
                return;
              }
              for (i = 0; i < this.imageSizes_.length; i++) {
                size = this.imageSizes_[i];
                this.styles_.push({
                  url: this.imagePath_ + (i + 1) + "." + this.imageExtension_,
                  height: size,
                  width: size
                });
              }
            };
            MarkerClusterer.prototype.fitMapToMarkers = function() {
              var i;
              var markers = this.getMarkers();
              var bounds = new google.maps.LatLngBounds();
              for (i = 0; i < markers.length; i++) {
                bounds.extend(markers[i].getPosition());
              }
              this.getMap().fitBounds(bounds);
            };
            MarkerClusterer.prototype.getGridSize = function() {
              return this.gridSize_;
            };
            MarkerClusterer.prototype.setGridSize = function(gridSize) {
              this.gridSize_ = gridSize;
            };
            MarkerClusterer.prototype.getMinimumClusterSize = function() {
              return this.minClusterSize_;
            };
            MarkerClusterer.prototype.setMinimumClusterSize = function(minimumClusterSize) {
              this.minClusterSize_ = minimumClusterSize;
            };
            MarkerClusterer.prototype.getMaxZoom = function() {
              return this.maxZoom_;
            };
            MarkerClusterer.prototype.setMaxZoom = function(maxZoom) {
              this.maxZoom_ = maxZoom;
            };
            MarkerClusterer.prototype.getStyles = function() {
              return this.styles_;
            };
            MarkerClusterer.prototype.setStyles = function(styles) {
              this.styles_ = styles;
            };
            MarkerClusterer.prototype.getTitle = function() {
              return this.title_;
            };
            MarkerClusterer.prototype.setTitle = function(title) {
              this.title_ = title;
            };
            MarkerClusterer.prototype.getZoomOnClick = function() {
              return this.zoomOnClick_;
            };
            MarkerClusterer.prototype.setZoomOnClick = function(zoomOnClick) {
              this.zoomOnClick_ = zoomOnClick;
            };
            MarkerClusterer.prototype.getAverageCenter = function() {
              return this.averageCenter_;
            };
            MarkerClusterer.prototype.setAverageCenter = function(averageCenter) {
              this.averageCenter_ = averageCenter;
            };
            MarkerClusterer.prototype.getIgnoreHidden = function() {
              return this.ignoreHidden_;
            };
            MarkerClusterer.prototype.setIgnoreHidden = function(ignoreHidden) {
              this.ignoreHidden_ = ignoreHidden;
            };
            MarkerClusterer.prototype.getEnableRetinaIcons = function() {
              return this.enableRetinaIcons_;
            };
            MarkerClusterer.prototype.setEnableRetinaIcons = function(enableRetinaIcons) {
              this.enableRetinaIcons_ = enableRetinaIcons;
            };
            MarkerClusterer.prototype.getImageExtension = function() {
              return this.imageExtension_;
            };
            MarkerClusterer.prototype.setImageExtension = function(imageExtension) {
              this.imageExtension_ = imageExtension;
            };
            MarkerClusterer.prototype.getImagePath = function() {
              return this.imagePath_;
            };
            MarkerClusterer.prototype.setImagePath = function(imagePath) {
              this.imagePath_ = imagePath;
            };
            MarkerClusterer.prototype.getImageSizes = function() {
              return this.imageSizes_;
            };
            MarkerClusterer.prototype.setImageSizes = function(imageSizes) {
              this.imageSizes_ = imageSizes;
            };
            MarkerClusterer.prototype.getCalculator = function() {
              return this.calculator_;
            };
            MarkerClusterer.prototype.setCalculator = function(calculator) {
              this.calculator_ = calculator;
            };
            MarkerClusterer.prototype.getBatchSizeIE = function() {
              return this.batchSizeIE_;
            };
            MarkerClusterer.prototype.setBatchSizeIE = function(batchSizeIE) {
              this.batchSizeIE_ = batchSizeIE;
            };
            MarkerClusterer.prototype.getClusterClass = function() {
              return this.clusterClass_;
            };
            MarkerClusterer.prototype.setClusterClass = function(clusterClass) {
              this.clusterClass_ = clusterClass;
            };
            MarkerClusterer.prototype.getMarkers = function() {
              return this.markers_;
            };
            MarkerClusterer.prototype.getTotalMarkers = function() {
              return this.markers_.length;
            };
            MarkerClusterer.prototype.getClusters = function() {
              return this.clusters_;
            };
            MarkerClusterer.prototype.getTotalClusters = function() {
              return this.clusters_.length;
            };
            MarkerClusterer.prototype.addMarker = function(marker, opt_nodraw) {
              this.pushMarkerTo_(marker);
              if (!opt_nodraw) {
                this.redraw_();
              }
            };
            MarkerClusterer.prototype.addMarkers = function(markers, opt_nodraw) {
              var key;
              for (key in markers) {
                if (markers.hasOwnProperty(key)) {
                  this.pushMarkerTo_(markers[key]);
                }
              }
              if (!opt_nodraw) {
                this.redraw_();
              }
            };
            MarkerClusterer.prototype.pushMarkerTo_ = function(marker) {
              if (marker.getDraggable()) {
                var cMarkerClusterer = this;
                google.maps.event.addListener(marker, "dragend", function() {
                  if (cMarkerClusterer.ready_) {
                    this.isAdded = false;
                    cMarkerClusterer.repaint();
                  }
                });
              }
              marker.isAdded = false;
              this.markers_.push(marker);
            };
            MarkerClusterer.prototype.removeMarker = function(marker, opt_nodraw) {
              var removed = this.removeMarker_(marker);
              if (!opt_nodraw && removed) {
                this.repaint();
              }
              return removed;
            };
            MarkerClusterer.prototype.removeMarkers = function(markers, opt_nodraw) {
              var i,
                  r;
              var removed = false;
              for (i = 0; i < markers.length; i++) {
                r = this.removeMarker_(markers[i]);
                removed = removed || r;
              }
              if (!opt_nodraw && removed) {
                this.repaint();
              }
              return removed;
            };
            MarkerClusterer.prototype.removeMarker_ = function(marker) {
              var i;
              var index = -1;
              if (this.markers_.indexOf) {
                index = this.markers_.indexOf(marker);
              } else {
                for (i = 0; i < this.markers_.length; i++) {
                  if (marker === this.markers_[i]) {
                    index = i;
                    break;
                  }
                }
              }
              if (index === -1) {
                return false;
              }
              marker.setMap(null);
              this.markers_.splice(index, 1);
              return true;
            };
            MarkerClusterer.prototype.clearMarkers = function() {
              this.resetViewport_(true);
              this.markers_ = [];
            };
            MarkerClusterer.prototype.repaint = function() {
              var oldClusters = this.clusters_.slice();
              this.clusters_ = [];
              this.resetViewport_(false);
              this.redraw_();
              setTimeout(function() {
                var i;
                for (i = 0; i < oldClusters.length; i++) {
                  oldClusters[i].remove();
                }
              }, 0);
            };
            MarkerClusterer.prototype.getExtendedBounds = function(bounds) {
              var projection = this.getProjection();
              var tr = new google.maps.LatLng(bounds.getNorthEast().lat(), bounds.getNorthEast().lng());
              var bl = new google.maps.LatLng(bounds.getSouthWest().lat(), bounds.getSouthWest().lng());
              var trPix = projection.fromLatLngToDivPixel(tr);
              trPix.x += this.gridSize_;
              trPix.y -= this.gridSize_;
              var blPix = projection.fromLatLngToDivPixel(bl);
              blPix.x -= this.gridSize_;
              blPix.y += this.gridSize_;
              var ne = projection.fromDivPixelToLatLng(trPix);
              var sw = projection.fromDivPixelToLatLng(blPix);
              bounds.extend(ne);
              bounds.extend(sw);
              return bounds;
            };
            MarkerClusterer.prototype.redraw_ = function() {
              this.createClusters_(0);
            };
            MarkerClusterer.prototype.resetViewport_ = function(opt_hide) {
              var i,
                  marker;
              for (i = 0; i < this.clusters_.length; i++) {
                this.clusters_[i].remove();
              }
              this.clusters_ = [];
              for (i = 0; i < this.markers_.length; i++) {
                marker = this.markers_[i];
                marker.isAdded = false;
                if (opt_hide) {
                  marker.setMap(null);
                }
              }
            };
            MarkerClusterer.prototype.distanceBetweenPoints_ = function(p1, p2) {
              var R = 6371;
              var dLat = (p2.lat() - p1.lat()) * Math.PI / 180;
              var dLon = (p2.lng() - p1.lng()) * Math.PI / 180;
              var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(p1.lat() * Math.PI / 180) * Math.cos(p2.lat() * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
              var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
              var d = R * c;
              return d;
            };
            MarkerClusterer.prototype.isMarkerInBounds_ = function(marker, bounds) {
              return bounds.contains(marker.getPosition());
            };
            MarkerClusterer.prototype.addToClosestCluster_ = function(marker) {
              var i,
                  d,
                  cluster,
                  center;
              var distance = 40000;
              var clusterToAddTo = null;
              for (i = 0; i < this.clusters_.length; i++) {
                cluster = this.clusters_[i];
                center = cluster.getCenter();
                if (center) {
                  d = this.distanceBetweenPoints_(center, marker.getPosition());
                  if (d < distance) {
                    distance = d;
                    clusterToAddTo = cluster;
                  }
                }
              }
              if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {
                clusterToAddTo.addMarker(marker);
              } else {
                cluster = new Cluster(this);
                cluster.addMarker(marker);
                this.clusters_.push(cluster);
              }
            };
            MarkerClusterer.prototype.createClusters_ = function(iFirst) {
              var i,
                  marker;
              var mapBounds;
              var cMarkerClusterer = this;
              if (!this.ready_) {
                return;
              }
              if (iFirst === 0) {
                google.maps.event.trigger(this, "clusteringbegin", this);
                if (typeof this.timerRefStatic !== "undefined") {
                  clearTimeout(this.timerRefStatic);
                  delete this.timerRefStatic;
                }
              }
              if (this.getMap().getZoom() > 3) {
                mapBounds = new google.maps.LatLngBounds(this.getMap().getBounds().getSouthWest(), this.getMap().getBounds().getNorthEast());
              } else {
                mapBounds = new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625));
              }
              var bounds = this.getExtendedBounds(mapBounds);
              var iLast = Math.min(iFirst + this.batchSize_, this.markers_.length);
              for (i = iFirst; i < iLast; i++) {
                marker = this.markers_[i];
                if (!marker.isAdded && this.isMarkerInBounds_(marker, bounds)) {
                  if (!this.ignoreHidden_ || (this.ignoreHidden_ && marker.getVisible())) {
                    this.addToClosestCluster_(marker);
                  }
                }
              }
              if (iLast < this.markers_.length) {
                this.timerRefStatic = setTimeout(function() {
                  cMarkerClusterer.createClusters_(iLast);
                }, 0);
              } else {
                delete this.timerRefStatic;
                google.maps.event.trigger(this, "clusteringend", this);
              }
            };
            MarkerClusterer.prototype.extend = function(obj1, obj2) {
              return (function(object) {
                var property;
                for (property in object.prototype) {
                  this.prototype[property] = object.prototype[property];
                }
                return this;
              }).apply(obj1, [obj2]);
            };
            MarkerClusterer.CALCULATOR = function(markers, numStyles) {
              var index = 0;
              var title = "";
              var count = markers.length.toString();
              var dv = count;
              while (dv !== 0) {
                dv = parseInt(dv / 10, 10);
                index++;
              }
              index = Math.min(index, numStyles);
              return {
                text: count,
                index: index,
                title: title
              };
            };
            MarkerClusterer.BATCH_SIZE = 2000;
            MarkerClusterer.BATCH_SIZE_IE = 500;
            MarkerClusterer.IMAGE_PATH = "http://google-maps-utility-library-v3.googlecode.com/svn/trunk/markerclustererplus/images/m";
            MarkerClusterer.IMAGE_EXTENSION = "png";
            MarkerClusterer.IMAGE_SIZES = [53, 56, 66, 78, 90];
            function inherits(childCtor, parentCtor) {
              function tempCtor() {}
              tempCtor.prototype = parentCtor.prototype;
              childCtor.superClass_ = parentCtor.prototype;
              childCtor.prototype = new tempCtor();
              childCtor.prototype.constructor = childCtor;
            }
            function MarkerLabel_(marker, crossURL, handCursorURL) {
              this.marker_ = marker;
              this.handCursorURL_ = marker.handCursorURL;
              this.labelDiv_ = document.createElement("div");
              this.labelDiv_.style.cssText = "position: absolute; overflow: hidden;";
              this.eventDiv_ = document.createElement("div");
              this.eventDiv_.style.cssText = this.labelDiv_.style.cssText;
              this.eventDiv_.setAttribute("onselectstart", "return false;");
              this.eventDiv_.setAttribute("ondragstart", "return false;");
              this.crossDiv_ = MarkerLabel_.getSharedCross(crossURL);
            }
            inherits(MarkerLabel_, google.maps.OverlayView);
            MarkerLabel_.getSharedCross = function(crossURL) {
              var div;
              if (typeof MarkerLabel_.getSharedCross.crossDiv === "undefined") {
                div = document.createElement("img");
                div.style.cssText = "position: absolute; z-index: 1000002; display: none;";
                div.style.marginLeft = "-8px";
                div.style.marginTop = "-9px";
                div.src = crossURL;
                MarkerLabel_.getSharedCross.crossDiv = div;
              }
              return MarkerLabel_.getSharedCross.crossDiv;
            };
            MarkerLabel_.prototype.onAdd = function() {
              var me = this;
              var cMouseIsDown = false;
              var cDraggingLabel = false;
              var cSavedZIndex;
              var cLatOffset,
                  cLngOffset;
              var cIgnoreClick;
              var cRaiseEnabled;
              var cStartPosition;
              var cStartCenter;
              var cRaiseOffset = 20;
              var cDraggingCursor = "url(" + this.handCursorURL_ + ")";
              var cAbortEvent = function(e) {
                if (e.preventDefault) {
                  e.preventDefault();
                }
                e.cancelBubble = true;
                if (e.stopPropagation) {
                  e.stopPropagation();
                }
              };
              var cStopBounce = function() {
                me.marker_.setAnimation(null);
              };
              this.getPanes().overlayImage.appendChild(this.labelDiv_);
              this.getPanes().overlayMouseTarget.appendChild(this.eventDiv_);
              if (typeof MarkerLabel_.getSharedCross.processed === "undefined") {
                this.getPanes().overlayImage.appendChild(this.crossDiv_);
                MarkerLabel_.getSharedCross.processed = true;
              }
              this.listeners_ = [google.maps.event.addDomListener(this.eventDiv_, "mouseover", function(e) {
                if (me.marker_.getDraggable() || me.marker_.getClickable()) {
                  this.style.cursor = "pointer";
                  google.maps.event.trigger(me.marker_, "mouseover", e);
                }
              }), google.maps.event.addDomListener(this.eventDiv_, "mouseout", function(e) {
                if ((me.marker_.getDraggable() || me.marker_.getClickable()) && !cDraggingLabel) {
                  this.style.cursor = me.marker_.getCursor();
                  google.maps.event.trigger(me.marker_, "mouseout", e);
                }
              }), google.maps.event.addDomListener(this.eventDiv_, "mousedown", function(e) {
                cDraggingLabel = false;
                if (me.marker_.getDraggable()) {
                  cMouseIsDown = true;
                  this.style.cursor = cDraggingCursor;
                }
                if (me.marker_.getDraggable() || me.marker_.getClickable()) {
                  google.maps.event.trigger(me.marker_, "mousedown", e);
                  cAbortEvent(e);
                }
              }), google.maps.event.addDomListener(document, "mouseup", function(mEvent) {
                var position;
                if (cMouseIsDown) {
                  cMouseIsDown = false;
                  me.eventDiv_.style.cursor = "pointer";
                  google.maps.event.trigger(me.marker_, "mouseup", mEvent);
                }
                if (cDraggingLabel) {
                  if (cRaiseEnabled) {
                    position = me.getProjection().fromLatLngToDivPixel(me.marker_.getPosition());
                    position.y += cRaiseOffset;
                    me.marker_.setPosition(me.getProjection().fromDivPixelToLatLng(position));
                    try {
                      me.marker_.setAnimation(google.maps.Animation.BOUNCE);
                      setTimeout(cStopBounce, 1406);
                    } catch (e) {}
                  }
                  me.crossDiv_.style.display = "none";
                  me.marker_.setZIndex(cSavedZIndex);
                  cIgnoreClick = true;
                  cDraggingLabel = false;
                  mEvent.latLng = me.marker_.getPosition();
                  google.maps.event.trigger(me.marker_, "dragend", mEvent);
                }
              }), google.maps.event.addListener(me.marker_.getMap(), "mousemove", function(mEvent) {
                var position;
                if (cMouseIsDown) {
                  if (cDraggingLabel) {
                    mEvent.latLng = new google.maps.LatLng(mEvent.latLng.lat() - cLatOffset, mEvent.latLng.lng() - cLngOffset);
                    position = me.getProjection().fromLatLngToDivPixel(mEvent.latLng);
                    if (cRaiseEnabled) {
                      me.crossDiv_.style.left = position.x + "px";
                      me.crossDiv_.style.top = position.y + "px";
                      me.crossDiv_.style.display = "";
                      position.y -= cRaiseOffset;
                    }
                    me.marker_.setPosition(me.getProjection().fromDivPixelToLatLng(position));
                    if (cRaiseEnabled) {
                      me.eventDiv_.style.top = (position.y + cRaiseOffset) + "px";
                    }
                    google.maps.event.trigger(me.marker_, "drag", mEvent);
                  } else {
                    cLatOffset = mEvent.latLng.lat() - me.marker_.getPosition().lat();
                    cLngOffset = mEvent.latLng.lng() - me.marker_.getPosition().lng();
                    cSavedZIndex = me.marker_.getZIndex();
                    cStartPosition = me.marker_.getPosition();
                    cStartCenter = me.marker_.getMap().getCenter();
                    cRaiseEnabled = me.marker_.get("raiseOnDrag");
                    cDraggingLabel = true;
                    me.marker_.setZIndex(1000000);
                    mEvent.latLng = me.marker_.getPosition();
                    google.maps.event.trigger(me.marker_, "dragstart", mEvent);
                  }
                }
              }), google.maps.event.addDomListener(document, "keydown", function(e) {
                if (cDraggingLabel) {
                  if (e.keyCode === 27) {
                    cRaiseEnabled = false;
                    me.marker_.setPosition(cStartPosition);
                    me.marker_.getMap().setCenter(cStartCenter);
                    google.maps.event.trigger(document, "mouseup", e);
                  }
                }
              }), google.maps.event.addDomListener(this.eventDiv_, "click", function(e) {
                if (me.marker_.getDraggable() || me.marker_.getClickable()) {
                  if (cIgnoreClick) {
                    cIgnoreClick = false;
                  } else {
                    google.maps.event.trigger(me.marker_, "click", e);
                    cAbortEvent(e);
                  }
                }
              }), google.maps.event.addDomListener(this.eventDiv_, "dblclick", function(e) {
                if (me.marker_.getDraggable() || me.marker_.getClickable()) {
                  google.maps.event.trigger(me.marker_, "dblclick", e);
                  cAbortEvent(e);
                }
              }), google.maps.event.addListener(this.marker_, "dragstart", function(mEvent) {
                if (!cDraggingLabel) {
                  cRaiseEnabled = this.get("raiseOnDrag");
                }
              }), google.maps.event.addListener(this.marker_, "drag", function(mEvent) {
                if (!cDraggingLabel) {
                  if (cRaiseEnabled) {
                    me.setPosition(cRaiseOffset);
                    me.labelDiv_.style.zIndex = 1000000 + (this.get("labelInBackground") ? -1 : +1);
                  }
                }
              }), google.maps.event.addListener(this.marker_, "dragend", function(mEvent) {
                if (!cDraggingLabel) {
                  if (cRaiseEnabled) {
                    me.setPosition(0);
                  }
                }
              }), google.maps.event.addListener(this.marker_, "position_changed", function() {
                me.setPosition();
              }), google.maps.event.addListener(this.marker_, "zindex_changed", function() {
                me.setZIndex();
              }), google.maps.event.addListener(this.marker_, "visible_changed", function() {
                me.setVisible();
              }), google.maps.event.addListener(this.marker_, "labelvisible_changed", function() {
                me.setVisible();
              }), google.maps.event.addListener(this.marker_, "title_changed", function() {
                me.setTitle();
              }), google.maps.event.addListener(this.marker_, "labelcontent_changed", function() {
                me.setContent();
              }), google.maps.event.addListener(this.marker_, "labelanchor_changed", function() {
                me.setAnchor();
              }), google.maps.event.addListener(this.marker_, "labelclass_changed", function() {
                me.setStyles();
              }), google.maps.event.addListener(this.marker_, "labelstyle_changed", function() {
                me.setStyles();
              })];
            };
            MarkerLabel_.prototype.onRemove = function() {
              var i;
              this.labelDiv_.parentNode.removeChild(this.labelDiv_);
              this.eventDiv_.parentNode.removeChild(this.eventDiv_);
              for (i = 0; i < this.listeners_.length; i++) {
                google.maps.event.removeListener(this.listeners_[i]);
              }
            };
            MarkerLabel_.prototype.draw = function() {
              this.setContent();
              this.setTitle();
              this.setStyles();
            };
            MarkerLabel_.prototype.setContent = function() {
              var content = this.marker_.get("labelContent");
              if (typeof content.nodeType === "undefined") {
                this.labelDiv_.innerHTML = content;
                this.eventDiv_.innerHTML = this.labelDiv_.innerHTML;
              } else {
                this.labelDiv_.innerHTML = "";
                this.labelDiv_.appendChild(content);
                content = content.cloneNode(true);
                this.eventDiv_.innerHTML = "";
                this.eventDiv_.appendChild(content);
              }
            };
            MarkerLabel_.prototype.setTitle = function() {
              this.eventDiv_.title = this.marker_.getTitle() || "";
            };
            MarkerLabel_.prototype.setStyles = function() {
              var i,
                  labelStyle;
              this.labelDiv_.className = this.marker_.get("labelClass");
              this.eventDiv_.className = this.labelDiv_.className;
              this.labelDiv_.style.cssText = "";
              this.eventDiv_.style.cssText = "";
              labelStyle = this.marker_.get("labelStyle");
              for (i in labelStyle) {
                if (labelStyle.hasOwnProperty(i)) {
                  this.labelDiv_.style[i] = labelStyle[i];
                  this.eventDiv_.style[i] = labelStyle[i];
                }
              }
              this.setMandatoryStyles();
            };
            MarkerLabel_.prototype.setMandatoryStyles = function() {
              this.labelDiv_.style.position = "absolute";
              this.labelDiv_.style.overflow = "hidden";
              if (typeof this.labelDiv_.style.opacity !== "undefined" && this.labelDiv_.style.opacity !== "") {
                this.labelDiv_.style.MsFilter = "\"progid:DXImageTransform.Microsoft.Alpha(opacity=" + (this.labelDiv_.style.opacity * 100) + ")\"";
                this.labelDiv_.style.filter = "alpha(opacity=" + (this.labelDiv_.style.opacity * 100) + ")";
              }
              this.eventDiv_.style.position = this.labelDiv_.style.position;
              this.eventDiv_.style.overflow = this.labelDiv_.style.overflow;
              this.eventDiv_.style.opacity = 0.01;
              this.eventDiv_.style.MsFilter = "\"progid:DXImageTransform.Microsoft.Alpha(opacity=1)\"";
              this.eventDiv_.style.filter = "alpha(opacity=1)";
              this.setAnchor();
              this.setPosition();
              this.setVisible();
            };
            MarkerLabel_.prototype.setAnchor = function() {
              var anchor = this.marker_.get("labelAnchor");
              this.labelDiv_.style.marginLeft = -anchor.x + "px";
              this.labelDiv_.style.marginTop = -anchor.y + "px";
              this.eventDiv_.style.marginLeft = -anchor.x + "px";
              this.eventDiv_.style.marginTop = -anchor.y + "px";
            };
            MarkerLabel_.prototype.setPosition = function(yOffset) {
              var position = this.getProjection().fromLatLngToDivPixel(this.marker_.getPosition());
              if (typeof yOffset === "undefined") {
                yOffset = 0;
              }
              this.labelDiv_.style.left = Math.round(position.x) + "px";
              this.labelDiv_.style.top = Math.round(position.y - yOffset) + "px";
              this.eventDiv_.style.left = this.labelDiv_.style.left;
              this.eventDiv_.style.top = this.labelDiv_.style.top;
              this.setZIndex();
            };
            MarkerLabel_.prototype.setZIndex = function() {
              var zAdjust = (this.marker_.get("labelInBackground") ? -1 : +1);
              if (typeof this.marker_.getZIndex() === "undefined") {
                this.labelDiv_.style.zIndex = parseInt(this.labelDiv_.style.top, 10) + zAdjust;
                this.eventDiv_.style.zIndex = this.labelDiv_.style.zIndex;
              } else {
                this.labelDiv_.style.zIndex = this.marker_.getZIndex() + zAdjust;
                this.eventDiv_.style.zIndex = this.labelDiv_.style.zIndex;
              }
            };
            MarkerLabel_.prototype.setVisible = function() {
              if (this.marker_.get("labelVisible")) {
                this.labelDiv_.style.display = this.marker_.getVisible() ? "block" : "none";
              } else {
                this.labelDiv_.style.display = "none";
              }
              this.eventDiv_.style.display = this.labelDiv_.style.display;
            };
            function MarkerWithLabel(opt_options) {
              opt_options = opt_options || {};
              opt_options.labelContent = opt_options.labelContent || "";
              opt_options.labelAnchor = opt_options.labelAnchor || new google.maps.Point(0, 0);
              opt_options.labelClass = opt_options.labelClass || "markerLabels";
              opt_options.labelStyle = opt_options.labelStyle || {};
              opt_options.labelInBackground = opt_options.labelInBackground || false;
              if (typeof opt_options.labelVisible === "undefined") {
                opt_options.labelVisible = true;
              }
              if (typeof opt_options.raiseOnDrag === "undefined") {
                opt_options.raiseOnDrag = true;
              }
              if (typeof opt_options.clickable === "undefined") {
                opt_options.clickable = true;
              }
              if (typeof opt_options.draggable === "undefined") {
                opt_options.draggable = false;
              }
              if (typeof opt_options.optimized === "undefined") {
                opt_options.optimized = false;
              }
              opt_options.crossImage = opt_options.crossImage || "http" + (document.location.protocol === "https:" ? "s" : "") + "://maps.gstatic.com/intl/en_us/mapfiles/drag_cross_67_16.png";
              opt_options.handCursor = opt_options.handCursor || "http" + (document.location.protocol === "https:" ? "s" : "") + "://maps.gstatic.com/intl/en_us/mapfiles/closedhand_8_8.cur";
              opt_options.optimized = false;
              this.label = new MarkerLabel_(this, opt_options.crossImage, opt_options.handCursor);
              google.maps.Marker.apply(this, arguments);
            }
            inherits(MarkerWithLabel, google.maps.Marker);
            MarkerWithLabel.prototype.setMap = function(theMap) {
              google.maps.Marker.prototype.setMap.apply(this, arguments);
              this.label.setMap(theMap);
            };
            function RichMarker(opt_options) {
              var options = opt_options || {};
              this.ready_ = false;
              this.dragging_ = false;
              if (opt_options['visible'] == undefined) {
                opt_options['visible'] = true;
              }
              if (opt_options['shadow'] == undefined) {
                opt_options['shadow'] = '7px -3px 5px rgba(88,88,88,0.7)';
              }
              if (opt_options['anchor'] == undefined) {
                opt_options['anchor'] = RichMarkerPosition['BOTTOM'];
              }
              this.setValues(options);
            }
            RichMarker.prototype = new google.maps.OverlayView();
            window['RichMarker'] = RichMarker;
            RichMarker.prototype.getVisible = function() {
              return (this.get('visible'));
            };
            RichMarker.prototype['getVisible'] = RichMarker.prototype.getVisible;
            RichMarker.prototype.setVisible = function(visible) {
              this.set('visible', visible);
            };
            RichMarker.prototype['setVisible'] = RichMarker.prototype.setVisible;
            RichMarker.prototype.visible_changed = function() {
              if (this.ready_) {
                this.markerWrapper_.style['display'] = this.getVisible() ? '' : 'none';
                this.draw();
              }
            };
            RichMarker.prototype['visible_changed'] = RichMarker.prototype.visible_changed;
            RichMarker.prototype.setFlat = function(flat) {
              this.set('flat', !!flat);
            };
            RichMarker.prototype['setFlat'] = RichMarker.prototype.setFlat;
            RichMarker.prototype.getFlat = function() {
              return (this.get('flat'));
            };
            RichMarker.prototype['getFlat'] = RichMarker.prototype.getFlat;
            RichMarker.prototype.getWidth = function() {
              return (this.get('width'));
            };
            RichMarker.prototype['getWidth'] = RichMarker.prototype.getWidth;
            RichMarker.prototype.getHeight = function() {
              return (this.get('height'));
            };
            RichMarker.prototype['getHeight'] = RichMarker.prototype.getHeight;
            RichMarker.prototype.setShadow = function(shadow) {
              this.set('shadow', shadow);
              this.flat_changed();
            };
            RichMarker.prototype['setShadow'] = RichMarker.prototype.setShadow;
            RichMarker.prototype.getShadow = function() {
              return (this.get('shadow'));
            };
            RichMarker.prototype['getShadow'] = RichMarker.prototype.getShadow;
            RichMarker.prototype.flat_changed = function() {
              if (!this.ready_) {
                return;
              }
              this.markerWrapper_.style['boxShadow'] = this.markerWrapper_.style['webkitBoxShadow'] = this.markerWrapper_.style['MozBoxShadow'] = this.getFlat() ? '' : this.getShadow();
            };
            RichMarker.prototype['flat_changed'] = RichMarker.prototype.flat_changed;
            RichMarker.prototype.setZIndex = function(index) {
              this.set('zIndex', index);
            };
            RichMarker.prototype['setZIndex'] = RichMarker.prototype.setZIndex;
            RichMarker.prototype.getZIndex = function() {
              return (this.get('zIndex'));
            };
            RichMarker.prototype['getZIndex'] = RichMarker.prototype.getZIndex;
            RichMarker.prototype.zIndex_changed = function() {
              if (this.getZIndex() && this.ready_) {
                this.markerWrapper_.style.zIndex = this.getZIndex();
              }
            };
            RichMarker.prototype['zIndex_changed'] = RichMarker.prototype.zIndex_changed;
            RichMarker.prototype.getDraggable = function() {
              return (this.get('draggable'));
            };
            RichMarker.prototype['getDraggable'] = RichMarker.prototype.getDraggable;
            RichMarker.prototype.setDraggable = function(draggable) {
              this.set('draggable', !!draggable);
            };
            RichMarker.prototype['setDraggable'] = RichMarker.prototype.setDraggable;
            RichMarker.prototype.draggable_changed = function() {
              if (this.ready_) {
                if (this.getDraggable()) {
                  this.addDragging_(this.markerWrapper_);
                } else {
                  this.removeDragListeners_();
                }
              }
            };
            RichMarker.prototype['draggable_changed'] = RichMarker.prototype.draggable_changed;
            RichMarker.prototype.getPosition = function() {
              return (this.get('position'));
            };
            RichMarker.prototype['getPosition'] = RichMarker.prototype.getPosition;
            RichMarker.prototype.setPosition = function(position) {
              this.set('position', position);
            };
            RichMarker.prototype['setPosition'] = RichMarker.prototype.setPosition;
            RichMarker.prototype.position_changed = function() {
              this.draw();
            };
            RichMarker.prototype['position_changed'] = RichMarker.prototype.position_changed;
            RichMarker.prototype.getAnchor = function() {
              return (this.get('anchor'));
            };
            RichMarker.prototype['getAnchor'] = RichMarker.prototype.getAnchor;
            RichMarker.prototype.setAnchor = function(anchor) {
              this.set('anchor', anchor);
            };
            RichMarker.prototype['setAnchor'] = RichMarker.prototype.setAnchor;
            RichMarker.prototype.anchor_changed = function() {
              this.draw();
            };
            RichMarker.prototype['anchor_changed'] = RichMarker.prototype.anchor_changed;
            RichMarker.prototype.htmlToDocumentFragment_ = function(htmlString) {
              var tempDiv = document.createElement('DIV');
              tempDiv.innerHTML = htmlString;
              if (tempDiv.childNodes.length == 1) {
                return (tempDiv.removeChild(tempDiv.firstChild));
              } else {
                var fragment = document.createDocumentFragment();
                while (tempDiv.firstChild) {
                  fragment.appendChild(tempDiv.firstChild);
                }
                return fragment;
              }
            };
            RichMarker.prototype.removeChildren_ = function(node) {
              if (!node) {
                return;
              }
              var child;
              while (child = node.firstChild) {
                node.removeChild(child);
              }
            };
            RichMarker.prototype.setContent = function(content) {
              this.set('content', content);
            };
            RichMarker.prototype['setContent'] = RichMarker.prototype.setContent;
            RichMarker.prototype.getContent = function() {
              return (this.get('content'));
            };
            RichMarker.prototype['getContent'] = RichMarker.prototype.getContent;
            RichMarker.prototype.content_changed = function() {
              if (!this.markerContent_) {
                return;
              }
              this.removeChildren_(this.markerContent_);
              var content = this.getContent();
              if (content) {
                if (typeof content == 'string') {
                  content = content.replace(/^\s*([\S\s]*)\b\s*$/, '$1');
                  content = this.htmlToDocumentFragment_(content);
                }
                this.markerContent_.appendChild(content);
                var that = this;
                var images = this.markerContent_.getElementsByTagName('IMG');
                for (var i = 0,
                    image; image = images[i]; i++) {
                  google.maps.event.addDomListener(image, 'mousedown', function(e) {
                    if (that.getDraggable()) {
                      if (e.preventDefault) {
                        e.preventDefault();
                      }
                      e.returnValue = false;
                    }
                  });
                  google.maps.event.addDomListener(image, 'load', function() {
                    that.draw();
                  });
                }
                google.maps.event.trigger(this, 'domready');
              }
              if (this.ready_) {
                this.draw();
              }
            };
            RichMarker.prototype['content_changed'] = RichMarker.prototype.content_changed;
            RichMarker.prototype.setCursor_ = function(whichCursor) {
              if (!this.ready_) {
                return;
              }
              var cursor = '';
              if (navigator.userAgent.indexOf('Gecko/') !== -1) {
                if (whichCursor == 'dragging') {
                  cursor = '-moz-grabbing';
                }
                if (whichCursor == 'dragready') {
                  cursor = '-moz-grab';
                }
                if (whichCursor == 'draggable') {
                  cursor = 'pointer';
                }
              } else {
                if (whichCursor == 'dragging' || whichCursor == 'dragready') {
                  cursor = 'move';
                }
                if (whichCursor == 'draggable') {
                  cursor = 'pointer';
                }
              }
              if (this.markerWrapper_.style.cursor != cursor) {
                this.markerWrapper_.style.cursor = cursor;
              }
            };
            RichMarker.prototype.startDrag = function(e) {
              if (!this.getDraggable()) {
                return;
              }
              if (!this.dragging_) {
                this.dragging_ = true;
                var map = this.getMap();
                this.mapDraggable_ = map.get('draggable');
                map.set('draggable', false);
                this.mouseX_ = e.clientX;
                this.mouseY_ = e.clientY;
                this.setCursor_('dragready');
                this.markerWrapper_.style['MozUserSelect'] = 'none';
                this.markerWrapper_.style['KhtmlUserSelect'] = 'none';
                this.markerWrapper_.style['WebkitUserSelect'] = 'none';
                this.markerWrapper_['unselectable'] = 'on';
                this.markerWrapper_['onselectstart'] = function() {
                  return false;
                };
                this.addDraggingListeners_();
                google.maps.event.trigger(this, 'dragstart');
              }
            };
            RichMarker.prototype.stopDrag = function() {
              if (!this.getDraggable()) {
                return;
              }
              if (this.dragging_) {
                this.dragging_ = false;
                this.getMap().set('draggable', this.mapDraggable_);
                this.mouseX_ = this.mouseY_ = this.mapDraggable_ = null;
                this.markerWrapper_.style['MozUserSelect'] = '';
                this.markerWrapper_.style['KhtmlUserSelect'] = '';
                this.markerWrapper_.style['WebkitUserSelect'] = '';
                this.markerWrapper_['unselectable'] = 'off';
                this.markerWrapper_['onselectstart'] = function() {};
                this.removeDraggingListeners_();
                this.setCursor_('draggable');
                google.maps.event.trigger(this, 'dragend');
                this.draw();
              }
            };
            RichMarker.prototype.drag = function(e) {
              if (!this.getDraggable() || !this.dragging_) {
                this.stopDrag();
                return;
              }
              var dx = this.mouseX_ - e.clientX;
              var dy = this.mouseY_ - e.clientY;
              this.mouseX_ = e.clientX;
              this.mouseY_ = e.clientY;
              var left = parseInt(this.markerWrapper_.style['left'], 10) - dx;
              var top = parseInt(this.markerWrapper_.style['top'], 10) - dy;
              this.markerWrapper_.style['left'] = left + 'px';
              this.markerWrapper_.style['top'] = top + 'px';
              var offset = this.getOffset_();
              var point = new google.maps.Point(left - offset.width, top - offset.height);
              var projection = this.getProjection();
              this.setPosition(projection.fromDivPixelToLatLng(point));
              this.setCursor_('dragging');
              google.maps.event.trigger(this, 'drag');
            };
            RichMarker.prototype.removeDragListeners_ = function() {
              if (this.draggableListener_) {
                google.maps.event.removeListener(this.draggableListener_);
                delete this.draggableListener_;
              }
              this.setCursor_('');
            };
            RichMarker.prototype.addDragging_ = function(node) {
              if (!node) {
                return;
              }
              var that = this;
              this.draggableListener_ = google.maps.event.addDomListener(node, 'mousedown', function(e) {
                that.startDrag(e);
              });
              this.setCursor_('draggable');
            };
            RichMarker.prototype.addDraggingListeners_ = function() {
              var that = this;
              if (this.markerWrapper_.setCapture) {
                this.markerWrapper_.setCapture(true);
                this.draggingListeners_ = [google.maps.event.addDomListener(this.markerWrapper_, 'mousemove', function(e) {
                  that.drag(e);
                }, true), google.maps.event.addDomListener(this.markerWrapper_, 'mouseup', function() {
                  that.stopDrag();
                  that.markerWrapper_.releaseCapture();
                }, true)];
              } else {
                this.draggingListeners_ = [google.maps.event.addDomListener(window, 'mousemove', function(e) {
                  that.drag(e);
                }, true), google.maps.event.addDomListener(window, 'mouseup', function() {
                  that.stopDrag();
                }, true)];
              }
            };
            RichMarker.prototype.removeDraggingListeners_ = function() {
              if (this.draggingListeners_) {
                for (var i = 0,
                    listener; listener = this.draggingListeners_[i]; i++) {
                  google.maps.event.removeListener(listener);
                }
                this.draggingListeners_.length = 0;
              }
            };
            RichMarker.prototype.getOffset_ = function() {
              var anchor = this.getAnchor();
              if (typeof anchor == 'object') {
                return (anchor);
              }
              var offset = new google.maps.Size(0, 0);
              if (!this.markerContent_) {
                return offset;
              }
              var width = this.markerContent_.offsetWidth;
              var height = this.markerContent_.offsetHeight;
              switch (anchor) {
                case RichMarkerPosition['TOP_LEFT']:
                  break;
                case RichMarkerPosition['TOP']:
                  offset.width = -width / 2;
                  break;
                case RichMarkerPosition['TOP_RIGHT']:
                  offset.width = -width;
                  break;
                case RichMarkerPosition['LEFT']:
                  offset.height = -height / 2;
                  break;
                case RichMarkerPosition['MIDDLE']:
                  offset.width = -width / 2;
                  offset.height = -height / 2;
                  break;
                case RichMarkerPosition['RIGHT']:
                  offset.width = -width;
                  offset.height = -height / 2;
                  break;
                case RichMarkerPosition['BOTTOM_LEFT']:
                  offset.height = -height;
                  break;
                case RichMarkerPosition['BOTTOM']:
                  offset.width = -width / 2;
                  offset.height = -height;
                  break;
                case RichMarkerPosition['BOTTOM_RIGHT']:
                  offset.width = -width;
                  offset.height = -height;
                  break;
              }
              return offset;
            };
            RichMarker.prototype.onAdd = function() {
              if (!this.markerWrapper_) {
                this.markerWrapper_ = document.createElement('DIV');
                this.markerWrapper_.style['position'] = 'absolute';
              }
              if (this.getZIndex()) {
                this.markerWrapper_.style['zIndex'] = this.getZIndex();
              }
              this.markerWrapper_.style['display'] = this.getVisible() ? '' : 'none';
              if (!this.markerContent_) {
                this.markerContent_ = document.createElement('DIV');
                this.markerWrapper_.appendChild(this.markerContent_);
                var that = this;
                google.maps.event.addDomListener(this.markerContent_, 'click', function(e) {
                  google.maps.event.trigger(that, 'click');
                });
                google.maps.event.addDomListener(this.markerContent_, 'mouseover', function(e) {
                  google.maps.event.trigger(that, 'mouseover');
                });
                google.maps.event.addDomListener(this.markerContent_, 'mouseout', function(e) {
                  google.maps.event.trigger(that, 'mouseout');
                });
              }
              this.ready_ = true;
              this.content_changed();
              this.flat_changed();
              this.draggable_changed();
              var panes = this.getPanes();
              if (panes) {
                panes.overlayMouseTarget.appendChild(this.markerWrapper_);
              }
              google.maps.event.trigger(this, 'ready');
            };
            RichMarker.prototype['onAdd'] = RichMarker.prototype.onAdd;
            RichMarker.prototype.draw = function() {
              if (!this.ready_ || this.dragging_) {
                return;
              }
              var projection = this.getProjection();
              if (!projection) {
                return;
              }
              var latLng = (this.get('position'));
              var pos = projection.fromLatLngToDivPixel(latLng);
              var offset = this.getOffset_();
              this.markerWrapper_.style['top'] = (pos.y + offset.height) + 'px';
              this.markerWrapper_.style['left'] = (pos.x + offset.width) + 'px';
              var height = this.markerContent_.offsetHeight;
              var width = this.markerContent_.offsetWidth;
              if (width != this.get('width')) {
                this.set('width', width);
              }
              if (height != this.get('height')) {
                this.set('height', height);
              }
            };
            RichMarker.prototype['draw'] = RichMarker.prototype.draw;
            RichMarker.prototype.onRemove = function() {
              if (this.markerWrapper_ && this.markerWrapper_.parentNode) {
                this.markerWrapper_.parentNode.removeChild(this.markerWrapper_);
              }
              this.removeDragListeners_();
            };
            RichMarker.prototype['onRemove'] = RichMarker.prototype.onRemove;
            var RichMarkerPosition = {
              'TOP_LEFT': 1,
              'TOP': 2,
              'TOP_RIGHT': 3,
              'LEFT': 4,
              'MIDDLE': 5,
              'RIGHT': 6,
              'BOTTOM_LEFT': 7,
              'BOTTOM': 8,
              'BOTTOM_RIGHT': 9
            };
            window['RichMarkerPosition'] = RichMarkerPosition;
            window.InfoBox = InfoBox;
            window.Cluster = Cluster;
            window.ClusterIcon = ClusterIcon;
            window.MarkerClusterer = MarkerClusterer;
            window.MarkerLabel_ = MarkerLabel_;
            window.MarkerWithLabel = MarkerWithLabel;
            window.RichMarker = RichMarker;
          }();
        })};
    });
    ;
    (function(modules) {
      var installedModules = {};
      function __webpack_require__(moduleId) {
        if (installedModules[moduleId])
          return installedModules[moduleId].exports;
        var module = installedModules[moduleId] = {
          exports: {},
          id: moduleId,
          loaded: false
        };
        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        module.loaded = true;
        return module.exports;
      }
      __webpack_require__.m = modules;
      __webpack_require__.c = installedModules;
      __webpack_require__.p = "";
      return __webpack_require__(0);
    })([function(module, exports, __webpack_require__) {
      angular.module('uiGmapgoogle-maps.wrapped').service('uiGmapDataStructures', function() {
        return {
          Graph: __webpack_require__(1).Graph,
          Queue: __webpack_require__(1).Queue
        };
      });
    }, function(module, exports, __webpack_require__) {
      (function() {
        module.exports = {
          Graph: __webpack_require__(2),
          Heap: __webpack_require__(3),
          LinkedList: __webpack_require__(4),
          Map: __webpack_require__(5),
          Queue: __webpack_require__(6),
          RedBlackTree: __webpack_require__(7),
          Trie: __webpack_require__(8)
        };
      }).call(this);
    }, function(module, exports) {
      (function() {
        var Graph,
            __hasProp = {}.hasOwnProperty;
        Graph = (function() {
          function Graph() {
            this._nodes = {};
            this.nodeSize = 0;
            this.edgeSize = 0;
          }
          Graph.prototype.addNode = function(id) {
            if (!this._nodes[id]) {
              this.nodeSize++;
              return this._nodes[id] = {
                _outEdges: {},
                _inEdges: {}
              };
            }
          };
          Graph.prototype.getNode = function(id) {
            return this._nodes[id];
          };
          Graph.prototype.removeNode = function(id) {
            var inEdgeId,
                nodeToRemove,
                outEdgeId,
                _ref,
                _ref1;
            nodeToRemove = this._nodes[id];
            if (!nodeToRemove) {
              return;
            } else {
              _ref = nodeToRemove._outEdges;
              for (outEdgeId in _ref) {
                if (!__hasProp.call(_ref, outEdgeId))
                  continue;
                this.removeEdge(id, outEdgeId);
              }
              _ref1 = nodeToRemove._inEdges;
              for (inEdgeId in _ref1) {
                if (!__hasProp.call(_ref1, inEdgeId))
                  continue;
                this.removeEdge(inEdgeId, id);
              }
              this.nodeSize--;
              delete this._nodes[id];
            }
            return nodeToRemove;
          };
          Graph.prototype.addEdge = function(fromId, toId, weight) {
            var edgeToAdd,
                fromNode,
                toNode;
            if (weight == null) {
              weight = 1;
            }
            if (this.getEdge(fromId, toId)) {
              return;
            }
            fromNode = this._nodes[fromId];
            toNode = this._nodes[toId];
            if (!fromNode || !toNode) {
              return;
            }
            edgeToAdd = {weight: weight};
            fromNode._outEdges[toId] = edgeToAdd;
            toNode._inEdges[fromId] = edgeToAdd;
            this.edgeSize++;
            return edgeToAdd;
          };
          Graph.prototype.getEdge = function(fromId, toId) {
            var fromNode,
                toNode;
            fromNode = this._nodes[fromId];
            toNode = this._nodes[toId];
            if (!fromNode || !toNode) {} else {
              return fromNode._outEdges[toId];
            }
          };
          Graph.prototype.removeEdge = function(fromId, toId) {
            var edgeToDelete,
                fromNode,
                toNode;
            fromNode = this._nodes[fromId];
            toNode = this._nodes[toId];
            edgeToDelete = this.getEdge(fromId, toId);
            if (!edgeToDelete) {
              return;
            }
            delete fromNode._outEdges[toId];
            delete toNode._inEdges[fromId];
            this.edgeSize--;
            return edgeToDelete;
          };
          Graph.prototype.getInEdgesOf = function(nodeId) {
            var fromId,
                inEdges,
                toNode,
                _ref;
            toNode = this._nodes[nodeId];
            inEdges = [];
            _ref = toNode != null ? toNode._inEdges : void 0;
            for (fromId in _ref) {
              if (!__hasProp.call(_ref, fromId))
                continue;
              inEdges.push(this.getEdge(fromId, nodeId));
            }
            return inEdges;
          };
          Graph.prototype.getOutEdgesOf = function(nodeId) {
            var fromNode,
                outEdges,
                toId,
                _ref;
            fromNode = this._nodes[nodeId];
            outEdges = [];
            _ref = fromNode != null ? fromNode._outEdges : void 0;
            for (toId in _ref) {
              if (!__hasProp.call(_ref, toId))
                continue;
              outEdges.push(this.getEdge(nodeId, toId));
            }
            return outEdges;
          };
          Graph.prototype.getAllEdgesOf = function(nodeId) {
            var i,
                inEdges,
                outEdges,
                selfEdge,
                _i,
                _ref,
                _ref1;
            inEdges = this.getInEdgesOf(nodeId);
            outEdges = this.getOutEdgesOf(nodeId);
            if (inEdges.length === 0) {
              return outEdges;
            }
            selfEdge = this.getEdge(nodeId, nodeId);
            for (i = _i = 0, _ref = inEdges.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
              if (inEdges[i] === selfEdge) {
                _ref1 = [inEdges[inEdges.length - 1], inEdges[i]], inEdges[i] = _ref1[0], inEdges[inEdges.length - 1] = _ref1[1];
                inEdges.pop();
                break;
              }
            }
            return inEdges.concat(outEdges);
          };
          Graph.prototype.forEachNode = function(operation) {
            var nodeId,
                nodeObject,
                _ref;
            _ref = this._nodes;
            for (nodeId in _ref) {
              if (!__hasProp.call(_ref, nodeId))
                continue;
              nodeObject = _ref[nodeId];
              operation(nodeObject, nodeId);
            }
          };
          Graph.prototype.forEachEdge = function(operation) {
            var edgeObject,
                nodeId,
                nodeObject,
                toId,
                _ref,
                _ref1;
            _ref = this._nodes;
            for (nodeId in _ref) {
              if (!__hasProp.call(_ref, nodeId))
                continue;
              nodeObject = _ref[nodeId];
              _ref1 = nodeObject._outEdges;
              for (toId in _ref1) {
                if (!__hasProp.call(_ref1, toId))
                  continue;
                edgeObject = _ref1[toId];
                operation(edgeObject);
              }
            }
          };
          return Graph;
        })();
        module.exports = Graph;
      }).call(this);
    }, function(module, exports) {
      (function() {
        var Heap,
            _leftChild,
            _parent,
            _rightChild;
        Heap = (function() {
          function Heap(dataToHeapify) {
            var i,
                item,
                _i,
                _j,
                _len,
                _ref;
            if (dataToHeapify == null) {
              dataToHeapify = [];
            }
            this._data = [void 0];
            for (_i = 0, _len = dataToHeapify.length; _i < _len; _i++) {
              item = dataToHeapify[_i];
              if (item != null) {
                this._data.push(item);
              }
            }
            if (this._data.length > 1) {
              for (i = _j = 2, _ref = this._data.length; 2 <= _ref ? _j < _ref : _j > _ref; i = 2 <= _ref ? ++_j : --_j) {
                this._upHeap(i);
              }
            }
            this.size = this._data.length - 1;
          }
          Heap.prototype.add = function(value) {
            if (value == null) {
              return;
            }
            this._data.push(value);
            this._upHeap(this._data.length - 1);
            this.size++;
            return value;
          };
          Heap.prototype.removeMin = function() {
            var min;
            if (this._data.length === 1) {
              return;
            }
            this.size--;
            if (this._data.length === 2) {
              return this._data.pop();
            }
            min = this._data[1];
            this._data[1] = this._data.pop();
            this._downHeap();
            return min;
          };
          Heap.prototype.peekMin = function() {
            return this._data[1];
          };
          Heap.prototype._upHeap = function(index) {
            var valueHolder,
                _ref;
            valueHolder = this._data[index];
            while (this._data[index] < this._data[_parent(index)] && index > 1) {
              _ref = [this._data[_parent(index)], this._data[index]], this._data[index] = _ref[0], this._data[_parent(index)] = _ref[1];
              index = _parent(index);
            }
          };
          Heap.prototype._downHeap = function() {
            var currentIndex,
                smallerChildIndex,
                _ref;
            currentIndex = 1;
            while (_leftChild(currentIndex < this._data.length)) {
              smallerChildIndex = _leftChild(currentIndex);
              if (smallerChildIndex < this._data.length - 1) {
                if (this._data[_rightChild(currentIndex)] < this._data[smallerChildIndex]) {
                  smallerChildIndex = _rightChild(currentIndex);
                }
              }
              if (this._data[smallerChildIndex] < this._data[currentIndex]) {
                _ref = [this._data[currentIndex], this._data[smallerChildIndex]], this._data[smallerChildIndex] = _ref[0], this._data[currentIndex] = _ref[1];
                currentIndex = smallerChildIndex;
              } else {
                break;
              }
            }
          };
          return Heap;
        })();
        _parent = function(index) {
          return index >> 1;
        };
        _leftChild = function(index) {
          return index << 1;
        };
        _rightChild = function(index) {
          return (index << 1) + 1;
        };
        module.exports = Heap;
      }).call(this);
    }, function(module, exports) {
      (function() {
        var LinkedList;
        LinkedList = (function() {
          function LinkedList(valuesToAdd) {
            var value,
                _i,
                _len;
            if (valuesToAdd == null) {
              valuesToAdd = [];
            }
            this.head = {
              prev: void 0,
              value: void 0,
              next: void 0
            };
            this.tail = {
              prev: void 0,
              value: void 0,
              next: void 0
            };
            this.size = 0;
            for (_i = 0, _len = valuesToAdd.length; _i < _len; _i++) {
              value = valuesToAdd[_i];
              this.add(value);
            }
          }
          LinkedList.prototype.at = function(position) {
            var currentNode,
                i,
                _i,
                _j,
                _ref;
            if (!((-this.size <= position && position < this.size))) {
              return;
            }
            position = this._adjust(position);
            if (position * 2 < this.size) {
              currentNode = this.head;
              for (i = _i = 1; _i <= position; i = _i += 1) {
                currentNode = currentNode.next;
              }
            } else {
              currentNode = this.tail;
              for (i = _j = 1, _ref = this.size - position - 1; _j <= _ref; i = _j += 1) {
                currentNode = currentNode.prev;
              }
            }
            return currentNode;
          };
          LinkedList.prototype.add = function(value, position) {
            var currentNode,
                nodeToAdd,
                _ref,
                _ref1,
                _ref2;
            if (position == null) {
              position = this.size;
            }
            if (!((-this.size <= position && position <= this.size))) {
              return;
            }
            nodeToAdd = {value: value};
            position = this._adjust(position);
            if (this.size === 0) {
              this.head = nodeToAdd;
            } else {
              if (position === 0) {
                _ref = [nodeToAdd, this.head, nodeToAdd], this.head.prev = _ref[0], nodeToAdd.next = _ref[1], this.head = _ref[2];
              } else {
                currentNode = this.at(position - 1);
                _ref1 = [currentNode.next, nodeToAdd, nodeToAdd, currentNode], nodeToAdd.next = _ref1[0], (_ref2 = currentNode.next) != null ? _ref2.prev = _ref1[1] : void 0, currentNode.next = _ref1[2], nodeToAdd.prev = _ref1[3];
              }
            }
            if (position === this.size) {
              this.tail = nodeToAdd;
            }
            this.size++;
            return value;
          };
          LinkedList.prototype.removeAt = function(position) {
            var currentNode,
                valueToReturn,
                _ref;
            if (position == null) {
              position = this.size - 1;
            }
            if (!((-this.size <= position && position < this.size))) {
              return;
            }
            if (this.size === 0) {
              return;
            }
            position = this._adjust(position);
            if (this.size === 1) {
              valueToReturn = this.head.value;
              this.head.value = this.tail.value = void 0;
            } else {
              if (position === 0) {
                valueToReturn = this.head.value;
                this.head = this.head.next;
                this.head.prev = void 0;
              } else {
                currentNode = this.at(position);
                valueToReturn = currentNode.value;
                currentNode.prev.next = currentNode.next;
                if ((_ref = currentNode.next) != null) {
                  _ref.prev = currentNode.prev;
                }
                if (position === this.size - 1) {
                  this.tail = currentNode.prev;
                }
              }
            }
            this.size--;
            return valueToReturn;
          };
          LinkedList.prototype.remove = function(value) {
            var currentNode;
            if (value == null) {
              return;
            }
            currentNode = this.head;
            while (currentNode && currentNode.value !== value) {
              currentNode = currentNode.next;
            }
            if (!currentNode) {
              return;
            }
            if (this.size === 1) {
              this.head.value = this.tail.value = void 0;
            } else if (currentNode === this.head) {
              this.head = this.head.next;
              this.head.prev = void 0;
            } else if (currentNode === this.tail) {
              this.tail = this.tail.prev;
              this.tail.next = void 0;
            } else {
              currentNode.prev.next = currentNode.next;
              currentNode.next.prev = currentNode.prev;
            }
            this.size--;
            return value;
          };
          LinkedList.prototype.indexOf = function(value, startingPosition) {
            var currentNode,
                position;
            if (startingPosition == null) {
              startingPosition = 0;
            }
            if (((this.head.value == null) && !this.head.next) || startingPosition >= this.size) {
              return -1;
            }
            startingPosition = Math.max(0, this._adjust(startingPosition));
            currentNode = this.at(startingPosition);
            position = startingPosition;
            while (currentNode) {
              if (currentNode.value === value) {
                break;
              }
              currentNode = currentNode.next;
              position++;
            }
            if (position === this.size) {
              return -1;
            } else {
              return position;
            }
          };
          LinkedList.prototype._adjust = function(position) {
            if (position < 0) {
              return this.size + position;
            } else {
              return position;
            }
          };
          return LinkedList;
        })();
        module.exports = LinkedList;
      }).call(this);
    }, function(module, exports) {
      (function() {
        var Map,
            SPECIAL_TYPE_KEY_PREFIX,
            _extractDataType,
            _isSpecialType,
            __hasProp = {}.hasOwnProperty;
        SPECIAL_TYPE_KEY_PREFIX = '_mapId_';
        Map = (function() {
          Map._mapIdTracker = 0;
          Map._newMapId = function() {
            return this._mapIdTracker++;
          };
          function Map(objectToMap) {
            var key,
                value;
            this._content = {};
            this._itemId = 0;
            this._id = Map._newMapId();
            this.size = 0;
            for (key in objectToMap) {
              if (!__hasProp.call(objectToMap, key))
                continue;
              value = objectToMap[key];
              this.set(key, value);
            }
          }
          Map.prototype.hash = function(key, makeHash) {
            var propertyForMap,
                type;
            if (makeHash == null) {
              makeHash = false;
            }
            type = _extractDataType(key);
            if (_isSpecialType(key)) {
              propertyForMap = SPECIAL_TYPE_KEY_PREFIX + this._id;
              if (makeHash && !key[propertyForMap]) {
                key[propertyForMap] = this._itemId++;
              }
              return propertyForMap + '_' + key[propertyForMap];
            } else {
              return type + '_' + key;
            }
          };
          Map.prototype.set = function(key, value) {
            if (!this.has(key)) {
              this.size++;
            }
            this._content[this.hash(key, true)] = [value, key];
            return value;
          };
          Map.prototype.get = function(key) {
            var _ref;
            return (_ref = this._content[this.hash(key)]) != null ? _ref[0] : void 0;
          };
          Map.prototype.has = function(key) {
            return this.hash(key) in this._content;
          };
          Map.prototype["delete"] = function(key) {
            var hashedKey;
            hashedKey = this.hash(key);
            if (hashedKey in this._content) {
              delete this._content[hashedKey];
              if (_isSpecialType(key)) {
                delete key[SPECIAL_TYPE_KEY_PREFIX + this._id];
              }
              this.size--;
              return true;
            }
            return false;
          };
          Map.prototype.forEach = function(operation) {
            var key,
                value,
                _ref;
            _ref = this._content;
            for (key in _ref) {
              if (!__hasProp.call(_ref, key))
                continue;
              value = _ref[key];
              operation(value[1], value[0]);
            }
          };
          return Map;
        })();
        _isSpecialType = function(key) {
          var simpleHashableTypes,
              simpleType,
              type,
              _i,
              _len;
          simpleHashableTypes = ['Boolean', 'Number', 'String', 'Undefined', 'Null', 'RegExp', 'Function'];
          type = _extractDataType(key);
          for (_i = 0, _len = simpleHashableTypes.length; _i < _len; _i++) {
            simpleType = simpleHashableTypes[_i];
            if (type === simpleType) {
              return false;
            }
          }
          return true;
        };
        _extractDataType = function(type) {
          return Object.prototype.toString.apply(type).match(/\[object (.+)\]/)[1];
        };
        module.exports = Map;
      }).call(this);
    }, function(module, exports) {
      (function() {
        var Queue;
        Queue = (function() {
          function Queue(initialArray) {
            if (initialArray == null) {
              initialArray = [];
            }
            this._content = initialArray;
            this._dequeueIndex = 0;
            this.size = this._content.length;
          }
          Queue.prototype.enqueue = function(item) {
            this.size++;
            this._content.push(item);
            return item;
          };
          Queue.prototype.dequeue = function() {
            var itemToDequeue;
            if (this.size === 0) {
              return;
            }
            this.size--;
            itemToDequeue = this._content[this._dequeueIndex];
            this._dequeueIndex++;
            if (this._dequeueIndex * 2 > this._content.length) {
              this._content = this._content.slice(this._dequeueIndex);
              this._dequeueIndex = 0;
            }
            return itemToDequeue;
          };
          Queue.prototype.peek = function() {
            return this._content[this._dequeueIndex];
          };
          return Queue;
        })();
        module.exports = Queue;
      }).call(this);
    }, function(module, exports) {
      (function() {
        var BLACK,
            NODE_FOUND,
            NODE_TOO_BIG,
            NODE_TOO_SMALL,
            RED,
            RedBlackTree,
            STOP_SEARCHING,
            _findNode,
            _grandParentOf,
            _isLeft,
            _leftOrRight,
            _peekMaxNode,
            _peekMinNode,
            _siblingOf,
            _uncleOf;
        NODE_FOUND = 0;
        NODE_TOO_BIG = 1;
        NODE_TOO_SMALL = 2;
        STOP_SEARCHING = 3;
        RED = 1;
        BLACK = 2;
        RedBlackTree = (function() {
          function RedBlackTree(valuesToAdd) {
            var value,
                _i,
                _len;
            if (valuesToAdd == null) {
              valuesToAdd = [];
            }
            this._root;
            this.size = 0;
            for (_i = 0, _len = valuesToAdd.length; _i < _len; _i++) {
              value = valuesToAdd[_i];
              if (value != null) {
                this.add(value);
              }
            }
          }
          RedBlackTree.prototype.add = function(value) {
            var currentNode,
                foundNode,
                nodeToInsert,
                _ref;
            if (value == null) {
              return;
            }
            this.size++;
            nodeToInsert = {
              value: value,
              _color: RED
            };
            if (!this._root) {
              this._root = nodeToInsert;
            } else {
              foundNode = _findNode(this._root, function(node) {
                if (value === node.value) {
                  return NODE_FOUND;
                } else {
                  if (value < node.value) {
                    if (node._left) {
                      return NODE_TOO_BIG;
                    } else {
                      nodeToInsert._parent = node;
                      node._left = nodeToInsert;
                      return STOP_SEARCHING;
                    }
                  } else {
                    if (node._right) {
                      return NODE_TOO_SMALL;
                    } else {
                      nodeToInsert._parent = node;
                      node._right = nodeToInsert;
                      return STOP_SEARCHING;
                    }
                  }
                }
              });
              if (foundNode != null) {
                return;
              }
            }
            currentNode = nodeToInsert;
            while (true) {
              if (currentNode === this._root) {
                currentNode._color = BLACK;
                break;
              }
              if (currentNode._parent._color === BLACK) {
                break;
              }
              if (((_ref = _uncleOf(currentNode)) != null ? _ref._color : void 0) === RED) {
                currentNode._parent._color = BLACK;
                _uncleOf(currentNode)._color = BLACK;
                _grandParentOf(currentNode)._color = RED;
                currentNode = _grandParentOf(currentNode);
                continue;
              }
              if (!_isLeft(currentNode) && _isLeft(currentNode._parent)) {
                this._rotateLeft(currentNode._parent);
                currentNode = currentNode._left;
              } else if (_isLeft(currentNode) && !_isLeft(currentNode._parent)) {
                this._rotateRight(currentNode._parent);
                currentNode = currentNode._right;
              }
              currentNode._parent._color = BLACK;
              _grandParentOf(currentNode)._color = RED;
              if (_isLeft(currentNode)) {
                this._rotateRight(_grandParentOf(currentNode));
              } else {
                this._rotateLeft(_grandParentOf(currentNode));
              }
              break;
            }
            return value;
          };
          RedBlackTree.prototype.has = function(value) {
            var foundNode;
            foundNode = _findNode(this._root, function(node) {
              if (value === node.value) {
                return NODE_FOUND;
              } else if (value < node.value) {
                return NODE_TOO_BIG;
              } else {
                return NODE_TOO_SMALL;
              }
            });
            if (foundNode) {
              return true;
            } else {
              return false;
            }
          };
          RedBlackTree.prototype.peekMin = function() {
            var _ref;
            return (_ref = _peekMinNode(this._root)) != null ? _ref.value : void 0;
          };
          RedBlackTree.prototype.peekMax = function() {
            var _ref;
            return (_ref = _peekMaxNode(this._root)) != null ? _ref.value : void 0;
          };
          RedBlackTree.prototype.remove = function(value) {
            var foundNode;
            foundNode = _findNode(this._root, function(node) {
              if (value === node.value) {
                return NODE_FOUND;
              } else if (value < node.value) {
                return NODE_TOO_BIG;
              } else {
                return NODE_TOO_SMALL;
              }
            });
            if (!foundNode) {
              return;
            }
            this._removeNode(this._root, foundNode);
            this.size--;
            return value;
          };
          RedBlackTree.prototype.removeMin = function() {
            var nodeToRemove,
                valueToReturn;
            nodeToRemove = _peekMinNode(this._root);
            if (!nodeToRemove) {
              return;
            }
            valueToReturn = nodeToRemove.value;
            this._removeNode(this._root, nodeToRemove);
            return valueToReturn;
          };
          RedBlackTree.prototype.removeMax = function() {
            var nodeToRemove,
                valueToReturn;
            nodeToRemove = _peekMaxNode(this._root);
            if (!nodeToRemove) {
              return;
            }
            valueToReturn = nodeToRemove.value;
            this._removeNode(this._root, nodeToRemove);
            return valueToReturn;
          };
          RedBlackTree.prototype._removeNode = function(root, node) {
            var sibling,
                successor,
                _ref,
                _ref1,
                _ref2,
                _ref3,
                _ref4,
                _ref5,
                _ref6,
                _ref7;
            if (node._left && node._right) {
              successor = _peekMinNode(node._right);
              node.value = successor.value;
              node = successor;
            }
            successor = node._left || node._right;
            if (!successor) {
              successor = {
                color: BLACK,
                _right: void 0,
                _left: void 0,
                isLeaf: true
              };
            }
            successor._parent = node._parent;
            if ((_ref = node._parent) != null) {
              _ref[_leftOrRight(node)] = successor;
            }
            if (node._color === BLACK) {
              if (successor._color === RED) {
                successor._color = BLACK;
                if (!successor._parent) {
                  this._root = successor;
                }
              } else {
                while (true) {
                  if (!successor._parent) {
                    if (!successor.isLeaf) {
                      this._root = successor;
                    } else {
                      this._root = void 0;
                    }
                    break;
                  }
                  sibling = _siblingOf(successor);
                  if ((sibling != null ? sibling._color : void 0) === RED) {
                    successor._parent._color = RED;
                    sibling._color = BLACK;
                    if (_isLeft(successor)) {
                      this._rotateLeft(successor._parent);
                    } else {
                      this._rotateRight(successor._parent);
                    }
                  }
                  sibling = _siblingOf(successor);
                  if (successor._parent._color === BLACK && (!sibling || (sibling._color === BLACK && (!sibling._left || sibling._left._color === BLACK) && (!sibling._right || sibling._right._color === BLACK)))) {
                    if (sibling != null) {
                      sibling._color = RED;
                    }
                    if (successor.isLeaf) {
                      successor._parent[_leftOrRight(successor)] = void 0;
                    }
                    successor = successor._parent;
                    continue;
                  }
                  if (successor._parent._color === RED && (!sibling || (sibling._color === BLACK && (!sibling._left || ((_ref1 = sibling._left) != null ? _ref1._color : void 0) === BLACK) && (!sibling._right || ((_ref2 = sibling._right) != null ? _ref2._color : void 0) === BLACK)))) {
                    if (sibling != null) {
                      sibling._color = RED;
                    }
                    successor._parent._color = BLACK;
                    break;
                  }
                  if ((sibling != null ? sibling._color : void 0) === BLACK) {
                    if (_isLeft(successor) && (!sibling._right || sibling._right._color === BLACK) && ((_ref3 = sibling._left) != null ? _ref3._color : void 0) === RED) {
                      sibling._color = RED;
                      if ((_ref4 = sibling._left) != null) {
                        _ref4._color = BLACK;
                      }
                      this._rotateRight(sibling);
                    } else if (!_isLeft(successor) && (!sibling._left || sibling._left._color === BLACK) && ((_ref5 = sibling._right) != null ? _ref5._color : void 0) === RED) {
                      sibling._color = RED;
                      if ((_ref6 = sibling._right) != null) {
                        _ref6._color = BLACK;
                      }
                      this._rotateLeft(sibling);
                    }
                    break;
                  }
                  sibling = _siblingOf(successor);
                  sibling._color = successor._parent._color;
                  if (_isLeft(successor)) {
                    sibling._right._color = BLACK;
                    this._rotateRight(successor._parent);
                  } else {
                    sibling._left._color = BLACK;
                    this._rotateLeft(successor._parent);
                  }
                }
              }
            }
            if (successor.isLeaf) {
              return (_ref7 = successor._parent) != null ? _ref7[_leftOrRight(successor)] = void 0 : void 0;
            }
          };
          RedBlackTree.prototype._rotateLeft = function(node) {
            var _ref,
                _ref1;
            if ((_ref = node._parent) != null) {
              _ref[_leftOrRight(node)] = node._right;
            }
            node._right._parent = node._parent;
            node._parent = node._right;
            node._right = node._right._left;
            node._parent._left = node;
            if ((_ref1 = node._right) != null) {
              _ref1._parent = node;
            }
            if (node._parent._parent == null) {
              return this._root = node._parent;
            }
          };
          RedBlackTree.prototype._rotateRight = function(node) {
            var _ref,
                _ref1;
            if ((_ref = node._parent) != null) {
              _ref[_leftOrRight(node)] = node._left;
            }
            node._left._parent = node._parent;
            node._parent = node._left;
            node._left = node._left._right;
            node._parent._right = node;
            if ((_ref1 = node._left) != null) {
              _ref1._parent = node;
            }
            if (node._parent._parent == null) {
              return this._root = node._parent;
            }
          };
          return RedBlackTree;
        })();
        _isLeft = function(node) {
          return node === node._parent._left;
        };
        _leftOrRight = function(node) {
          if (_isLeft(node)) {
            return '_left';
          } else {
            return '_right';
          }
        };
        _findNode = function(startingNode, comparator) {
          var comparisonResult,
              currentNode,
              foundNode;
          currentNode = startingNode;
          foundNode = void 0;
          while (currentNode) {
            comparisonResult = comparator(currentNode);
            if (comparisonResult === NODE_FOUND) {
              foundNode = currentNode;
              break;
            }
            if (comparisonResult === NODE_TOO_BIG) {
              currentNode = currentNode._left;
            } else if (comparisonResult === NODE_TOO_SMALL) {
              currentNode = currentNode._right;
            } else if (comparisonResult === STOP_SEARCHING) {
              break;
            }
          }
          return foundNode;
        };
        _peekMinNode = function(startingNode) {
          return _findNode(startingNode, function(node) {
            if (node._left) {
              return NODE_TOO_BIG;
            } else {
              return NODE_FOUND;
            }
          });
        };
        _peekMaxNode = function(startingNode) {
          return _findNode(startingNode, function(node) {
            if (node._right) {
              return NODE_TOO_SMALL;
            } else {
              return NODE_FOUND;
            }
          });
        };
        _grandParentOf = function(node) {
          var _ref;
          return (_ref = node._parent) != null ? _ref._parent : void 0;
        };
        _uncleOf = function(node) {
          if (!_grandParentOf(node)) {
            return;
          }
          if (_isLeft(node._parent)) {
            return _grandParentOf(node)._right;
          } else {
            return _grandParentOf(node)._left;
          }
        };
        _siblingOf = function(node) {
          if (_isLeft(node)) {
            return node._parent._right;
          } else {
            return node._parent._left;
          }
        };
        module.exports = RedBlackTree;
      }).call(this);
    }, function(module, exports, __webpack_require__) {
      (function() {
        var Queue,
            Trie,
            WORD_END,
            _hasAtLeastNChildren,
            __hasProp = {}.hasOwnProperty;
        Queue = __webpack_require__(6);
        WORD_END = 'end';
        Trie = (function() {
          function Trie(words) {
            var word,
                _i,
                _len;
            if (words == null) {
              words = [];
            }
            this._root = {};
            this.size = 0;
            for (_i = 0, _len = words.length; _i < _len; _i++) {
              word = words[_i];
              this.add(word);
            }
          }
          Trie.prototype.add = function(word) {
            var currentNode,
                letter,
                _i,
                _len;
            if (word == null) {
              return;
            }
            this.size++;
            currentNode = this._root;
            for (_i = 0, _len = word.length; _i < _len; _i++) {
              letter = word[_i];
              if (currentNode[letter] == null) {
                currentNode[letter] = {};
              }
              currentNode = currentNode[letter];
            }
            currentNode[WORD_END] = true;
            return word;
          };
          Trie.prototype.has = function(word) {
            var currentNode,
                letter,
                _i,
                _len;
            if (word == null) {
              return false;
            }
            currentNode = this._root;
            for (_i = 0, _len = word.length; _i < _len; _i++) {
              letter = word[_i];
              if (currentNode[letter] == null) {
                return false;
              }
              currentNode = currentNode[letter];
            }
            if (currentNode[WORD_END]) {
              return true;
            } else {
              return false;
            }
          };
          Trie.prototype.longestPrefixOf = function(word) {
            var currentNode,
                letter,
                prefix,
                _i,
                _len;
            if (word == null) {
              return '';
            }
            currentNode = this._root;
            prefix = '';
            for (_i = 0, _len = word.length; _i < _len; _i++) {
              letter = word[_i];
              if (currentNode[letter] == null) {
                break;
              }
              prefix += letter;
              currentNode = currentNode[letter];
            }
            return prefix;
          };
          Trie.prototype.wordsWithPrefix = function(prefix) {
            var accumulatedLetters,
                currentNode,
                letter,
                node,
                queue,
                subNode,
                words,
                _i,
                _len,
                _ref;
            if (prefix == null) {
              return [];
            }
            (prefix != null) || (prefix = '');
            words = [];
            currentNode = this._root;
            for (_i = 0, _len = prefix.length; _i < _len; _i++) {
              letter = prefix[_i];
              currentNode = currentNode[letter];
              if (currentNode == null) {
                return [];
              }
            }
            queue = new Queue();
            queue.enqueue([currentNode, '']);
            while (queue.size !== 0) {
              _ref = queue.dequeue(), node = _ref[0], accumulatedLetters = _ref[1];
              if (node[WORD_END]) {
                words.push(prefix + accumulatedLetters);
              }
              for (letter in node) {
                if (!__hasProp.call(node, letter))
                  continue;
                subNode = node[letter];
                queue.enqueue([subNode, accumulatedLetters + letter]);
              }
            }
            return words;
          };
          Trie.prototype.remove = function(word) {
            var currentNode,
                i,
                letter,
                prefix,
                _i,
                _j,
                _len,
                _ref;
            if (word == null) {
              return;
            }
            currentNode = this._root;
            prefix = [];
            for (_i = 0, _len = word.length; _i < _len; _i++) {
              letter = word[_i];
              if (currentNode[letter] == null) {
                return;
              }
              currentNode = currentNode[letter];
              prefix.push([letter, currentNode]);
            }
            if (!currentNode[WORD_END]) {
              return;
            }
            this.size--;
            delete currentNode[WORD_END];
            if (_hasAtLeastNChildren(currentNode, 1)) {
              return word;
            }
            for (i = _j = _ref = prefix.length - 1; _ref <= 1 ? _j <= 1 : _j >= 1; i = _ref <= 1 ? ++_j : --_j) {
              if (!_hasAtLeastNChildren(prefix[i][1], 1)) {
                delete prefix[i - 1][1][prefix[i][0]];
              } else {
                break;
              }
            }
            if (!_hasAtLeastNChildren(this._root[prefix[0][0]], 1)) {
              delete this._root[prefix[0][0]];
            }
            return word;
          };
          return Trie;
        })();
        _hasAtLeastNChildren = function(node, n) {
          var child,
              childCount;
          if (n === 0) {
            return true;
          }
          childCount = 0;
          for (child in node) {
            if (!__hasProp.call(node, child))
              continue;
            childCount++;
            if (childCount >= n) {
              return true;
            }
          }
          return false;
        };
        module.exports = Trie;
      }).call(this);
    }]);
    ;
    angular.module('uiGmapgoogle-maps.wrapped').service('uiGmapMarkerSpiderfier', ['uiGmapGoogleMapApi', function(GoogleMapApi) {
      var self = this;
      +function() {
        var hasProp = {}.hasOwnProperty,
            slice = [].slice;
        this['OverlappingMarkerSpiderfier'] = (function() {
          var ge,
              gm,
              j,
              lcH,
              lcU,
              len,
              mt,
              p,
              ref,
              twoPi,
              x;
          p = _Class.prototype;
          ref = [_Class, p];
          for (j = 0, len = ref.length; j < len; j++) {
            x = ref[j];
            x['VERSION'] = '0.3.3';
          }
          gm = void 0;
          ge = void 0;
          mt = void 0;
          twoPi = Math.PI * 2;
          p['keepSpiderfied'] = false;
          p['markersWontHide'] = false;
          p['markersWontMove'] = false;
          p['nearbyDistance'] = 20;
          p['circleSpiralSwitchover'] = 9;
          p['circleFootSeparation'] = 23;
          p['circleStartAngle'] = twoPi / 12;
          p['spiralFootSeparation'] = 26;
          p['spiralLengthStart'] = 11;
          p['spiralLengthFactor'] = 4;
          p['spiderfiedZIndex'] = 1000;
          p['usualLegZIndex'] = 10;
          p['highlightedLegZIndex'] = 20;
          p['event'] = 'click';
          p['minZoomLevel'] = false;
          p['legWeight'] = 1.5;
          p['legColors'] = {
            'usual': {},
            'highlighted': {}
          };
          lcU = p['legColors']['usual'];
          lcH = p['legColors']['highlighted'];
          _Class['initializeGoogleMaps'] = function(google) {
            gm = google.maps;
            ge = gm.event;
            mt = gm.MapTypeId;
            lcU[mt.HYBRID] = lcU[mt.SATELLITE] = '#fff';
            lcH[mt.HYBRID] = lcH[mt.SATELLITE] = '#f00';
            lcU[mt.TERRAIN] = lcU[mt.ROADMAP] = '#444';
            lcH[mt.TERRAIN] = lcH[mt.ROADMAP] = '#f00';
            this.ProjHelper = function(map) {
              return this.setMap(map);
            };
            this.ProjHelper.prototype = new gm.OverlayView();
            return this.ProjHelper.prototype['draw'] = function() {};
          };
          function _Class(map1, opts) {
            var e,
                k,
                l,
                len1,
                ref1,
                v;
            this.map = map1;
            if (opts == null) {
              opts = {};
            }
            for (k in opts) {
              if (!hasProp.call(opts, k))
                continue;
              v = opts[k];
              this[k] = v;
            }
            this.projHelper = new this.constructor.ProjHelper(this.map);
            this.initMarkerArrays();
            this.listeners = {};
            ref1 = ['click', 'zoom_changed', 'maptypeid_changed'];
            for (l = 0, len1 = ref1.length; l < len1; l++) {
              e = ref1[l];
              ge.addListener(this.map, e, (function(_this) {
                return function() {
                  return _this['unspiderfy']();
                };
              })(this));
            }
          }
          p.initMarkerArrays = function() {
            this.markers = [];
            return this.markerListenerRefs = [];
          };
          p['addMarker'] = function(marker) {
            var listenerRefs;
            if (marker['_oms'] != null) {
              return this;
            }
            marker['_oms'] = true;
            listenerRefs = [ge.addListener(marker, this['event'], (function(_this) {
              return function(event) {
                return _this.spiderListener(marker, event);
              };
            })(this))];
            if (!this['markersWontHide']) {
              listenerRefs.push(ge.addListener(marker, 'visible_changed', (function(_this) {
                return function() {
                  return _this.markerChangeListener(marker, false);
                };
              })(this)));
            }
            if (!this['markersWontMove']) {
              listenerRefs.push(ge.addListener(marker, 'position_changed', (function(_this) {
                return function() {
                  return _this.markerChangeListener(marker, true);
                };
              })(this)));
            }
            this.markerListenerRefs.push(listenerRefs);
            this.markers.push(marker);
            return this;
          };
          p.markerChangeListener = function(marker, positionChanged) {
            if ((marker['_omsData'] != null) && (positionChanged || !marker.getVisible()) && !((this.spiderfying != null) || (this.unspiderfying != null))) {
              return this['unspiderfy'](positionChanged ? marker : null);
            }
          };
          p['getMarkers'] = function() {
            return this.markers.slice(0);
          };
          p['removeMarker'] = function(marker) {
            var i,
                l,
                len1,
                listenerRef,
                listenerRefs;
            if (marker['_omsData'] != null) {
              this['unspiderfy']();
            }
            i = this.arrIndexOf(this.markers, marker);
            if (i < 0) {
              return this;
            }
            listenerRefs = this.markerListenerRefs.splice(i, 1)[0];
            for (l = 0, len1 = listenerRefs.length; l < len1; l++) {
              listenerRef = listenerRefs[l];
              ge.removeListener(listenerRef);
            }
            delete marker['_oms'];
            this.markers.splice(i, 1);
            return this;
          };
          p['clearMarkers'] = function() {
            var i,
                l,
                len1,
                len2,
                listenerRef,
                listenerRefs,
                marker,
                n,
                ref1;
            this['unspiderfy']();
            ref1 = this.markers;
            for (i = l = 0, len1 = ref1.length; l < len1; i = ++l) {
              marker = ref1[i];
              listenerRefs = this.markerListenerRefs[i];
              for (n = 0, len2 = listenerRefs.length; n < len2; n++) {
                listenerRef = listenerRefs[n];
                ge.removeListener(listenerRef);
              }
              delete marker['_oms'];
            }
            this.initMarkerArrays();
            return this;
          };
          p['addListener'] = function(event, func) {
            var base;
            ((base = this.listeners)[event] != null ? base[event] : base[event] = []).push(func);
            return this;
          };
          p['removeListener'] = function(event, func) {
            var i;
            i = this.arrIndexOf(this.listeners[event], func);
            if (!(i < 0)) {
              this.listeners[event].splice(i, 1);
            }
            return this;
          };
          p['clearListeners'] = function(event) {
            this.listeners[event] = [];
            return this;
          };
          p.trigger = function() {
            var args,
                event,
                func,
                l,
                len1,
                ref1,
                ref2,
                results;
            event = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
            ref2 = (ref1 = this.listeners[event]) != null ? ref1 : [];
            results = [];
            for (l = 0, len1 = ref2.length; l < len1; l++) {
              func = ref2[l];
              results.push(func.apply(null, args));
            }
            return results;
          };
          p.generatePtsCircle = function(count, centerPt) {
            var angle,
                angleStep,
                circumference,
                i,
                l,
                legLength,
                ref1,
                results;
            circumference = this['circleFootSeparation'] * (2 + count);
            legLength = circumference / twoPi;
            angleStep = twoPi / count;
            results = [];
            for (i = l = 0, ref1 = count; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
              angle = this['circleStartAngle'] + i * angleStep;
              results.push(new gm.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle)));
            }
            return results;
          };
          p.generatePtsSpiral = function(count, centerPt) {
            var angle,
                i,
                l,
                legLength,
                pt,
                ref1,
                results;
            legLength = this['spiralLengthStart'];
            angle = 0;
            results = [];
            for (i = l = 0, ref1 = count; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
              angle += this['spiralFootSeparation'] / legLength + i * 0.0005;
              pt = new gm.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle));
              legLength += twoPi * this['spiralLengthFactor'] / angle;
              results.push(pt);
            }
            return results;
          };
          p.spiderListener = function(marker, event) {
            var $this,
                clear,
                l,
                len1,
                m,
                mPt,
                markerPt,
                markerSpiderfied,
                nDist,
                nearbyMarkerData,
                nonNearbyMarkers,
                pxSq,
                ref1;
            markerSpiderfied = marker['_omsData'] != null;
            if (!(markerSpiderfied && this['keepSpiderfied'])) {
              if (this['event'] === 'mouseover') {
                $this = this;
                clear = function() {
                  return $this['unspiderfy']();
                };
                window.clearTimeout(p.timeout);
                p.timeout = setTimeout(clear, 3000);
              } else {
                this['unspiderfy']();
              }
            }
            if (markerSpiderfied || this.map.getStreetView().getVisible() || this.map.getMapTypeId() === 'GoogleEarthAPI') {
              return this.trigger('click', marker, event);
            } else {
              nearbyMarkerData = [];
              nonNearbyMarkers = [];
              nDist = this['nearbyDistance'];
              pxSq = nDist * nDist;
              markerPt = this.llToPt(marker.position);
              ref1 = this.markers;
              for (l = 0, len1 = ref1.length; l < len1; l++) {
                m = ref1[l];
                if (!((m.map != null) && m.getVisible())) {
                  continue;
                }
                mPt = this.llToPt(m.position);
                if (this.ptDistanceSq(mPt, markerPt) < pxSq) {
                  nearbyMarkerData.push({
                    marker: m,
                    markerPt: mPt
                  });
                } else {
                  nonNearbyMarkers.push(m);
                }
              }
              if (nearbyMarkerData.length === 1) {
                return this.trigger('click', marker, event);
              } else {
                return this.spiderfy(nearbyMarkerData, nonNearbyMarkers);
              }
            }
          };
          p['markersNearMarker'] = function(marker, firstOnly) {
            var l,
                len1,
                m,
                mPt,
                markerPt,
                markers,
                nDist,
                pxSq,
                ref1,
                ref2,
                ref3;
            if (firstOnly == null) {
              firstOnly = false;
            }
            if (this.projHelper.getProjection() == null) {
              throw "Must wait for 'idle' event on map before calling markersNearMarker";
            }
            nDist = this['nearbyDistance'];
            pxSq = nDist * nDist;
            markerPt = this.llToPt(marker.position);
            markers = [];
            ref1 = this.markers;
            for (l = 0, len1 = ref1.length; l < len1; l++) {
              m = ref1[l];
              if (m === marker || (m.map == null) || !m.getVisible()) {
                continue;
              }
              mPt = this.llToPt((ref2 = (ref3 = m['_omsData']) != null ? ref3.usualPosition : void 0) != null ? ref2 : m.position);
              if (this.ptDistanceSq(mPt, markerPt) < pxSq) {
                markers.push(m);
                if (firstOnly) {
                  break;
                }
              }
            }
            return markers;
          };
          p['markersNearAnyOtherMarker'] = function() {
            var i,
                i1,
                i2,
                l,
                len1,
                len2,
                len3,
                m,
                m1,
                m1Data,
                m2,
                m2Data,
                mData,
                n,
                nDist,
                pxSq,
                q,
                ref1,
                ref2,
                ref3,
                results;
            if (this.projHelper.getProjection() == null) {
              throw "Must wait for 'idle' event on map before calling markersNearAnyOtherMarker";
            }
            nDist = this['nearbyDistance'];
            pxSq = nDist * nDist;
            mData = (function() {
              var l,
                  len1,
                  ref1,
                  ref2,
                  ref3,
                  results;
              ref1 = this.markers;
              results = [];
              for (l = 0, len1 = ref1.length; l < len1; l++) {
                m = ref1[l];
                results.push({
                  pt: this.llToPt((ref2 = (ref3 = m['_omsData']) != null ? ref3.usualPosition : void 0) != null ? ref2 : m.position),
                  willSpiderfy: false
                });
              }
              return results;
            }).call(this);
            ref1 = this.markers;
            for (i1 = l = 0, len1 = ref1.length; l < len1; i1 = ++l) {
              m1 = ref1[i1];
              if (!((m1.map != null) && m1.getVisible())) {
                continue;
              }
              m1Data = mData[i1];
              if (m1Data.willSpiderfy) {
                continue;
              }
              ref2 = this.markers;
              for (i2 = n = 0, len2 = ref2.length; n < len2; i2 = ++n) {
                m2 = ref2[i2];
                if (i2 === i1) {
                  continue;
                }
                if (!((m2.map != null) && m2.getVisible())) {
                  continue;
                }
                m2Data = mData[i2];
                if (i2 < i1 && !m2Data.willSpiderfy) {
                  continue;
                }
                if (this.ptDistanceSq(m1Data.pt, m2Data.pt) < pxSq) {
                  m1Data.willSpiderfy = m2Data.willSpiderfy = true;
                  break;
                }
              }
            }
            ref3 = this.markers;
            results = [];
            for (i = q = 0, len3 = ref3.length; q < len3; i = ++q) {
              m = ref3[i];
              if (mData[i].willSpiderfy) {
                results.push(m);
              }
            }
            return results;
          };
          p.makeHighlightListenerFuncs = function(marker) {
            return {
              highlight: (function(_this) {
                return function() {
                  return marker['_omsData'].leg.setOptions({
                    strokeColor: _this['legColors']['highlighted'][_this.map.mapTypeId],
                    zIndex: _this['highlightedLegZIndex']
                  });
                };
              })(this),
              unhighlight: (function(_this) {
                return function() {
                  return marker['_omsData'].leg.setOptions({
                    strokeColor: _this['legColors']['usual'][_this.map.mapTypeId],
                    zIndex: _this['usualLegZIndex']
                  });
                };
              })(this)
            };
          };
          p.spiderfy = function(markerData, nonNearbyMarkers) {
            var bodyPt,
                footLl,
                footPt,
                footPts,
                highlightListenerFuncs,
                leg,
                marker,
                md,
                nearestMarkerDatum,
                numFeet,
                spiderfiedMarkers;
            if (this['minZoomLevel'] && this.map.getZoom() < this['minZoomLevel']) {
              return false;
            }
            this.spiderfying = true;
            numFeet = markerData.length;
            bodyPt = this.ptAverage((function() {
              var l,
                  len1,
                  results;
              results = [];
              for (l = 0, len1 = markerData.length; l < len1; l++) {
                md = markerData[l];
                results.push(md.markerPt);
              }
              return results;
            })());
            footPts = numFeet >= this['circleSpiralSwitchover'] ? this.generatePtsSpiral(numFeet, bodyPt).reverse() : this.generatePtsCircle(numFeet, bodyPt);
            spiderfiedMarkers = (function() {
              var l,
                  len1,
                  results;
              results = [];
              for (l = 0, len1 = footPts.length; l < len1; l++) {
                footPt = footPts[l];
                footLl = this.ptToLl(footPt);
                nearestMarkerDatum = this.minExtract(markerData, (function(_this) {
                  return function(md) {
                    return _this.ptDistanceSq(md.markerPt, footPt);
                  };
                })(this));
                marker = nearestMarkerDatum.marker;
                leg = new gm.Polyline({
                  map: this.map,
                  path: [marker.position, footLl],
                  strokeColor: this['legColors']['usual'][this.map.mapTypeId],
                  strokeWeight: this['legWeight'],
                  zIndex: this['usualLegZIndex']
                });
                marker['_omsData'] = {
                  usualPosition: marker.position,
                  leg: leg
                };
                if (this['legColors']['highlighted'][this.map.mapTypeId] !== this['legColors']['usual'][this.map.mapTypeId]) {
                  highlightListenerFuncs = this.makeHighlightListenerFuncs(marker);
                  marker['_omsData'].hightlightListeners = {
                    highlight: ge.addListener(marker, 'mouseover', highlightListenerFuncs.highlight),
                    unhighlight: ge.addListener(marker, 'mouseout', highlightListenerFuncs.unhighlight)
                  };
                }
                marker.setPosition(footLl);
                marker.setZIndex(Math.round(this['spiderfiedZIndex'] + footPt.y));
                results.push(marker);
              }
              return results;
            }).call(this);
            delete this.spiderfying;
            this.spiderfied = true;
            return this.trigger('spiderfy', spiderfiedMarkers, nonNearbyMarkers);
          };
          p['unspiderfy'] = function(markerNotToMove) {
            var l,
                len1,
                listeners,
                marker,
                nonNearbyMarkers,
                ref1,
                unspiderfiedMarkers;
            if (markerNotToMove == null) {
              markerNotToMove = null;
            }
            if (this.spiderfied == null) {
              return this;
            }
            this.unspiderfying = true;
            unspiderfiedMarkers = [];
            nonNearbyMarkers = [];
            ref1 = this.markers;
            for (l = 0, len1 = ref1.length; l < len1; l++) {
              marker = ref1[l];
              if (marker['_omsData'] != null) {
                marker['_omsData'].leg.setMap(null);
                if (marker !== markerNotToMove) {
                  marker.setPosition(marker['_omsData'].usualPosition);
                }
                marker.setZIndex(null);
                listeners = marker['_omsData'].hightlightListeners;
                if (listeners != null) {
                  ge.removeListener(listeners.highlight);
                  ge.removeListener(listeners.unhighlight);
                }
                delete marker['_omsData'];
                unspiderfiedMarkers.push(marker);
              } else {
                nonNearbyMarkers.push(marker);
              }
            }
            delete this.unspiderfying;
            delete this.spiderfied;
            this.trigger('unspiderfy', unspiderfiedMarkers, nonNearbyMarkers);
            return this;
          };
          p.ptDistanceSq = function(pt1, pt2) {
            var dx,
                dy;
            dx = pt1.x - pt2.x;
            dy = pt1.y - pt2.y;
            return dx * dx + dy * dy;
          };
          p.ptAverage = function(pts) {
            var l,
                len1,
                numPts,
                pt,
                sumX,
                sumY;
            sumX = sumY = 0;
            for (l = 0, len1 = pts.length; l < len1; l++) {
              pt = pts[l];
              sumX += pt.x;
              sumY += pt.y;
            }
            numPts = pts.length;
            return new gm.Point(sumX / numPts, sumY / numPts);
          };
          p.llToPt = function(ll) {
            return this.projHelper.getProjection().fromLatLngToDivPixel(ll);
          };
          p.ptToLl = function(pt) {
            return this.projHelper.getProjection().fromDivPixelToLatLng(pt);
          };
          p.minExtract = function(set, func) {
            var bestIndex,
                bestVal,
                index,
                item,
                l,
                len1,
                val;
            for (index = l = 0, len1 = set.length; l < len1; index = ++l) {
              item = set[index];
              val = func(item);
              if ((typeof bestIndex === "undefined" || bestIndex === null) || val < bestVal) {
                bestVal = val;
                bestIndex = index;
              }
            }
            return set.splice(bestIndex, 1)[0];
          };
          p.arrIndexOf = function(arr, obj) {
            var i,
                l,
                len1,
                o;
            if (arr.indexOf != null) {
              return arr.indexOf(obj);
            }
            for (i = l = 0, len1 = arr.length; l < len1; i = ++l) {
              o = arr[i];
              if (o === obj) {
                return i;
              }
            }
            return -1;
          };
          return _Class;
        })();
      }.apply(self);
      GoogleMapApi.then(function() {
        self.OverlappingMarkerSpiderfier.initializeGoogleMaps(window.google);
      });
      return this.OverlappingMarkerSpiderfier;
    }]);
    ;
    angular.module('uiGmapgoogle-maps.extensions').service('uiGmapExtendMarkerClusterer', ['uiGmapLodash', 'uiGmapPropMap', function(uiGmapLodash, PropMap) {
      return {init: _.once(function() {
          (function() {
            var __hasProp = {}.hasOwnProperty,
                __extends = function(child, parent) {
                  for (var key in parent) {
                    if (__hasProp.call(parent, key))
                      child[key] = parent[key];
                  }
                  function ctor() {
                    this.constructor = child;
                  }
                  ctor.prototype = parent.prototype;
                  child.prototype = new ctor();
                  child.__super__ = parent.prototype;
                  return child;
                };
            window.NgMapCluster = (function(_super) {
              __extends(NgMapCluster, _super);
              function NgMapCluster(opts) {
                NgMapCluster.__super__.constructor.call(this, opts);
                this.markers_ = new PropMap();
              }
              NgMapCluster.prototype.addMarker = function(marker) {
                var i;
                var mCount;
                var mz;
                if (this.isMarkerAlreadyAdded_(marker)) {
                  var oldMarker = this.markers_.get(marker.key);
                  if (oldMarker.getPosition().lat() == marker.getPosition().lat() && oldMarker.getPosition().lon() == marker.getPosition().lon())
                    return false;
                }
                if (!this.center_) {
                  this.center_ = marker.getPosition();
                  this.calculateBounds_();
                } else {
                  if (this.averageCenter_) {
                    var l = this.markers_.length + 1;
                    var lat = (this.center_.lat() * (l - 1) + marker.getPosition().lat()) / l;
                    var lng = (this.center_.lng() * (l - 1) + marker.getPosition().lng()) / l;
                    this.center_ = new google.maps.LatLng(lat, lng);
                    this.calculateBounds_();
                  }
                }
                marker.isAdded = true;
                this.markers_.push(marker);
                mCount = this.markers_.length;
                mz = this.markerClusterer_.getMaxZoom();
                if (mz !== null && this.map_.getZoom() > mz) {
                  if (marker.getMap() !== this.map_) {
                    marker.setMap(this.map_);
                  }
                } else if (mCount < this.minClusterSize_) {
                  if (marker.getMap() !== this.map_) {
                    marker.setMap(this.map_);
                  }
                } else if (mCount === this.minClusterSize_) {
                  this.markers_.each(function(m) {
                    m.setMap(null);
                  });
                } else {
                  marker.setMap(null);
                }
                return true;
              };
              NgMapCluster.prototype.isMarkerAlreadyAdded_ = function(marker) {
                return uiGmapLodash.isNullOrUndefined(this.markers_.get(marker.key));
              };
              NgMapCluster.prototype.getBounds = function() {
                var i;
                var bounds = new google.maps.LatLngBounds(this.center_, this.center_);
                this.getMarkers().each(function(m) {
                  bounds.extend(m.getPosition());
                });
                return bounds;
              };
              NgMapCluster.prototype.remove = function() {
                this.clusterIcon_.setMap(null);
                this.markers_ = new PropMap();
                delete this.markers_;
              };
              return NgMapCluster;
            })(Cluster);
            window.NgMapMarkerClusterer = (function(_super) {
              __extends(NgMapMarkerClusterer, _super);
              function NgMapMarkerClusterer(map, opt_markers, opt_options) {
                NgMapMarkerClusterer.__super__.constructor.call(this, map, opt_markers, opt_options);
                this.markers_ = new PropMap();
              }
              NgMapMarkerClusterer.prototype.clearMarkers = function() {
                this.resetViewport_(true);
                this.markers_ = new PropMap();
              };
              NgMapMarkerClusterer.prototype.removeMarker_ = function(marker) {
                if (!this.markers_.get(marker.key)) {
                  return false;
                }
                marker.setMap(null);
                this.markers_.remove(marker.key);
                return true;
              };
              NgMapMarkerClusterer.prototype.createClusters_ = function(iFirst) {
                var i,
                    marker;
                var mapBounds;
                var cMarkerClusterer = this;
                if (!this.ready_) {
                  return;
                }
                if (iFirst === 0) {
                  google.maps.event.trigger(this, 'clusteringbegin', this);
                  if (typeof this.timerRefStatic !== 'undefined') {
                    clearTimeout(this.timerRefStatic);
                    delete this.timerRefStatic;
                  }
                }
                if (this.getMap().getZoom() > 3) {
                  mapBounds = new google.maps.LatLngBounds(this.getMap().getBounds().getSouthWest(), this.getMap().getBounds().getNorthEast());
                } else {
                  mapBounds = new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625));
                }
                var bounds = this.getExtendedBounds(mapBounds);
                var iLast = Math.min(iFirst + this.batchSize_, this.markers_.length);
                var _ms = this.markers_.values();
                for (i = iFirst; i < iLast; i++) {
                  marker = _ms[i];
                  if (!marker.isAdded && this.isMarkerInBounds_(marker, bounds)) {
                    if (!this.ignoreHidden_ || (this.ignoreHidden_ && marker.getVisible())) {
                      this.addToClosestCluster_(marker);
                    }
                  }
                }
                if (iLast < this.markers_.length) {
                  this.timerRefStatic = setTimeout(function() {
                    cMarkerClusterer.createClusters_(iLast);
                  }, 0);
                } else {
                  for (i = 0; i < this.clusters_.length; i++) {
                    this.clusters_[i].updateIcon_();
                  }
                  delete this.timerRefStatic;
                  google.maps.event.trigger(this, 'clusteringend', this);
                }
              };
              NgMapMarkerClusterer.prototype.addToClosestCluster_ = function(marker) {
                var i,
                    d,
                    cluster,
                    center;
                var distance = 40000;
                var clusterToAddTo = null;
                for (i = 0; i < this.clusters_.length; i++) {
                  cluster = this.clusters_[i];
                  center = cluster.getCenter();
                  if (center) {
                    d = this.distanceBetweenPoints_(center, marker.getPosition());
                    if (d < distance) {
                      distance = d;
                      clusterToAddTo = cluster;
                    }
                  }
                }
                if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {
                  clusterToAddTo.addMarker(marker);
                } else {
                  cluster = new NgMapCluster(this);
                  cluster.addMarker(marker);
                  this.clusters_.push(cluster);
                }
              };
              NgMapMarkerClusterer.prototype.redraw_ = function() {
                this.createClusters_(0);
              };
              NgMapMarkerClusterer.prototype.resetViewport_ = function(opt_hide) {
                var i,
                    marker;
                for (i = 0; i < this.clusters_.length; i++) {
                  this.clusters_[i].remove();
                }
                this.clusters_ = [];
                this.markers_.each(function(marker) {
                  marker.isAdded = false;
                  if (opt_hide) {
                    marker.setMap(null);
                  }
                });
              };
              NgMapMarkerClusterer.prototype.extend = function(obj1, obj2) {
                return (function(object) {
                  var property;
                  for (property in object.prototype) {
                    if (property !== 'constructor')
                      this.prototype[property] = object.prototype[property];
                  }
                  return this;
                }).apply(obj1, [obj2]);
              };
              ClusterIcon.prototype.show = function() {
                if (this.div_) {
                  var img = "";
                  var bp = this.backgroundPosition_.split(" ");
                  var spriteH = parseInt(bp[0].trim(), 10);
                  var spriteV = parseInt(bp[1].trim(), 10);
                  var pos = this.getPosFromLatLng_(this.center_);
                  this.div_.style.cssText = this.createCss(pos);
                  img = "<img src='" + this.url_ + "' style='position: absolute; top: " + spriteV + "px; left: " + spriteH + "px; ";
                  if (!this.cluster_.getMarkerClusterer().enableRetinaIcons_) {
                    img += "clip: rect(" + (-1 * spriteV) + "px, " + ((-1 * spriteH) + this.width_) + "px, " + ((-1 * spriteV) + this.height_) + "px, " + (-1 * spriteH) + "px);";
                  } else {
                    img += "width: " + this.width_ + "px;" + "height: " + this.height_ + "px;";
                  }
                  img += "'>";
                  this.div_.innerHTML = img + "<div style='" + "position: absolute;" + "top: " + this.anchorText_[0] + "px;" + "left: " + this.anchorText_[1] + "px;" + "color: " + this.textColor_ + ";" + "font-size: " + this.textSize_ + "px;" + "font-family: " + this.fontFamily_ + ";" + "font-weight: " + this.fontWeight_ + ";" + "font-style: " + this.fontStyle_ + ";" + "text-decoration: " + this.textDecoration_ + ";" + "text-align: center;" + "width: " + this.width_ + "px;" + "line-height:" + this.height_ + "px;" + "'>" + this.sums_.text + "</div>";
                  if (typeof this.sums_.title === "undefined" || this.sums_.title === "") {
                    this.div_.title = this.cluster_.getMarkerClusterer().getTitle();
                  } else {
                    this.div_.title = this.sums_.title;
                  }
                  this.div_.style.display = "";
                }
                this.visible_ = true;
              };
              return NgMapMarkerClusterer;
            })(MarkerClusterer);
          }).call(this);
        })};
    }]);
  }(window, angular));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:ms@0.7.1/index", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    if ('string' == typeof val)
      return parse(val);
    return options.long ? long(val) : short(val);
  };
  function parse(str) {
    str = '' + str;
    if (str.length > 10000)
      return;
    var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
    if (!match)
      return;
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch (type) {
      case 'years':
      case 'year':
      case 'yrs':
      case 'yr':
      case 'y':
        return n * y;
      case 'days':
      case 'day':
      case 'd':
        return n * d;
      case 'hours':
      case 'hour':
      case 'hrs':
      case 'hr':
      case 'h':
        return n * h;
      case 'minutes':
      case 'minute':
      case 'mins':
      case 'min':
      case 'm':
        return n * m;
      case 'seconds':
      case 'second':
      case 'secs':
      case 'sec':
      case 's':
        return n * s;
      case 'milliseconds':
      case 'millisecond':
      case 'msecs':
      case 'msec':
      case 'ms':
        return n;
    }
  }
  function short(ms) {
    if (ms >= d)
      return Math.round(ms / d) + 'd';
    if (ms >= h)
      return Math.round(ms / h) + 'h';
    if (ms >= m)
      return Math.round(ms / m) + 'm';
    if (ms >= s)
      return Math.round(ms / s) + 's';
    return ms + 'ms';
  }
  function long(ms) {
    return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
  }
  function plural(ms, n, name) {
    if (ms < n)
      return;
    if (ms < n * 1.5)
      return Math.floor(ms / n) + ' ' + name;
    return Math.ceil(ms / n) + ' ' + name + 's';
  }
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:ms@0.7.1", ["npm:ms@0.7.1/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:ms@0.7.1/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:debug@2.2.0/debug", ["ms"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports = module.exports = debug;
  exports.coerce = coerce;
  exports.disable = disable;
  exports.enable = enable;
  exports.enabled = enabled;
  exports.humanize = $__require('ms');
  exports.names = [];
  exports.skips = [];
  exports.formatters = {};
  var prevColor = 0;
  var prevTime;
  function selectColor() {
    return exports.colors[prevColor++ % exports.colors.length];
  }
  function debug(namespace) {
    function disabled() {}
    disabled.enabled = false;
    function enabled() {
      var self = enabled;
      var curr = +new Date();
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      if (null == self.useColors)
        self.useColors = exports.useColors();
      if (null == self.color && self.useColors)
        self.color = selectColor();
      var args = Array.prototype.slice.call(arguments);
      args[0] = exports.coerce(args[0]);
      if ('string' !== typeof args[0]) {
        args = ['%o'].concat(args);
      }
      var index = 0;
      args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
        if (match === '%%')
          return match;
        index++;
        var formatter = exports.formatters[format];
        if ('function' === typeof formatter) {
          var val = args[index];
          match = formatter.call(self, val);
          args.splice(index, 1);
          index--;
        }
        return match;
      });
      if ('function' === typeof exports.formatArgs) {
        args = exports.formatArgs.apply(self, args);
      }
      var logFn = enabled.log || exports.log || console.log.bind(console);
      logFn.apply(self, args);
    }
    enabled.enabled = true;
    var fn = exports.enabled(namespace) ? enabled : disabled;
    fn.namespace = namespace;
    return fn;
  }
  function enable(namespaces) {
    exports.save(namespaces);
    var split = (namespaces || '').split(/[\s,]+/);
    var len = split.length;
    for (var i = 0; i < len; i++) {
      if (!split[i])
        continue;
      namespaces = split[i].replace(/\*/g, '.*?');
      if (namespaces[0] === '-') {
        exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        exports.names.push(new RegExp('^' + namespaces + '$'));
      }
    }
  }
  function disable() {
    exports.enable('');
  }
  function enabled(name) {
    var i,
        len;
    for (i = 0, len = exports.skips.length; i < len; i++) {
      if (exports.skips[i].test(name)) {
        return false;
      }
    }
    for (i = 0, len = exports.names.length; i < len; i++) {
      if (exports.names[i].test(name)) {
        return true;
      }
    }
    return false;
  }
  function coerce(val) {
    if (val instanceof Error)
      return val.stack || val.message;
    return val;
  }
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:debug@2.2.0/browser", ["./debug"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports = module.exports = $__require('./debug');
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();
  exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];
  function useColors() {
    return ('WebkitAppearance' in document.documentElement.style) || (window.console && (console.firebug || (console.exception && console.table))) || (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
  }
  exports.formatters.j = function(v) {
    return JSON.stringify(v);
  };
  function formatArgs() {
    var args = arguments;
    var useColors = this.useColors;
    args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);
    if (!useColors)
      return args;
    var c = 'color: ' + this.color;
    args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));
    var index = 0;
    var lastC = 0;
    args[0].replace(/%[a-z%]/g, function(match) {
      if ('%%' === match)
        return;
      index++;
      if ('%c' === match) {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
    return args;
  }
  function log() {
    return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
  }
  function save(namespaces) {
    try {
      if (null == namespaces) {
        exports.storage.removeItem('debug');
      } else {
        exports.storage.debug = namespaces;
      }
    } catch (e) {}
  }
  function load() {
    var r;
    try {
      r = exports.storage.debug;
    } catch (e) {}
    return r;
  }
  exports.enable(load());
  function localstorage() {
    try {
      return window.localStorage;
    } catch (e) {}
  }
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:debug@2.2.0", ["npm:debug@2.2.0/browser"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:debug@2.2.0/browser');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:angular-simple-logger@0.1.5/dist/index", ["angular", "debug"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var angular = $__require('angular');
  angular.module('nemLogging', []);
  angular.module('nemLogging').provider('nemDebug', function() {
    var ourDebug = null;
    ourDebug = $__require('debug');
    this.$get = function() {
      return ourDebug;
    };
    this.debug = ourDebug;
    return this;
  });
  var bind = function(fn, me) {
    return function() {
      return fn.apply(me, arguments);
    };
  };
  angular.module('nemLogging').provider('nemSimpleLogger', ['nemDebugProvider', function(nemDebugProvider) {
    var LEVELS,
        Logger,
        _fns,
        _isValidLogObject,
        _maybeExecLevel,
        _wrapDebug,
        i,
        key,
        len,
        nemDebug,
        val;
    nemDebug = nemDebugProvider.debug;
    _fns = ['debug', 'info', 'warn', 'error', 'log'];
    LEVELS = {};
    for (key = i = 0, len = _fns.length; i < len; key = ++i) {
      val = _fns[key];
      LEVELS[val] = key;
    }
    _maybeExecLevel = function(level, current, fn) {
      if (level >= current) {
        return fn();
      }
    };
    _isValidLogObject = function(logObject) {
      var isValid,
          j,
          len1;
      isValid = false;
      if (!logObject) {
        return isValid;
      }
      for (j = 0, len1 = _fns.length; j < len1; j++) {
        val = _fns[j];
        isValid = (logObject[val] != null) && typeof logObject[val] === 'function';
        if (!isValid) {
          break;
        }
      }
      return isValid;
    };
    _wrapDebug = function(debugStrLevel, logObject) {
      var debugInstance,
          j,
          len1,
          newLogger;
      debugInstance = nemDebug(debugStrLevel);
      newLogger = {};
      for (j = 0, len1 = _fns.length; j < len1; j++) {
        val = _fns[j];
        newLogger[val] = val === 'debug' ? debugInstance : logObject[val];
      }
      return newLogger;
    };
    Logger = (function() {
      function Logger($log1) {
        var fn1,
            j,
            len1,
            level,
            logFns;
        this.$log = $log1;
        this.spawn = bind(this.spawn, this);
        if (!this.$log) {
          throw 'internalLogger undefined';
        }
        if (!_isValidLogObject(this.$log)) {
          throw '@$log is invalid';
        }
        this.doLog = true;
        logFns = {};
        fn1 = (function(_this) {
          return function(level) {
            logFns[level] = function(msg) {
              if (_this.doLog) {
                return _maybeExecLevel(LEVELS[level], _this.currentLevel, function() {
                  return _this.$log[level](msg);
                });
              }
            };
            return _this[level] = logFns[level];
          };
        })(this);
        for (j = 0, len1 = _fns.length; j < len1; j++) {
          level = _fns[j];
          fn1(level);
        }
        this.LEVELS = LEVELS;
        this.currentLevel = LEVELS.error;
      }
      Logger.prototype.spawn = function(newInternalLogger) {
        if (typeof newInternalLogger === 'string') {
          if (!_isValidLogObject(this.$log)) {
            throw '@$log is invalid';
          }
          if (!nemDebug) {
            throw 'nemDebug is undefined this is probably the light version of this library sep debug logggers is not supported!';
          }
          return _wrapDebug(newInternalLogger, this.$log);
        }
        return new Logger(newInternalLogger || this.$log);
      };
      return Logger;
    })();
    this.decorator = ['$log', function($delegate) {
      var log;
      log = new Logger($delegate);
      log.currentLevel = LEVELS.debug;
      return log;
    }];
    this.$get = ['$log', function($log) {
      return new Logger($log);
    }];
    return this;
  }]);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:angular-simple-logger@0.1.5", ["npm:angular-simple-logger@0.1.5/dist/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:angular-simple-logger@0.1.5/dist/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:angular-ui/angular-google-maps@2.3.2", ["github:angular-ui/angular-google-maps@2.3.2/dist/angular-google-maps.js", "angular", "lodash", "angular-simple-logger"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('github:angular-ui/angular-google-maps@2.3.2/dist/angular-google-maps.js');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:angular-ui/bootstrap-bower@0.14.3/ui-bootstrap-tpls", [], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {
    angular.module("ui.bootstrap", ["ui.bootstrap.tpls", "ui.bootstrap.collapse", "ui.bootstrap.accordion", "ui.bootstrap.alert", "ui.bootstrap.buttons", "ui.bootstrap.carousel", "ui.bootstrap.dateparser", "ui.bootstrap.position", "ui.bootstrap.datepicker", "ui.bootstrap.dropdown", "ui.bootstrap.stackedMap", "ui.bootstrap.modal", "ui.bootstrap.pagination", "ui.bootstrap.tooltip", "ui.bootstrap.popover", "ui.bootstrap.progressbar", "ui.bootstrap.rating", "ui.bootstrap.tabs", "ui.bootstrap.timepicker", "ui.bootstrap.typeahead"]);
    angular.module("ui.bootstrap.tpls", ["template/accordion/accordion-group.html", "template/accordion/accordion.html", "template/alert/alert.html", "template/carousel/carousel.html", "template/carousel/slide.html", "template/datepicker/datepicker.html", "template/datepicker/day.html", "template/datepicker/month.html", "template/datepicker/popup.html", "template/datepicker/year.html", "template/modal/backdrop.html", "template/modal/window.html", "template/pagination/pager.html", "template/pagination/pagination.html", "template/tooltip/tooltip-html-popup.html", "template/tooltip/tooltip-popup.html", "template/tooltip/tooltip-template-popup.html", "template/popover/popover-html.html", "template/popover/popover-template.html", "template/popover/popover.html", "template/progressbar/bar.html", "template/progressbar/progress.html", "template/progressbar/progressbar.html", "template/rating/rating.html", "template/tabs/tab.html", "template/tabs/tabset.html", "template/timepicker/timepicker.html", "template/typeahead/typeahead-match.html", "template/typeahead/typeahead-popup.html"]);
    angular.module('ui.bootstrap.collapse', []).directive('uibCollapse', ['$animate', '$injector', function($animate, $injector) {
      var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;
      return {link: function(scope, element, attrs) {
          function expand() {
            element.removeClass('collapse').addClass('collapsing').attr('aria-expanded', true).attr('aria-hidden', false);
            if ($animateCss) {
              $animateCss(element, {
                addClass: 'in',
                easing: 'ease',
                to: {height: element[0].scrollHeight + 'px'}
              }).start().finally(expandDone);
            } else {
              $animate.addClass(element, 'in', {to: {height: element[0].scrollHeight + 'px'}}).then(expandDone);
            }
          }
          function expandDone() {
            element.removeClass('collapsing').addClass('collapse').css({height: 'auto'});
          }
          function collapse() {
            if (!element.hasClass('collapse') && !element.hasClass('in')) {
              return collapseDone();
            }
            element.css({height: element[0].scrollHeight + 'px'}).removeClass('collapse').addClass('collapsing').attr('aria-expanded', false).attr('aria-hidden', true);
            if ($animateCss) {
              $animateCss(element, {
                removeClass: 'in',
                to: {height: '0'}
              }).start().finally(collapseDone);
            } else {
              $animate.removeClass(element, 'in', {to: {height: '0'}}).then(collapseDone);
            }
          }
          function collapseDone() {
            element.css({height: '0'});
            element.removeClass('collapsing').addClass('collapse');
          }
          scope.$watch(attrs.uibCollapse, function(shouldCollapse) {
            if (shouldCollapse) {
              collapse();
            } else {
              expand();
            }
          });
        }};
    }]);
    angular.module('ui.bootstrap.collapse').value('$collapseSuppressWarning', false).directive('collapse', ['$animate', '$injector', '$log', '$collapseSuppressWarning', function($animate, $injector, $log, $collapseSuppressWarning) {
      var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;
      return {link: function(scope, element, attrs) {
          if (!$collapseSuppressWarning) {
            $log.warn('collapse is now deprecated. Use uib-collapse instead.');
          }
          function expand() {
            element.removeClass('collapse').addClass('collapsing').attr('aria-expanded', true).attr('aria-hidden', false);
            if ($animateCss) {
              $animateCss(element, {
                easing: 'ease',
                to: {height: element[0].scrollHeight + 'px'}
              }).start().done(expandDone);
            } else {
              $animate.animate(element, {}, {height: element[0].scrollHeight + 'px'}).then(expandDone);
            }
          }
          function expandDone() {
            element.removeClass('collapsing').addClass('collapse in').css({height: 'auto'});
          }
          function collapse() {
            if (!element.hasClass('collapse') && !element.hasClass('in')) {
              return collapseDone();
            }
            element.css({height: element[0].scrollHeight + 'px'}).removeClass('collapse in').addClass('collapsing').attr('aria-expanded', false).attr('aria-hidden', true);
            if ($animateCss) {
              $animateCss(element, {to: {height: '0'}}).start().done(collapseDone);
            } else {
              $animate.animate(element, {}, {height: '0'}).then(collapseDone);
            }
          }
          function collapseDone() {
            element.css({height: '0'});
            element.removeClass('collapsing').addClass('collapse');
          }
          scope.$watch(attrs.collapse, function(shouldCollapse) {
            if (shouldCollapse) {
              collapse();
            } else {
              expand();
            }
          });
        }};
    }]);
    angular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse']).constant('uibAccordionConfig', {closeOthers: true}).controller('UibAccordionController', ['$scope', '$attrs', 'uibAccordionConfig', function($scope, $attrs, accordionConfig) {
      this.groups = [];
      this.closeOthers = function(openGroup) {
        var closeOthers = angular.isDefined($attrs.closeOthers) ? $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
        if (closeOthers) {
          angular.forEach(this.groups, function(group) {
            if (group !== openGroup) {
              group.isOpen = false;
            }
          });
        }
      };
      this.addGroup = function(groupScope) {
        var that = this;
        this.groups.push(groupScope);
        groupScope.$on('$destroy', function(event) {
          that.removeGroup(groupScope);
        });
      };
      this.removeGroup = function(group) {
        var index = this.groups.indexOf(group);
        if (index !== -1) {
          this.groups.splice(index, 1);
        }
      };
    }]).directive('uibAccordion', function() {
      return {
        controller: 'UibAccordionController',
        controllerAs: 'accordion',
        transclude: true,
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'template/accordion/accordion.html';
        }
      };
    }).directive('uibAccordionGroup', function() {
      return {
        require: '^uibAccordion',
        transclude: true,
        replace: true,
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'template/accordion/accordion-group.html';
        },
        scope: {
          heading: '@',
          isOpen: '=?',
          isDisabled: '=?'
        },
        controller: function() {
          this.setHeading = function(element) {
            this.heading = element;
          };
        },
        link: function(scope, element, attrs, accordionCtrl) {
          accordionCtrl.addGroup(scope);
          scope.openClass = attrs.openClass || 'panel-open';
          scope.panelClass = attrs.panelClass;
          scope.$watch('isOpen', function(value) {
            element.toggleClass(scope.openClass, !!value);
            if (value) {
              accordionCtrl.closeOthers(scope);
            }
          });
          scope.toggleOpen = function($event) {
            if (!scope.isDisabled) {
              if (!$event || $event.which === 32) {
                scope.isOpen = !scope.isOpen;
              }
            }
          };
        }
      };
    }).directive('uibAccordionHeading', function() {
      return {
        transclude: true,
        template: '',
        replace: true,
        require: '^uibAccordionGroup',
        link: function(scope, element, attrs, accordionGroupCtrl, transclude) {
          accordionGroupCtrl.setHeading(transclude(scope, angular.noop));
        }
      };
    }).directive('uibAccordionTransclude', function() {
      return {
        require: ['?^uibAccordionGroup', '?^accordionGroup'],
        link: function(scope, element, attrs, controller) {
          controller = controller[0] ? controller[0] : controller[1];
          scope.$watch(function() {
            return controller[attrs.uibAccordionTransclude];
          }, function(heading) {
            if (heading) {
              element.find('span').html('');
              element.find('span').append(heading);
            }
          });
        }
      };
    });
    angular.module('ui.bootstrap.accordion').value('$accordionSuppressWarning', false).controller('AccordionController', ['$scope', '$attrs', '$controller', '$log', '$accordionSuppressWarning', function($scope, $attrs, $controller, $log, $accordionSuppressWarning) {
      if (!$accordionSuppressWarning) {
        $log.warn('AccordionController is now deprecated. Use UibAccordionController instead.');
      }
      angular.extend(this, $controller('UibAccordionController', {
        $scope: $scope,
        $attrs: $attrs
      }));
    }]).directive('accordion', ['$log', '$accordionSuppressWarning', function($log, $accordionSuppressWarning) {
      return {
        restrict: 'EA',
        controller: 'AccordionController',
        controllerAs: 'accordion',
        transclude: true,
        replace: false,
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'template/accordion/accordion.html';
        },
        link: function() {
          if (!$accordionSuppressWarning) {
            $log.warn('accordion is now deprecated. Use uib-accordion instead.');
          }
        }
      };
    }]).directive('accordionGroup', ['$log', '$accordionSuppressWarning', function($log, $accordionSuppressWarning) {
      return {
        require: '^accordion',
        restrict: 'EA',
        transclude: true,
        replace: true,
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'template/accordion/accordion-group.html';
        },
        scope: {
          heading: '@',
          isOpen: '=?',
          isDisabled: '=?'
        },
        controller: function() {
          this.setHeading = function(element) {
            this.heading = element;
          };
        },
        link: function(scope, element, attrs, accordionCtrl) {
          if (!$accordionSuppressWarning) {
            $log.warn('accordion-group is now deprecated. Use uib-accordion-group instead.');
          }
          accordionCtrl.addGroup(scope);
          scope.openClass = attrs.openClass || 'panel-open';
          scope.panelClass = attrs.panelClass;
          scope.$watch('isOpen', function(value) {
            element.toggleClass(scope.openClass, !!value);
            if (value) {
              accordionCtrl.closeOthers(scope);
            }
          });
          scope.toggleOpen = function($event) {
            if (!scope.isDisabled) {
              if (!$event || $event.which === 32) {
                scope.isOpen = !scope.isOpen;
              }
            }
          };
        }
      };
    }]).directive('accordionHeading', ['$log', '$accordionSuppressWarning', function($log, $accordionSuppressWarning) {
      return {
        restrict: 'EA',
        transclude: true,
        template: '',
        replace: true,
        require: '^accordionGroup',
        link: function(scope, element, attr, accordionGroupCtrl, transclude) {
          if (!$accordionSuppressWarning) {
            $log.warn('accordion-heading is now deprecated. Use uib-accordion-heading instead.');
          }
          accordionGroupCtrl.setHeading(transclude(scope, angular.noop));
        }
      };
    }]).directive('accordionTransclude', ['$log', '$accordionSuppressWarning', function($log, $accordionSuppressWarning) {
      return {
        require: '^accordionGroup',
        link: function(scope, element, attr, controller) {
          if (!$accordionSuppressWarning) {
            $log.warn('accordion-transclude is now deprecated. Use uib-accordion-transclude instead.');
          }
          scope.$watch(function() {
            return controller[attr.accordionTransclude];
          }, function(heading) {
            if (heading) {
              element.find('span').html('');
              element.find('span').append(heading);
            }
          });
        }
      };
    }]);
    angular.module('ui.bootstrap.alert', []).controller('UibAlertController', ['$scope', '$attrs', '$interpolate', '$timeout', function($scope, $attrs, $interpolate, $timeout) {
      $scope.closeable = !!$attrs.close;
      var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ? $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;
      if (dismissOnTimeout) {
        $timeout(function() {
          $scope.close();
        }, parseInt(dismissOnTimeout, 10));
      }
    }]).directive('uibAlert', function() {
      return {
        controller: 'UibAlertController',
        controllerAs: 'alert',
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'template/alert/alert.html';
        },
        transclude: true,
        replace: true,
        scope: {
          type: '@',
          close: '&'
        }
      };
    });
    angular.module('ui.bootstrap.alert').value('$alertSuppressWarning', false).controller('AlertController', ['$scope', '$attrs', '$controller', '$log', '$alertSuppressWarning', function($scope, $attrs, $controller, $log, $alertSuppressWarning) {
      if (!$alertSuppressWarning) {
        $log.warn('AlertController is now deprecated. Use UibAlertController instead.');
      }
      angular.extend(this, $controller('UibAlertController', {
        $scope: $scope,
        $attrs: $attrs
      }));
    }]).directive('alert', ['$log', '$alertSuppressWarning', function($log, $alertSuppressWarning) {
      return {
        controller: 'AlertController',
        controllerAs: 'alert',
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'template/alert/alert.html';
        },
        transclude: true,
        replace: true,
        scope: {
          type: '@',
          close: '&'
        },
        link: function() {
          if (!$alertSuppressWarning) {
            $log.warn('alert is now deprecated. Use uib-alert instead.');
          }
        }
      };
    }]);
    angular.module('ui.bootstrap.buttons', []).constant('uibButtonConfig', {
      activeClass: 'active',
      toggleEvent: 'click'
    }).controller('UibButtonsController', ['uibButtonConfig', function(buttonConfig) {
      this.activeClass = buttonConfig.activeClass || 'active';
      this.toggleEvent = buttonConfig.toggleEvent || 'click';
    }]).directive('uibBtnRadio', function() {
      return {
        require: ['uibBtnRadio', 'ngModel'],
        controller: 'UibButtonsController',
        controllerAs: 'buttons',
        link: function(scope, element, attrs, ctrls) {
          var buttonsCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];
          element.find('input').css({display: 'none'});
          ngModelCtrl.$render = function() {
            element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));
          };
          element.on(buttonsCtrl.toggleEvent, function() {
            if (attrs.disabled) {
              return;
            }
            var isActive = element.hasClass(buttonsCtrl.activeClass);
            if (!isActive || angular.isDefined(attrs.uncheckable)) {
              scope.$apply(function() {
                ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio));
                ngModelCtrl.$render();
              });
            }
          });
        }
      };
    }).directive('uibBtnCheckbox', function() {
      return {
        require: ['uibBtnCheckbox', 'ngModel'],
        controller: 'UibButtonsController',
        controllerAs: 'button',
        link: function(scope, element, attrs, ctrls) {
          var buttonsCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];
          element.find('input').css({display: 'none'});
          function getTrueValue() {
            return getCheckboxValue(attrs.btnCheckboxTrue, true);
          }
          function getFalseValue() {
            return getCheckboxValue(attrs.btnCheckboxFalse, false);
          }
          function getCheckboxValue(attribute, defaultValue) {
            return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;
          }
          ngModelCtrl.$render = function() {
            element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
          };
          element.on(buttonsCtrl.toggleEvent, function() {
            if (attrs.disabled) {
              return;
            }
            scope.$apply(function() {
              ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
              ngModelCtrl.$render();
            });
          });
        }
      };
    });
    angular.module('ui.bootstrap.buttons').value('$buttonsSuppressWarning', false).controller('ButtonsController', ['$controller', '$log', '$buttonsSuppressWarning', function($controller, $log, $buttonsSuppressWarning) {
      if (!$buttonsSuppressWarning) {
        $log.warn('ButtonsController is now deprecated. Use UibButtonsController instead.');
      }
      angular.extend(this, $controller('UibButtonsController'));
    }]).directive('btnRadio', ['$log', '$buttonsSuppressWarning', function($log, $buttonsSuppressWarning) {
      return {
        require: ['btnRadio', 'ngModel'],
        controller: 'ButtonsController',
        controllerAs: 'buttons',
        link: function(scope, element, attrs, ctrls) {
          if (!$buttonsSuppressWarning) {
            $log.warn('btn-radio is now deprecated. Use uib-btn-radio instead.');
          }
          var buttonsCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];
          element.find('input').css({display: 'none'});
          ngModelCtrl.$render = function() {
            element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));
          };
          element.bind(buttonsCtrl.toggleEvent, function() {
            if (attrs.disabled) {
              return;
            }
            var isActive = element.hasClass(buttonsCtrl.activeClass);
            if (!isActive || angular.isDefined(attrs.uncheckable)) {
              scope.$apply(function() {
                ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.btnRadio));
                ngModelCtrl.$render();
              });
            }
          });
        }
      };
    }]).directive('btnCheckbox', ['$document', '$log', '$buttonsSuppressWarning', function($document, $log, $buttonsSuppressWarning) {
      return {
        require: ['btnCheckbox', 'ngModel'],
        controller: 'ButtonsController',
        controllerAs: 'button',
        link: function(scope, element, attrs, ctrls) {
          if (!$buttonsSuppressWarning) {
            $log.warn('btn-checkbox is now deprecated. Use uib-btn-checkbox instead.');
          }
          var buttonsCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];
          element.find('input').css({display: 'none'});
          function getTrueValue() {
            return getCheckboxValue(attrs.btnCheckboxTrue, true);
          }
          function getFalseValue() {
            return getCheckboxValue(attrs.btnCheckboxFalse, false);
          }
          function getCheckboxValue(attributeValue, defaultValue) {
            var val = scope.$eval(attributeValue);
            return angular.isDefined(val) ? val : defaultValue;
          }
          ngModelCtrl.$render = function() {
            element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
          };
          element.bind(buttonsCtrl.toggleEvent, function() {
            if (attrs.disabled) {
              return;
            }
            scope.$apply(function() {
              ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
              ngModelCtrl.$render();
            });
          });
          element.on('keypress', function(e) {
            if (attrs.disabled || e.which !== 32 || $document[0].activeElement !== element[0]) {
              return;
            }
            scope.$apply(function() {
              ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
              ngModelCtrl.$render();
            });
          });
        }
      };
    }]);
    angular.module('ui.bootstrap.carousel', []).controller('UibCarouselController', ['$scope', '$element', '$interval', '$animate', function($scope, $element, $interval, $animate) {
      var self = this,
          slides = self.slides = $scope.slides = [],
          NEW_ANIMATE = angular.version.minor >= 4,
          NO_TRANSITION = 'uib-noTransition',
          SLIDE_DIRECTION = 'uib-slideDirection',
          currentIndex = -1,
          currentInterval,
          isPlaying;
      self.currentSlide = null;
      var destroyed = false;
      self.select = $scope.select = function(nextSlide, direction) {
        var nextIndex = $scope.indexOfSlide(nextSlide);
        if (direction === undefined) {
          direction = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';
        }
        if (nextSlide && nextSlide !== self.currentSlide && !$scope.$currentTransition) {
          goNext(nextSlide, nextIndex, direction);
        }
      };
      function goNext(slide, index, direction) {
        if (destroyed) {
          return;
        }
        angular.extend(slide, {
          direction: direction,
          active: true
        });
        angular.extend(self.currentSlide || {}, {
          direction: direction,
          active: false
        });
        if ($animate.enabled() && !$scope.noTransition && !$scope.$currentTransition && slide.$element && self.slides.length > 1) {
          slide.$element.data(SLIDE_DIRECTION, slide.direction);
          if (self.currentSlide && self.currentSlide.$element) {
            self.currentSlide.$element.data(SLIDE_DIRECTION, slide.direction);
          }
          $scope.$currentTransition = true;
          if (NEW_ANIMATE) {
            $animate.on('addClass', slide.$element, function(element, phase) {
              if (phase === 'close') {
                $scope.$currentTransition = null;
                $animate.off('addClass', element);
              }
            });
          } else {
            slide.$element.one('$animate:close', function closeFn() {
              $scope.$currentTransition = null;
            });
          }
        }
        self.currentSlide = slide;
        currentIndex = index;
        restartTimer();
      }
      $scope.$on('$destroy', function() {
        destroyed = true;
      });
      function getSlideByIndex(index) {
        if (angular.isUndefined(slides[index].index)) {
          return slides[index];
        }
        var i,
            len = slides.length;
        for (i = 0; i < slides.length; ++i) {
          if (slides[i].index == index) {
            return slides[i];
          }
        }
      }
      self.getCurrentIndex = function() {
        if (self.currentSlide && angular.isDefined(self.currentSlide.index)) {
          return +self.currentSlide.index;
        }
        return currentIndex;
      };
      $scope.indexOfSlide = function(slide) {
        return angular.isDefined(slide.index) ? +slide.index : slides.indexOf(slide);
      };
      $scope.next = function() {
        var newIndex = (self.getCurrentIndex() + 1) % slides.length;
        if (newIndex === 0 && $scope.noWrap()) {
          $scope.pause();
          return;
        }
        return self.select(getSlideByIndex(newIndex), 'next');
      };
      $scope.prev = function() {
        var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;
        if ($scope.noWrap() && newIndex === slides.length - 1) {
          $scope.pause();
          return;
        }
        return self.select(getSlideByIndex(newIndex), 'prev');
      };
      $scope.isActive = function(slide) {
        return self.currentSlide === slide;
      };
      $scope.$watch('interval', restartTimer);
      $scope.$watchCollection('slides', resetTransition);
      $scope.$on('$destroy', resetTimer);
      function restartTimer() {
        resetTimer();
        var interval = +$scope.interval;
        if (!isNaN(interval) && interval > 0) {
          currentInterval = $interval(timerFn, interval);
        }
      }
      function resetTimer() {
        if (currentInterval) {
          $interval.cancel(currentInterval);
          currentInterval = null;
        }
      }
      function timerFn() {
        var interval = +$scope.interval;
        if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {
          $scope.next();
        } else {
          $scope.pause();
        }
      }
      function resetTransition(slides) {
        if (!slides.length) {
          $scope.$currentTransition = null;
        }
      }
      $scope.play = function() {
        if (!isPlaying) {
          isPlaying = true;
          restartTimer();
        }
      };
      $scope.pause = function() {
        if (!$scope.noPause) {
          isPlaying = false;
          resetTimer();
        }
      };
      self.addSlide = function(slide, element) {
        slide.$element = element;
        slides.push(slide);
        if (slides.length === 1 || slide.active) {
          self.select(slides[slides.length - 1]);
          if (slides.length === 1) {
            $scope.play();
          }
        } else {
          slide.active = false;
        }
      };
      self.removeSlide = function(slide) {
        if (angular.isDefined(slide.index)) {
          slides.sort(function(a, b) {
            return +a.index > +b.index;
          });
        }
        var index = slides.indexOf(slide);
        slides.splice(index, 1);
        if (slides.length > 0 && slide.active) {
          if (index >= slides.length) {
            self.select(slides[index - 1]);
          } else {
            self.select(slides[index]);
          }
        } else if (currentIndex > index) {
          currentIndex--;
        }
        if (slides.length === 0) {
          self.currentSlide = null;
        }
      };
      $scope.$watch('noTransition', function(noTransition) {
        $element.data(NO_TRANSITION, noTransition);
      });
    }]).directive('uibCarousel', [function() {
      return {
        transclude: true,
        replace: true,
        controller: 'UibCarouselController',
        controllerAs: 'carousel',
        require: 'carousel',
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'template/carousel/carousel.html';
        },
        scope: {
          interval: '=',
          noTransition: '=',
          noPause: '=',
          noWrap: '&'
        }
      };
    }]).directive('uibSlide', function() {
      return {
        require: '^uibCarousel',
        restrict: 'EA',
        transclude: true,
        replace: true,
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'template/carousel/slide.html';
        },
        scope: {
          active: '=?',
          actual: '=?',
          index: '=?'
        },
        link: function(scope, element, attrs, carouselCtrl) {
          carouselCtrl.addSlide(scope, element);
          scope.$on('$destroy', function() {
            carouselCtrl.removeSlide(scope);
          });
          scope.$watch('active', function(active) {
            if (active) {
              carouselCtrl.select(scope);
            }
          });
        }
      };
    }).animation('.item', ['$injector', '$animate', function($injector, $animate) {
      var NO_TRANSITION = 'uib-noTransition',
          SLIDE_DIRECTION = 'uib-slideDirection',
          $animateCss = null;
      if ($injector.has('$animateCss')) {
        $animateCss = $injector.get('$animateCss');
      }
      function removeClass(element, className, callback) {
        element.removeClass(className);
        if (callback) {
          callback();
        }
      }
      return {
        beforeAddClass: function(element, className, done) {
          if (className == 'active' && element.parent() && element.parent().parent() && !element.parent().parent().data(NO_TRANSITION)) {
            var stopped = false;
            var direction = element.data(SLIDE_DIRECTION);
            var directionClass = direction == 'next' ? 'left' : 'right';
            var removeClassFn = removeClass.bind(this, element, directionClass + ' ' + direction, done);
            element.addClass(direction);
            if ($animateCss) {
              $animateCss(element, {addClass: directionClass}).start().done(removeClassFn);
            } else {
              $animate.addClass(element, directionClass).then(function() {
                if (!stopped) {
                  removeClassFn();
                }
                done();
              });
            }
            return function() {
              stopped = true;
            };
          }
          done();
        },
        beforeRemoveClass: function(element, className, done) {
          if (className === 'active' && element.parent() && element.parent().parent() && !element.parent().parent().data(NO_TRANSITION)) {
            var stopped = false;
            var direction = element.data(SLIDE_DIRECTION);
            var directionClass = direction == 'next' ? 'left' : 'right';
            var removeClassFn = removeClass.bind(this, element, directionClass, done);
            if ($animateCss) {
              $animateCss(element, {addClass: directionClass}).start().done(removeClassFn);
            } else {
              $animate.addClass(element, directionClass).then(function() {
                if (!stopped) {
                  removeClassFn();
                }
                done();
              });
            }
            return function() {
              stopped = true;
            };
          }
          done();
        }
      };
    }]);
    angular.module('ui.bootstrap.carousel').value('$carouselSuppressWarning', false).controller('CarouselController', ['$scope', '$element', '$controller', '$log', '$carouselSuppressWarning', function($scope, $element, $controller, $log, $carouselSuppressWarning) {
      if (!$carouselSuppressWarning) {
        $log.warn('CarouselController is now deprecated. Use UibCarouselController instead.');
      }
      angular.extend(this, $controller('UibCarouselController', {
        $scope: $scope,
        $element: $element
      }));
    }]).directive('carousel', ['$log', '$carouselSuppressWarning', function($log, $carouselSuppressWarning) {
      return {
        transclude: true,
        replace: true,
        controller: 'CarouselController',
        controllerAs: 'carousel',
        require: 'carousel',
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'template/carousel/carousel.html';
        },
        scope: {
          interval: '=',
          noTransition: '=',
          noPause: '=',
          noWrap: '&'
        },
        link: function() {
          if (!$carouselSuppressWarning) {
            $log.warn('carousel is now deprecated. Use uib-carousel instead.');
          }
        }
      };
    }]).directive('slide', ['$log', '$carouselSuppressWarning', function($log, $carouselSuppressWarning) {
      return {
        require: '^carousel',
        transclude: true,
        replace: true,
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'template/carousel/slide.html';
        },
        scope: {
          active: '=?',
          actual: '=?',
          index: '=?'
        },
        link: function(scope, element, attrs, carouselCtrl) {
          if (!$carouselSuppressWarning) {
            $log.warn('slide is now deprecated. Use uib-slide instead.');
          }
          carouselCtrl.addSlide(scope, element);
          scope.$on('$destroy', function() {
            carouselCtrl.removeSlide(scope);
          });
          scope.$watch('active', function(active) {
            if (active) {
              carouselCtrl.select(scope);
            }
          });
        }
      };
    }]);
    angular.module('ui.bootstrap.dateparser', []).service('uibDateParser', ['$log', '$locale', 'orderByFilter', function($log, $locale, orderByFilter) {
      var SPECIAL_CHARACTERS_REGEXP = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
      var localeId;
      var formatCodeToRegex;
      this.init = function() {
        localeId = $locale.id;
        this.parsers = {};
        formatCodeToRegex = {
          'yyyy': {
            regex: '\\d{4}',
            apply: function(value) {
              this.year = +value;
            }
          },
          'yy': {
            regex: '\\d{2}',
            apply: function(value) {
              this.year = +value + 2000;
            }
          },
          'y': {
            regex: '\\d{1,4}',
            apply: function(value) {
              this.year = +value;
            }
          },
          'MMMM': {
            regex: $locale.DATETIME_FORMATS.MONTH.join('|'),
            apply: function(value) {
              this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value);
            }
          },
          'MMM': {
            regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),
            apply: function(value) {
              this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value);
            }
          },
          'MM': {
            regex: '0[1-9]|1[0-2]',
            apply: function(value) {
              this.month = value - 1;
            }
          },
          'M': {
            regex: '[1-9]|1[0-2]',
            apply: function(value) {
              this.month = value - 1;
            }
          },
          'dd': {
            regex: '[0-2][0-9]{1}|3[0-1]{1}',
            apply: function(value) {
              this.date = +value;
            }
          },
          'd': {
            regex: '[1-2]?[0-9]{1}|3[0-1]{1}',
            apply: function(value) {
              this.date = +value;
            }
          },
          'EEEE': {regex: $locale.DATETIME_FORMATS.DAY.join('|')},
          'EEE': {regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|')},
          'HH': {
            regex: '(?:0|1)[0-9]|2[0-3]',
            apply: function(value) {
              this.hours = +value;
            }
          },
          'hh': {
            regex: '0[0-9]|1[0-2]',
            apply: function(value) {
              this.hours = +value;
            }
          },
          'H': {
            regex: '1?[0-9]|2[0-3]',
            apply: function(value) {
              this.hours = +value;
            }
          },
          'h': {
            regex: '[0-9]|1[0-2]',
            apply: function(value) {
              this.hours = +value;
            }
          },
          'mm': {
            regex: '[0-5][0-9]',
            apply: function(value) {
              this.minutes = +value;
            }
          },
          'm': {
            regex: '[0-9]|[1-5][0-9]',
            apply: function(value) {
              this.minutes = +value;
            }
          },
          'sss': {
            regex: '[0-9][0-9][0-9]',
            apply: function(value) {
              this.milliseconds = +value;
            }
          },
          'ss': {
            regex: '[0-5][0-9]',
            apply: function(value) {
              this.seconds = +value;
            }
          },
          's': {
            regex: '[0-9]|[1-5][0-9]',
            apply: function(value) {
              this.seconds = +value;
            }
          },
          'a': {
            regex: $locale.DATETIME_FORMATS.AMPMS.join('|'),
            apply: function(value) {
              if (this.hours === 12) {
                this.hours = 0;
              }
              if (value === 'PM') {
                this.hours += 12;
              }
            }
          }
        };
      };
      this.init();
      function createParser(format) {
        var map = [],
            regex = format.split('');
        angular.forEach(formatCodeToRegex, function(data, code) {
          var index = format.indexOf(code);
          if (index > -1) {
            format = format.split('');
            regex[index] = '(' + data.regex + ')';
            format[index] = '$';
            for (var i = index + 1,
                n = index + code.length; i < n; i++) {
              regex[i] = '';
              format[i] = '$';
            }
            format = format.join('');
            map.push({
              index: index,
              apply: data.apply
            });
          }
        });
        return {
          regex: new RegExp('^' + regex.join('') + '$'),
          map: orderByFilter(map, 'index')
        };
      }
      this.parse = function(input, format, baseDate) {
        if (!angular.isString(input) || !format) {
          return input;
        }
        format = $locale.DATETIME_FORMATS[format] || format;
        format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\$&');
        if ($locale.id !== localeId) {
          this.init();
        }
        if (!this.parsers[format]) {
          this.parsers[format] = createParser(format);
        }
        var parser = this.parsers[format],
            regex = parser.regex,
            map = parser.map,
            results = input.match(regex);
        if (results && results.length) {
          var fields,
              dt;
          if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {
            fields = {
              year: baseDate.getFullYear(),
              month: baseDate.getMonth(),
              date: baseDate.getDate(),
              hours: baseDate.getHours(),
              minutes: baseDate.getMinutes(),
              seconds: baseDate.getSeconds(),
              milliseconds: baseDate.getMilliseconds()
            };
          } else {
            if (baseDate) {
              $log.warn('dateparser:', 'baseDate is not a valid date');
            }
            fields = {
              year: 1900,
              month: 0,
              date: 1,
              hours: 0,
              minutes: 0,
              seconds: 0,
              milliseconds: 0
            };
          }
          for (var i = 1,
              n = results.length; i < n; i++) {
            var mapper = map[i - 1];
            if (mapper.apply) {
              mapper.apply.call(fields, results[i]);
            }
          }
          if (isValid(fields.year, fields.month, fields.date)) {
            if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {
              dt = new Date(baseDate);
              dt.setFullYear(fields.year, fields.month, fields.date, fields.hours, fields.minutes, fields.seconds, fields.milliseconds || 0);
            } else {
              dt = new Date(fields.year, fields.month, fields.date, fields.hours, fields.minutes, fields.seconds, fields.milliseconds || 0);
            }
          }
          return dt;
        }
      };
      function isValid(year, month, date) {
        if (date < 1) {
          return false;
        }
        if (month === 1 && date > 28) {
          return date === 29 && ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0);
        }
        if (month === 3 || month === 5 || month === 8 || month === 10) {
          return date < 31;
        }
        return true;
      }
    }]);
    angular.module('ui.bootstrap.dateparser').value('$dateParserSuppressWarning', false).service('dateParser', ['$log', '$dateParserSuppressWarning', 'uibDateParser', function($log, $dateParserSuppressWarning, uibDateParser) {
      if (!$dateParserSuppressWarning) {
        $log.warn('dateParser is now deprecated. Use uibDateParser instead.');
      }
      angular.extend(this, uibDateParser);
    }]);
    angular.module('ui.bootstrap.position', []).factory('$uibPosition', ['$document', '$window', function($document, $window) {
      function getStyle(el, cssprop) {
        if (el.currentStyle) {
          return el.currentStyle[cssprop];
        } else if ($window.getComputedStyle) {
          return $window.getComputedStyle(el)[cssprop];
        }
        return el.style[cssprop];
      }
      function isStaticPositioned(element) {
        return (getStyle(element, 'position') || 'static') === 'static';
      }
      var parentOffsetEl = function(element) {
        var docDomEl = $document[0];
        var offsetParent = element.offsetParent || docDomEl;
        while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent)) {
          offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || docDomEl;
      };
      return {
        position: function(element) {
          var elBCR = this.offset(element);
          var offsetParentBCR = {
            top: 0,
            left: 0
          };
          var offsetParentEl = parentOffsetEl(element[0]);
          if (offsetParentEl != $document[0]) {
            offsetParentBCR = this.offset(angular.element(offsetParentEl));
            offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;
            offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;
          }
          var boundingClientRect = element[0].getBoundingClientRect();
          return {
            width: boundingClientRect.width || element.prop('offsetWidth'),
            height: boundingClientRect.height || element.prop('offsetHeight'),
            top: elBCR.top - offsetParentBCR.top,
            left: elBCR.left - offsetParentBCR.left
          };
        },
        offset: function(element) {
          var boundingClientRect = element[0].getBoundingClientRect();
          return {
            width: boundingClientRect.width || element.prop('offsetWidth'),
            height: boundingClientRect.height || element.prop('offsetHeight'),
            top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),
            left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)
          };
        },
        positionElements: function(hostEl, targetEl, positionStr, appendToBody) {
          var positionStrParts = positionStr.split('-');
          var pos0 = positionStrParts[0],
              pos1 = positionStrParts[1] || 'center';
          var hostElPos,
              targetElWidth,
              targetElHeight,
              targetElPos;
          hostElPos = appendToBody ? this.offset(hostEl) : this.position(hostEl);
          targetElWidth = targetEl.prop('offsetWidth');
          targetElHeight = targetEl.prop('offsetHeight');
          var shiftWidth = {
            center: function() {
              return hostElPos.left + hostElPos.width / 2 - targetElWidth / 2;
            },
            left: function() {
              return hostElPos.left;
            },
            right: function() {
              return hostElPos.left + hostElPos.width;
            }
          };
          var shiftHeight = {
            center: function() {
              return hostElPos.top + hostElPos.height / 2 - targetElHeight / 2;
            },
            top: function() {
              return hostElPos.top;
            },
            bottom: function() {
              return hostElPos.top + hostElPos.height;
            }
          };
          switch (pos0) {
            case 'right':
              targetElPos = {
                top: shiftHeight[pos1](),
                left: shiftWidth[pos0]()
              };
              break;
            case 'left':
              targetElPos = {
                top: shiftHeight[pos1](),
                left: hostElPos.left - targetElWidth
              };
              break;
            case 'bottom':
              targetElPos = {
                top: shiftHeight[pos0](),
                left: shiftWidth[pos1]()
              };
              break;
            default:
              targetElPos = {
                top: hostElPos.top - targetElHeight,
                left: shiftWidth[pos1]()
              };
              break;
          }
          return targetElPos;
        }
      };
    }]);
    angular.module('ui.bootstrap.position').value('$positionSuppressWarning', false).service('$position', ['$log', '$positionSuppressWarning', '$uibPosition', function($log, $positionSuppressWarning, $uibPosition) {
      if (!$positionSuppressWarning) {
        $log.warn('$position is now deprecated. Use $uibPosition instead.');
      }
      angular.extend(this, $uibPosition);
    }]);
    angular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.position']).value('$datepickerSuppressError', false).constant('uibDatepickerConfig', {
      formatDay: 'dd',
      formatMonth: 'MMMM',
      formatYear: 'yyyy',
      formatDayHeader: 'EEE',
      formatDayTitle: 'MMMM yyyy',
      formatMonthTitle: 'yyyy',
      datepickerMode: 'day',
      minMode: 'day',
      maxMode: 'year',
      showWeeks: true,
      startingDay: 0,
      yearRange: 20,
      minDate: null,
      maxDate: null,
      shortcutPropagation: false
    }).controller('UibDatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerSuppressError', function($scope, $attrs, $parse, $interpolate, $log, dateFilter, datepickerConfig, $datepickerSuppressError) {
      var self = this,
          ngModelCtrl = {$setViewValue: angular.noop};
      this.modes = ['day', 'month', 'year'];
      angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle', 'showWeeks', 'startingDay', 'yearRange', 'shortcutPropagation'], function(key, index) {
        self[key] = angular.isDefined($attrs[key]) ? (index < 6 ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key])) : datepickerConfig[key];
      });
      angular.forEach(['minDate', 'maxDate'], function(key) {
        if ($attrs[key]) {
          $scope.$parent.$watch($parse($attrs[key]), function(value) {
            self[key] = value ? new Date(value) : null;
            self.refreshView();
          });
        } else {
          self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;
        }
      });
      angular.forEach(['minMode', 'maxMode'], function(key) {
        if ($attrs[key]) {
          $scope.$parent.$watch($parse($attrs[key]), function(value) {
            self[key] = angular.isDefined(value) ? value : $attrs[key];
            $scope[key] = self[key];
            if ((key == 'minMode' && self.modes.indexOf($scope.datepickerMode) < self.modes.indexOf(self[key])) || (key == 'maxMode' && self.modes.indexOf($scope.datepickerMode) > self.modes.indexOf(self[key]))) {
              $scope.datepickerMode = self[key];
            }
          });
        } else {
          self[key] = datepickerConfig[key] || null;
          $scope[key] = self[key];
        }
      });
      $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;
      $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);
      if (angular.isDefined($attrs.initDate)) {
        this.activeDate = $scope.$parent.$eval($attrs.initDate) || new Date();
        $scope.$parent.$watch($attrs.initDate, function(initDate) {
          if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {
            self.activeDate = initDate;
            self.refreshView();
          }
        });
      } else {
        this.activeDate = new Date();
      }
      $scope.isActive = function(dateObject) {
        if (self.compare(dateObject.date, self.activeDate) === 0) {
          $scope.activeDateId = dateObject.uid;
          return true;
        }
        return false;
      };
      this.init = function(ngModelCtrl_) {
        ngModelCtrl = ngModelCtrl_;
        ngModelCtrl.$render = function() {
          self.render();
        };
      };
      this.render = function() {
        if (ngModelCtrl.$viewValue) {
          var date = new Date(ngModelCtrl.$viewValue),
              isValid = !isNaN(date);
          if (isValid) {
            this.activeDate = date;
          } else if (!$datepickerSuppressError) {
            $log.error('Datepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
          }
        }
        this.refreshView();
      };
      this.refreshView = function() {
        if (this.element) {
          this._refreshView();
          var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
          ngModelCtrl.$setValidity('dateDisabled', !date || (this.element && !this.isDisabled(date)));
        }
      };
      this.createDateObject = function(date, format) {
        var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
        return {
          date: date,
          label: dateFilter(date, format),
          selected: model && this.compare(date, model) === 0,
          disabled: this.isDisabled(date),
          current: this.compare(date, new Date()) === 0,
          customClass: this.customClass(date)
        };
      };
      this.isDisabled = function(date) {
        return ((this.minDate && this.compare(date, this.minDate) < 0) || (this.maxDate && this.compare(date, this.maxDate) > 0) || ($attrs.dateDisabled && $scope.dateDisabled({
          date: date,
          mode: $scope.datepickerMode
        })));
      };
      this.customClass = function(date) {
        return $scope.customClass({
          date: date,
          mode: $scope.datepickerMode
        });
      };
      this.split = function(arr, size) {
        var arrays = [];
        while (arr.length > 0) {
          arrays.push(arr.splice(0, size));
        }
        return arrays;
      };
      $scope.select = function(date) {
        if ($scope.datepickerMode === self.minMode) {
          var dt = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : new Date(0, 0, 0, 0, 0, 0, 0);
          dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
          ngModelCtrl.$setViewValue(dt);
          ngModelCtrl.$render();
        } else {
          self.activeDate = date;
          $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1];
        }
      };
      $scope.move = function(direction) {
        var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),
            month = self.activeDate.getMonth() + direction * (self.step.months || 0);
        self.activeDate.setFullYear(year, month, 1);
        self.refreshView();
      };
      $scope.toggleMode = function(direction) {
        direction = direction || 1;
        if (($scope.datepickerMode === self.maxMode && direction === 1) || ($scope.datepickerMode === self.minMode && direction === -1)) {
          return;
        }
        $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction];
      };
      $scope.keys = {
        13: 'enter',
        32: 'space',
        33: 'pageup',
        34: 'pagedown',
        35: 'end',
        36: 'home',
        37: 'left',
        38: 'up',
        39: 'right',
        40: 'down'
      };
      var focusElement = function() {
        self.element[0].focus();
      };
      $scope.$on('uib:datepicker.focus', focusElement);
      $scope.keydown = function(evt) {
        var key = $scope.keys[evt.which];
        if (!key || evt.shiftKey || evt.altKey) {
          return;
        }
        evt.preventDefault();
        if (!self.shortcutPropagation) {
          evt.stopPropagation();
        }
        if (key === 'enter' || key === 'space') {
          if (self.isDisabled(self.activeDate)) {
            return;
          }
          $scope.select(self.activeDate);
        } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {
          $scope.toggleMode(key === 'up' ? 1 : -1);
        } else {
          self.handleKeyDown(key, evt);
          self.refreshView();
        }
      };
    }]).controller('UibDaypickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
      var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      this.step = {months: 1};
      this.element = $element;
      function getDaysInMonth(year, month) {
        return ((month === 1) && (year % 4 === 0) && ((year % 100 !== 0) || (year % 400 === 0))) ? 29 : DAYS_IN_MONTH[month];
      }
      this.init = function(ctrl) {
        angular.extend(ctrl, this);
        scope.showWeeks = ctrl.showWeeks;
        ctrl.refreshView();
      };
      this.getDates = function(startDate, n) {
        var dates = new Array(n),
            current = new Date(startDate),
            i = 0,
            date;
        while (i < n) {
          date = new Date(current);
          dates[i++] = date;
          current.setDate(current.getDate() + 1);
        }
        return dates;
      };
      this._refreshView = function() {
        var year = this.activeDate.getFullYear(),
            month = this.activeDate.getMonth(),
            firstDayOfMonth = new Date(this.activeDate);
        firstDayOfMonth.setFullYear(year, month, 1);
        var difference = this.startingDay - firstDayOfMonth.getDay(),
            numDisplayedFromPreviousMonth = (difference > 0) ? 7 - difference : -difference,
            firstDate = new Date(firstDayOfMonth);
        if (numDisplayedFromPreviousMonth > 0) {
          firstDate.setDate(-numDisplayedFromPreviousMonth + 1);
        }
        var days = this.getDates(firstDate, 42);
        for (var i = 0; i < 42; i++) {
          days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {
            secondary: days[i].getMonth() !== month,
            uid: scope.uniqueId + '-' + i
          });
        }
        scope.labels = new Array(7);
        for (var j = 0; j < 7; j++) {
          scope.labels[j] = {
            abbr: dateFilter(days[j].date, this.formatDayHeader),
            full: dateFilter(days[j].date, 'EEEE')
          };
        }
        scope.title = dateFilter(this.activeDate, this.formatDayTitle);
        scope.rows = this.split(days, 7);
        if (scope.showWeeks) {
          scope.weekNumbers = [];
          var thursdayIndex = (4 + 7 - this.startingDay) % 7,
              numWeeks = scope.rows.length;
          for (var curWeek = 0; curWeek < numWeeks; curWeek++) {
            scope.weekNumbers.push(getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));
          }
        }
      };
      this.compare = function(date1, date2) {
        return (new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate()));
      };
      function getISO8601WeekNumber(date) {
        var checkDate = new Date(date);
        checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
        var time = checkDate.getTime();
        checkDate.setMonth(0);
        checkDate.setDate(1);
        return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
      }
      this.handleKeyDown = function(key, evt) {
        var date = this.activeDate.getDate();
        if (key === 'left') {
          date = date - 1;
        } else if (key === 'up') {
          date = date - 7;
        } else if (key === 'right') {
          date = date + 1;
        } else if (key === 'down') {
          date = date + 7;
        } else if (key === 'pageup' || key === 'pagedown') {
          var month = this.activeDate.getMonth() + (key === 'pageup' ? -1 : 1);
          this.activeDate.setMonth(month, 1);
          date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);
        } else if (key === 'home') {
          date = 1;
        } else if (key === 'end') {
          date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth());
        }
        this.activeDate.setDate(date);
      };
    }]).controller('UibMonthpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
      this.step = {years: 1};
      this.element = $element;
      this.init = function(ctrl) {
        angular.extend(ctrl, this);
        ctrl.refreshView();
      };
      this._refreshView = function() {
        var months = new Array(12),
            year = this.activeDate.getFullYear(),
            date;
        for (var i = 0; i < 12; i++) {
          date = new Date(this.activeDate);
          date.setFullYear(year, i, 1);
          months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {uid: scope.uniqueId + '-' + i});
        }
        scope.title = dateFilter(this.activeDate, this.formatMonthTitle);
        scope.rows = this.split(months, 3);
      };
      this.compare = function(date1, date2) {
        return new Date(date1.getFullYear(), date1.getMonth()) - new Date(date2.getFullYear(), date2.getMonth());
      };
      this.handleKeyDown = function(key, evt) {
        var date = this.activeDate.getMonth();
        if (key === 'left') {
          date = date - 1;
        } else if (key === 'up') {
          date = date - 3;
        } else if (key === 'right') {
          date = date + 1;
        } else if (key === 'down') {
          date = date + 3;
        } else if (key === 'pageup' || key === 'pagedown') {
          var year = this.activeDate.getFullYear() + (key === 'pageup' ? -1 : 1);
          this.activeDate.setFullYear(year);
        } else if (key === 'home') {
          date = 0;
        } else if (key === 'end') {
          date = 11;
        }
        this.activeDate.setMonth(date);
      };
    }]).controller('UibYearpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
      var range;
      this.element = $element;
      function getStartingYear(year) {
        return parseInt((year - 1) / range, 10) * range + 1;
      }
      this.yearpickerInit = function() {
        range = this.yearRange;
        this.step = {years: range};
      };
      this._refreshView = function() {
        var years = new Array(range),
            date;
        for (var i = 0,
            start = getStartingYear(this.activeDate.getFullYear()); i < range; i++) {
          date = new Date(this.activeDate);
          date.setFullYear(start + i, 0, 1);
          years[i] = angular.extend(this.createDateObject(date, this.formatYear), {uid: scope.uniqueId + '-' + i});
        }
        scope.title = [years[0].label, years[range - 1].label].join(' - ');
        scope.rows = this.split(years, 5);
      };
      this.compare = function(date1, date2) {
        return date1.getFullYear() - date2.getFullYear();
      };
      this.handleKeyDown = function(key, evt) {
        var date = this.activeDate.getFullYear();
        if (key === 'left') {
          date = date - 1;
        } else if (key === 'up') {
          date = date - 5;
        } else if (key === 'right') {
          date = date + 1;
        } else if (key === 'down') {
          date = date + 5;
        } else if (key === 'pageup' || key === 'pagedown') {
          date += (key === 'pageup' ? -1 : 1) * this.step.years;
        } else if (key === 'home') {
          date = getStartingYear(this.activeDate.getFullYear());
        } else if (key === 'end') {
          date = getStartingYear(this.activeDate.getFullYear()) + range - 1;
        }
        this.activeDate.setFullYear(date);
      };
    }]).directive('uibDatepicker', function() {
      return {
        replace: true,
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'template/datepicker/datepicker.html';
        },
        scope: {
          datepickerMode: '=?',
          dateDisabled: '&',
          customClass: '&',
          shortcutPropagation: '&?'
        },
        require: ['uibDatepicker', '^ngModel'],
        controller: 'UibDatepickerController',
        controllerAs: 'datepicker',
        link: function(scope, element, attrs, ctrls) {
          var datepickerCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];
          datepickerCtrl.init(ngModelCtrl);
        }
      };
    }).directive('uibDaypicker', function() {
      return {
        replace: true,
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'template/datepicker/day.html';
        },
        require: ['^?uibDatepicker', 'uibDaypicker', '^?datepicker'],
        controller: 'UibDaypickerController',
        link: function(scope, element, attrs, ctrls) {
          var datepickerCtrl = ctrls[0] || ctrls[2],
              daypickerCtrl = ctrls[1];
          daypickerCtrl.init(datepickerCtrl);
        }
      };
    }).directive('uibMonthpicker', function() {
      return {
        replace: true,
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'template/datepicker/month.html';
        },
        require: ['^?uibDatepicker', 'uibMonthpicker', '^?datepicker'],
        controller: 'UibMonthpickerController',
        link: function(scope, element, attrs, ctrls) {
          var datepickerCtrl = ctrls[0] || ctrls[2],
              monthpickerCtrl = ctrls[1];
          monthpickerCtrl.init(datepickerCtrl);
        }
      };
    }).directive('uibYearpicker', function() {
      return {
        replace: true,
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'template/datepicker/year.html';
        },
        require: ['^?uibDatepicker', 'uibYearpicker', '^?datepicker'],
        controller: 'UibYearpickerController',
        link: function(scope, element, attrs, ctrls) {
          var ctrl = ctrls[0] || ctrls[2];
          angular.extend(ctrl, ctrls[1]);
          ctrl.yearpickerInit();
          ctrl.refreshView();
        }
      };
    }).constant('uibDatepickerPopupConfig', {
      datepickerPopup: 'yyyy-MM-dd',
      datepickerPopupTemplateUrl: 'template/datepicker/popup.html',
      datepickerTemplateUrl: 'template/datepicker/datepicker.html',
      html5Types: {
        date: 'yyyy-MM-dd',
        'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',
        'month': 'yyyy-MM'
      },
      currentText: 'Today',
      clearText: 'Clear',
      closeText: 'Done',
      closeOnDateSelection: true,
      appendToBody: false,
      showButtonBar: true,
      onOpenFocus: true
    }).controller('UibDatepickerPopupController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$document', '$rootScope', '$uibPosition', 'dateFilter', 'uibDateParser', 'uibDatepickerPopupConfig', '$timeout', function(scope, element, attrs, $compile, $parse, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout) {
      var self = this;
      var cache = {},
          isHtml5DateInput = false;
      var dateFormat,
          closeOnDateSelection,
          appendToBody,
          onOpenFocus,
          datepickerPopupTemplateUrl,
          datepickerTemplateUrl,
          popupEl,
          datepickerEl,
          ngModel,
          $popup;
      scope.watchData = {};
      this.init = function(_ngModel_) {
        ngModel = _ngModel_;
        closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? scope.$parent.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection;
        appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? scope.$parent.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody;
        onOpenFocus = angular.isDefined(attrs.onOpenFocus) ? scope.$parent.$eval(attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus;
        datepickerPopupTemplateUrl = angular.isDefined(attrs.datepickerPopupTemplateUrl) ? attrs.datepickerPopupTemplateUrl : datepickerPopupConfig.datepickerPopupTemplateUrl;
        datepickerTemplateUrl = angular.isDefined(attrs.datepickerTemplateUrl) ? attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl;
        scope.showButtonBar = angular.isDefined(attrs.showButtonBar) ? scope.$parent.$eval(attrs.showButtonBar) : datepickerPopupConfig.showButtonBar;
        if (datepickerPopupConfig.html5Types[attrs.type]) {
          dateFormat = datepickerPopupConfig.html5Types[attrs.type];
          isHtml5DateInput = true;
        } else {
          dateFormat = attrs.datepickerPopup || attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup;
          attrs.$observe('uibDatepickerPopup', function(value, oldValue) {
            var newDateFormat = value || datepickerPopupConfig.datepickerPopup;
            if (newDateFormat !== dateFormat) {
              dateFormat = newDateFormat;
              ngModel.$modelValue = null;
              if (!dateFormat) {
                throw new Error('uibDatepickerPopup must have a date format specified.');
              }
            }
          });
        }
        if (!dateFormat) {
          throw new Error('uibDatepickerPopup must have a date format specified.');
        }
        if (isHtml5DateInput && attrs.datepickerPopup) {
          throw new Error('HTML5 date input types do not support custom formats.');
        }
        popupEl = angular.element('<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>');
        popupEl.attr({
          'ng-model': 'date',
          'ng-change': 'dateSelection(date)',
          'template-url': datepickerPopupTemplateUrl
        });
        datepickerEl = angular.element(popupEl.children()[0]);
        datepickerEl.attr('template-url', datepickerTemplateUrl);
        if (isHtml5DateInput) {
          if (attrs.type === 'month') {
            datepickerEl.attr('datepicker-mode', '"month"');
            datepickerEl.attr('min-mode', 'month');
          }
        }
        if (attrs.datepickerOptions) {
          var options = scope.$parent.$eval(attrs.datepickerOptions);
          if (options && options.initDate) {
            scope.initDate = options.initDate;
            datepickerEl.attr('init-date', 'initDate');
            delete options.initDate;
          }
          angular.forEach(options, function(value, option) {
            datepickerEl.attr(cameltoDash(option), value);
          });
        }
        angular.forEach(['minMode', 'maxMode', 'minDate', 'maxDate', 'datepickerMode', 'initDate', 'shortcutPropagation'], function(key) {
          if (attrs[key]) {
            var getAttribute = $parse(attrs[key]);
            scope.$parent.$watch(getAttribute, function(value) {
              scope.watchData[key] = value;
              if (key === 'minDate' || key === 'maxDate') {
                cache[key] = new Date(value);
              }
            });
            datepickerEl.attr(cameltoDash(key), 'watchData.' + key);
            if (key === 'datepickerMode') {
              var setAttribute = getAttribute.assign;
              scope.$watch('watchData.' + key, function(value, oldvalue) {
                if (angular.isFunction(setAttribute) && value !== oldvalue) {
                  setAttribute(scope.$parent, value);
                }
              });
            }
          }
        });
        if (attrs.dateDisabled) {
          datepickerEl.attr('date-disabled', 'dateDisabled({ date: date, mode: mode })');
        }
        if (attrs.showWeeks) {
          datepickerEl.attr('show-weeks', attrs.showWeeks);
        }
        if (attrs.customClass) {
          datepickerEl.attr('custom-class', 'customClass({ date: date, mode: mode })');
        }
        if (!isHtml5DateInput) {
          ngModel.$$parserName = 'date';
          ngModel.$validators.date = validator;
          ngModel.$parsers.unshift(parseDate);
          ngModel.$formatters.push(function(value) {
            scope.date = value;
            return ngModel.$isEmpty(value) ? value : dateFilter(value, dateFormat);
          });
        } else {
          ngModel.$formatters.push(function(value) {
            scope.date = value;
            return value;
          });
        }
        ngModel.$viewChangeListeners.push(function() {
          scope.date = dateParser.parse(ngModel.$viewValue, dateFormat, scope.date);
        });
        element.bind('keydown', inputKeydownBind);
        $popup = $compile(popupEl)(scope);
        popupEl.remove();
        if (appendToBody) {
          $document.find('body').append($popup);
        } else {
          element.after($popup);
        }
        scope.$on('$destroy', function() {
          if (scope.isOpen === true) {
            if (!$rootScope.$$phase) {
              scope.$apply(function() {
                scope.isOpen = false;
              });
            }
          }
          $popup.remove();
          element.unbind('keydown', inputKeydownBind);
          $document.unbind('click', documentClickBind);
        });
      };
      scope.getText = function(key) {
        return scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];
      };
      scope.isDisabled = function(date) {
        if (date === 'today') {
          date = new Date();
        }
        return ((scope.watchData.minDate && scope.compare(date, cache.minDate) < 0) || (scope.watchData.maxDate && scope.compare(date, cache.maxDate) > 0));
      };
      scope.compare = function(date1, date2) {
        return (new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate()));
      };
      scope.dateSelection = function(dt) {
        if (angular.isDefined(dt)) {
          scope.date = dt;
        }
        var date = scope.date ? dateFilter(scope.date, dateFormat) : null;
        element.val(date);
        ngModel.$setViewValue(date);
        if (closeOnDateSelection) {
          scope.isOpen = false;
          element[0].focus();
        }
      };
      scope.keydown = function(evt) {
        if (evt.which === 27) {
          scope.isOpen = false;
          element[0].focus();
        }
      };
      scope.select = function(date) {
        if (date === 'today') {
          var today = new Date();
          if (angular.isDate(scope.date)) {
            date = new Date(scope.date);
            date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());
          } else {
            date = new Date(today.setHours(0, 0, 0, 0));
          }
        }
        scope.dateSelection(date);
      };
      scope.close = function() {
        scope.isOpen = false;
        element[0].focus();
      };
      scope.$watch('isOpen', function(value) {
        if (value) {
          scope.position = appendToBody ? $position.offset(element) : $position.position(element);
          scope.position.top = scope.position.top + element.prop('offsetHeight');
          $timeout(function() {
            if (onOpenFocus) {
              scope.$broadcast('uib:datepicker.focus');
            }
            $document.bind('click', documentClickBind);
          }, 0, false);
        } else {
          $document.unbind('click', documentClickBind);
        }
      });
      function cameltoDash(string) {
        return string.replace(/([A-Z])/g, function($1) {
          return '-' + $1.toLowerCase();
        });
      }
      function parseDate(viewValue) {
        if (angular.isNumber(viewValue)) {
          viewValue = new Date(viewValue);
        }
        if (!viewValue) {
          return null;
        } else if (angular.isDate(viewValue) && !isNaN(viewValue)) {
          return viewValue;
        } else if (angular.isString(viewValue)) {
          var date = dateParser.parse(viewValue, dateFormat, scope.date);
          if (isNaN(date)) {
            return undefined;
          } else {
            return date;
          }
        } else {
          return undefined;
        }
      }
      function validator(modelValue, viewValue) {
        var value = modelValue || viewValue;
        if (!attrs.ngRequired && !value) {
          return true;
        }
        if (angular.isNumber(value)) {
          value = new Date(value);
        }
        if (!value) {
          return true;
        } else if (angular.isDate(value) && !isNaN(value)) {
          return true;
        } else if (angular.isString(value)) {
          var date = dateParser.parse(value, dateFormat);
          return !isNaN(date);
        } else {
          return false;
        }
      }
      function documentClickBind(event) {
        var popup = $popup[0];
        var dpContainsTarget = element[0].contains(event.target);
        var popupContainsTarget = popup.contains !== undefined && popup.contains(event.target);
        if (scope.isOpen && !(dpContainsTarget || popupContainsTarget)) {
          scope.$apply(function() {
            scope.isOpen = false;
          });
        }
      }
      function inputKeydownBind(evt) {
        if (evt.which === 27 && scope.isOpen) {
          evt.preventDefault();
          evt.stopPropagation();
          scope.$apply(function() {
            scope.isOpen = false;
          });
          element[0].focus();
        } else if (evt.which === 40 && !scope.isOpen) {
          evt.preventDefault();
          evt.stopPropagation();
          scope.$apply(function() {
            scope.isOpen = true;
          });
        }
      }
    }]).directive('uibDatepickerPopup', function() {
      return {
        require: ['ngModel', 'uibDatepickerPopup'],
        controller: 'UibDatepickerPopupController',
        scope: {
          isOpen: '=?',
          currentText: '@',
          clearText: '@',
          closeText: '@',
          dateDisabled: '&',
          customClass: '&'
        },
        link: function(scope, element, attrs, ctrls) {
          var ngModel = ctrls[0],
              ctrl = ctrls[1];
          ctrl.init(ngModel);
        }
      };
    }).directive('uibDatepickerPopupWrap', function() {
      return {
        replace: true,
        transclude: true,
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'template/datepicker/popup.html';
        }
      };
    });
    angular.module('ui.bootstrap.datepicker').value('$datepickerSuppressWarning', false).controller('DatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerSuppressError', '$datepickerSuppressWarning', function($scope, $attrs, $parse, $interpolate, $log, dateFilter, datepickerConfig, $datepickerSuppressError, $datepickerSuppressWarning) {
      if (!$datepickerSuppressWarning) {
        $log.warn('DatepickerController is now deprecated. Use UibDatepickerController instead.');
      }
      var self = this,
          ngModelCtrl = {$setViewValue: angular.noop};
      this.modes = ['day', 'month', 'year'];
      angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle', 'showWeeks', 'startingDay', 'yearRange', 'shortcutPropagation'], function(key, index) {
        self[key] = angular.isDefined($attrs[key]) ? (index < 6 ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key])) : datepickerConfig[key];
      });
      angular.forEach(['minDate', 'maxDate'], function(key) {
        if ($attrs[key]) {
          $scope.$parent.$watch($parse($attrs[key]), function(value) {
            self[key] = value ? new Date(value) : null;
            self.refreshView();
          });
        } else {
          self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;
        }
      });
      angular.forEach(['minMode', 'maxMode'], function(key) {
        if ($attrs[key]) {
          $scope.$parent.$watch($parse($attrs[key]), function(value) {
            self[key] = angular.isDefined(value) ? value : $attrs[key];
            $scope[key] = self[key];
            if ((key == 'minMode' && self.modes.indexOf($scope.datepickerMode) < self.modes.indexOf(self[key])) || (key == 'maxMode' && self.modes.indexOf($scope.datepickerMode) > self.modes.indexOf(self[key]))) {
              $scope.datepickerMode = self[key];
            }
          });
        } else {
          self[key] = datepickerConfig[key] || null;
          $scope[key] = self[key];
        }
      });
      $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;
      $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);
      if (angular.isDefined($attrs.initDate)) {
        this.activeDate = $scope.$parent.$eval($attrs.initDate) || new Date();
        $scope.$parent.$watch($attrs.initDate, function(initDate) {
          if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {
            self.activeDate = initDate;
            self.refreshView();
          }
        });
      } else {
        this.activeDate = new Date();
      }
      $scope.isActive = function(dateObject) {
        if (self.compare(dateObject.date, self.activeDate) === 0) {
          $scope.activeDateId = dateObject.uid;
          return true;
        }
        return false;
      };
      this.init = function(ngModelCtrl_) {
        ngModelCtrl = ngModelCtrl_;
        ngModelCtrl.$render = function() {
          self.render();
        };
      };
      this.render = function() {
        if (ngModelCtrl.$viewValue) {
          var date = new Date(ngModelCtrl.$viewValue),
              isValid = !isNaN(date);
          if (isValid) {
            this.activeDate = date;
          } else if (!$datepickerSuppressError) {
            $log.error('Datepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
          }
        }
        this.refreshView();
      };
      this.refreshView = function() {
        if (this.element) {
          this._refreshView();
          var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
          ngModelCtrl.$setValidity('dateDisabled', !date || (this.element && !this.isDisabled(date)));
        }
      };
      this.createDateObject = function(date, format) {
        var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
        return {
          date: date,
          label: dateFilter(date, format),
          selected: model && this.compare(date, model) === 0,
          disabled: this.isDisabled(date),
          current: this.compare(date, new Date()) === 0,
          customClass: this.customClass(date)
        };
      };
      this.isDisabled = function(date) {
        return ((this.minDate && this.compare(date, this.minDate) < 0) || (this.maxDate && this.compare(date, this.maxDate) > 0) || ($attrs.dateDisabled && $scope.dateDisabled({
          date: date,
          mode: $scope.datepickerMode
        })));
      };
      this.customClass = function(date) {
        return $scope.customClass({
          date: date,
          mode: $scope.datepickerMode
        });
      };
      this.split = function(arr, size) {
        var arrays = [];
        while (arr.length > 0) {
          arrays.push(arr.splice(0, size));
        }
        return arrays;
      };
      this.fixTimeZone = function(date) {
        var hours = date.getHours();
        date.setHours(hours === 23 ? hours + 2 : 0);
      };
      $scope.select = function(date) {
        if ($scope.datepickerMode === self.minMode) {
          var dt = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : new Date(0, 0, 0, 0, 0, 0, 0);
          dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
          ngModelCtrl.$setViewValue(dt);
          ngModelCtrl.$render();
        } else {
          self.activeDate = date;
          $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1];
        }
      };
      $scope.move = function(direction) {
        var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),
            month = self.activeDate.getMonth() + direction * (self.step.months || 0);
        self.activeDate.setFullYear(year, month, 1);
        self.refreshView();
      };
      $scope.toggleMode = function(direction) {
        direction = direction || 1;
        if (($scope.datepickerMode === self.maxMode && direction === 1) || ($scope.datepickerMode === self.minMode && direction === -1)) {
          return;
        }
        $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction];
      };
      $scope.keys = {
        13: 'enter',
        32: 'space',
        33: 'pageup',
        34: 'pagedown',
        35: 'end',
        36: 'home',
        37: 'left',
        38: 'up',
        39: 'right',
        40: 'down'
      };
      var focusElement = function() {
        self.element[0].focus();
      };
      $scope.$on('uib:datepicker.focus', focusElement);
      $scope.keydown = function(evt) {
        var key = $scope.keys[evt.which];
        if (!key || evt.shiftKey || evt.altKey) {
          return;
        }
        evt.preventDefault();
        if (!self.shortcutPropagation) {
          evt.stopPropagation();
        }
        if (key === 'enter' || key === 'space') {
          if (self.isDisabled(self.activeDate)) {
            return;
          }
          $scope.select(self.activeDate);
        } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {
          $scope.toggleMode(key === 'up' ? 1 : -1);
        } else {
          self.handleKeyDown(key, evt);
          self.refreshView();
        }
      };
    }]).directive('datepicker', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {
      return {
        replace: true,
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'template/datepicker/datepicker.html';
        },
        scope: {
          datepickerMode: '=?',
          dateDisabled: '&',
          customClass: '&',
          shortcutPropagation: '&?'
        },
        require: ['datepicker', '^ngModel'],
        controller: 'DatepickerController',
        controllerAs: 'datepicker',
        link: function(scope, element, attrs, ctrls) {
          if (!$datepickerSuppressWarning) {
            $log.warn('datepicker is now deprecated. Use uib-datepicker instead.');
          }
          var datepickerCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];
          datepickerCtrl.init(ngModelCtrl);
        }
      };
    }]).directive('daypicker', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {
      return {
        replace: true,
        templateUrl: 'template/datepicker/day.html',
        require: ['^datepicker', 'daypicker'],
        controller: 'UibDaypickerController',
        link: function(scope, element, attrs, ctrls) {
          if (!$datepickerSuppressWarning) {
            $log.warn('daypicker is now deprecated. Use uib-daypicker instead.');
          }
          var datepickerCtrl = ctrls[0],
              daypickerCtrl = ctrls[1];
          daypickerCtrl.init(datepickerCtrl);
        }
      };
    }]).directive('monthpicker', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {
      return {
        replace: true,
        templateUrl: 'template/datepicker/month.html',
        require: ['^datepicker', 'monthpicker'],
        controller: 'UibMonthpickerController',
        link: function(scope, element, attrs, ctrls) {
          if (!$datepickerSuppressWarning) {
            $log.warn('monthpicker is now deprecated. Use uib-monthpicker instead.');
          }
          var datepickerCtrl = ctrls[0],
              monthpickerCtrl = ctrls[1];
          monthpickerCtrl.init(datepickerCtrl);
        }
      };
    }]).directive('yearpicker', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {
      return {
        replace: true,
        templateUrl: 'template/datepicker/year.html',
        require: ['^datepicker', 'yearpicker'],
        controller: 'UibYearpickerController',
        link: function(scope, element, attrs, ctrls) {
          if (!$datepickerSuppressWarning) {
            $log.warn('yearpicker is now deprecated. Use uib-yearpicker instead.');
          }
          var ctrl = ctrls[0];
          angular.extend(ctrl, ctrls[1]);
          ctrl.yearpickerInit();
          ctrl.refreshView();
        }
      };
    }]).directive('datepickerPopup', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {
      return {
        require: ['ngModel', 'datepickerPopup'],
        controller: 'UibDatepickerPopupController',
        scope: {
          isOpen: '=?',
          currentText: '@',
          clearText: '@',
          closeText: '@',
          dateDisabled: '&',
          customClass: '&'
        },
        link: function(scope, element, attrs, ctrls) {
          if (!$datepickerSuppressWarning) {
            $log.warn('datepicker-popup is now deprecated. Use uib-datepicker-popup instead.');
          }
          var ngModel = ctrls[0],
              ctrl = ctrls[1];
          ctrl.init(ngModel);
        }
      };
    }]).directive('datepickerPopupWrap', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {
      return {
        replace: true,
        transclude: true,
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'template/datepicker/popup.html';
        },
        link: function() {
          if (!$datepickerSuppressWarning) {
            $log.warn('datepicker-popup-wrap is now deprecated. Use uib-datepicker-popup-wrap instead.');
          }
        }
      };
    }]);
    angular.module('ui.bootstrap.dropdown', ['ui.bootstrap.position']).constant('uibDropdownConfig', {openClass: 'open'}).service('uibDropdownService', ['$document', '$rootScope', function($document, $rootScope) {
      var openScope = null;
      this.open = function(dropdownScope) {
        if (!openScope) {
          $document.bind('click', closeDropdown);
          $document.bind('keydown', keybindFilter);
        }
        if (openScope && openScope !== dropdownScope) {
          openScope.isOpen = false;
        }
        openScope = dropdownScope;
      };
      this.close = function(dropdownScope) {
        if (openScope === dropdownScope) {
          openScope = null;
          $document.unbind('click', closeDropdown);
          $document.unbind('keydown', keybindFilter);
        }
      };
      var closeDropdown = function(evt) {
        if (!openScope) {
          return;
        }
        if (evt && openScope.getAutoClose() === 'disabled') {
          return;
        }
        var toggleElement = openScope.getToggleElement();
        if (evt && toggleElement && toggleElement[0].contains(evt.target)) {
          return;
        }
        var dropdownElement = openScope.getDropdownElement();
        if (evt && openScope.getAutoClose() === 'outsideClick' && dropdownElement && dropdownElement[0].contains(evt.target)) {
          return;
        }
        openScope.isOpen = false;
        if (!$rootScope.$$phase) {
          openScope.$apply();
        }
      };
      var keybindFilter = function(evt) {
        if (evt.which === 27) {
          openScope.focusToggleElement();
          closeDropdown();
        } else if (openScope.isKeynavEnabled() && /(38|40)/.test(evt.which) && openScope.isOpen) {
          evt.preventDefault();
          evt.stopPropagation();
          openScope.focusDropdownEntry(evt.which);
        }
      };
    }]).controller('UibDropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {
      var self = this,
          scope = $scope.$new(),
          templateScope,
          openClass = dropdownConfig.openClass,
          getIsOpen,
          setIsOpen = angular.noop,
          toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,
          appendToBody = false,
          keynavEnabled = false,
          selectedOption = null;
      $element.addClass('dropdown');
      this.init = function() {
        if ($attrs.isOpen) {
          getIsOpen = $parse($attrs.isOpen);
          setIsOpen = getIsOpen.assign;
          $scope.$watch(getIsOpen, function(value) {
            scope.isOpen = !!value;
          });
        }
        appendToBody = angular.isDefined($attrs.dropdownAppendToBody);
        keynavEnabled = angular.isDefined($attrs.uibKeyboardNav);
        if (appendToBody && self.dropdownMenu) {
          $document.find('body').append(self.dropdownMenu);
          $element.on('$destroy', function handleDestroyEvent() {
            self.dropdownMenu.remove();
          });
        }
      };
      this.toggle = function(open) {
        return scope.isOpen = arguments.length ? !!open : !scope.isOpen;
      };
      this.isOpen = function() {
        return scope.isOpen;
      };
      scope.getToggleElement = function() {
        return self.toggleElement;
      };
      scope.getAutoClose = function() {
        return $attrs.autoClose || 'always';
      };
      scope.getElement = function() {
        return $element;
      };
      scope.isKeynavEnabled = function() {
        return keynavEnabled;
      };
      scope.focusDropdownEntry = function(keyCode) {
        var elems = self.dropdownMenu ? (angular.element(self.dropdownMenu).find('a')) : (angular.element($element).find('ul').eq(0).find('a'));
        switch (keyCode) {
          case (40):
            {
              if (!angular.isNumber(self.selectedOption)) {
                self.selectedOption = 0;
              } else {
                self.selectedOption = (self.selectedOption === elems.length - 1 ? self.selectedOption : self.selectedOption + 1);
              }
              break;
            }
          case (38):
            {
              if (!angular.isNumber(self.selectedOption)) {
                self.selectedOption = elems.length - 1;
              } else {
                self.selectedOption = self.selectedOption === 0 ? 0 : self.selectedOption - 1;
              }
              break;
            }
        }
        elems[self.selectedOption].focus();
      };
      scope.getDropdownElement = function() {
        return self.dropdownMenu;
      };
      scope.focusToggleElement = function() {
        if (self.toggleElement) {
          self.toggleElement[0].focus();
        }
      };
      scope.$watch('isOpen', function(isOpen, wasOpen) {
        if (appendToBody && self.dropdownMenu) {
          var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true);
          var css = {
            top: pos.top + 'px',
            display: isOpen ? 'block' : 'none'
          };
          var rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');
          if (!rightalign) {
            css.left = pos.left + 'px';
            css.right = 'auto';
          } else {
            css.left = 'auto';
            css.right = (window.innerWidth - (pos.left + $element.prop('offsetWidth'))) + 'px';
          }
          self.dropdownMenu.css(css);
        }
        $animate[isOpen ? 'addClass' : 'removeClass']($element, openClass).then(function() {
          if (angular.isDefined(isOpen) && isOpen !== wasOpen) {
            toggleInvoker($scope, {open: !!isOpen});
          }
        });
        if (isOpen) {
          if (self.dropdownMenuTemplateUrl) {
            $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {
              templateScope = scope.$new();
              $compile(tplContent.trim())(templateScope, function(dropdownElement) {
                var newEl = dropdownElement;
                self.dropdownMenu.replaceWith(newEl);
                self.dropdownMenu = newEl;
              });
            });
          }
          scope.focusToggleElement();
          uibDropdownService.open(scope);
        } else {
          if (self.dropdownMenuTemplateUrl) {
            if (templateScope) {
              templateScope.$destroy();
            }
            var newEl = angular.element('<ul class="dropdown-menu"></ul>');
            self.dropdownMenu.replaceWith(newEl);
            self.dropdownMenu = newEl;
          }
          uibDropdownService.close(scope);
          self.selectedOption = null;
        }
        if (angular.isFunction(setIsOpen)) {
          setIsOpen($scope, isOpen);
        }
      });
      $scope.$on('$locationChangeSuccess', function() {
        if (scope.getAutoClose() !== 'disabled') {
          scope.isOpen = false;
        }
      });
      var offDestroy = $scope.$on('$destroy', function() {
        scope.$destroy();
      });
      scope.$on('$destroy', offDestroy);
    }]).directive('uibDropdown', function() {
      return {
        controller: 'UibDropdownController',
        link: function(scope, element, attrs, dropdownCtrl) {
          dropdownCtrl.init();
        }
      };
    }).directive('uibDropdownMenu', function() {
      return {
        restrict: 'AC',
        require: '?^uibDropdown',
        link: function(scope, element, attrs, dropdownCtrl) {
          if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {
            return;
          }
          element.addClass('dropdown-menu');
          var tplUrl = attrs.templateUrl;
          if (tplUrl) {
            dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;
          }
          if (!dropdownCtrl.dropdownMenu) {
            dropdownCtrl.dropdownMenu = element;
          }
        }
      };
    }).directive('uibKeyboardNav', function() {
      return {
        restrict: 'A',
        require: '?^uibDropdown',
        link: function(scope, element, attrs, dropdownCtrl) {
          element.bind('keydown', function(e) {
            if ([38, 40].indexOf(e.which) !== -1) {
              e.preventDefault();
              e.stopPropagation();
              var elems = dropdownCtrl.dropdownMenu.find('a');
              switch (e.which) {
                case (40):
                  {
                    if (!angular.isNumber(dropdownCtrl.selectedOption)) {
                      dropdownCtrl.selectedOption = 0;
                    } else {
                      dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === elems.length - 1 ? dropdownCtrl.selectedOption : dropdownCtrl.selectedOption + 1;
                    }
                    break;
                  }
                case (38):
                  {
                    if (!angular.isNumber(dropdownCtrl.selectedOption)) {
                      dropdownCtrl.selectedOption = elems.length - 1;
                    } else {
                      dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === 0 ? 0 : dropdownCtrl.selectedOption - 1;
                    }
                    break;
                  }
              }
              elems[dropdownCtrl.selectedOption].focus();
            }
          });
        }
      };
    }).directive('uibDropdownToggle', function() {
      return {
        require: '?^uibDropdown',
        link: function(scope, element, attrs, dropdownCtrl) {
          if (!dropdownCtrl) {
            return;
          }
          element.addClass('dropdown-toggle');
          dropdownCtrl.toggleElement = element;
          var toggleDropdown = function(event) {
            event.preventDefault();
            if (!element.hasClass('disabled') && !attrs.disabled) {
              scope.$apply(function() {
                dropdownCtrl.toggle();
              });
            }
          };
          element.bind('click', toggleDropdown);
          element.attr({
            'aria-haspopup': true,
            'aria-expanded': false
          });
          scope.$watch(dropdownCtrl.isOpen, function(isOpen) {
            element.attr('aria-expanded', !!isOpen);
          });
          scope.$on('$destroy', function() {
            element.unbind('click', toggleDropdown);
          });
        }
      };
    });
    angular.module('ui.bootstrap.dropdown').value('$dropdownSuppressWarning', false).service('dropdownService', ['$log', '$dropdownSuppressWarning', 'uibDropdownService', function($log, $dropdownSuppressWarning, uibDropdownService) {
      if (!$dropdownSuppressWarning) {
        $log.warn('dropdownService is now deprecated. Use uibDropdownService instead.');
      }
      angular.extend(this, uibDropdownService);
    }]).controller('DropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', '$log', '$dropdownSuppressWarning', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest, $log, $dropdownSuppressWarning) {
      if (!$dropdownSuppressWarning) {
        $log.warn('DropdownController is now deprecated. Use UibDropdownController instead.');
      }
      var self = this,
          scope = $scope.$new(),
          templateScope,
          openClass = dropdownConfig.openClass,
          getIsOpen,
          setIsOpen = angular.noop,
          toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,
          appendToBody = false,
          keynavEnabled = false,
          selectedOption = null;
      $element.addClass('dropdown');
      this.init = function() {
        if ($attrs.isOpen) {
          getIsOpen = $parse($attrs.isOpen);
          setIsOpen = getIsOpen.assign;
          $scope.$watch(getIsOpen, function(value) {
            scope.isOpen = !!value;
          });
        }
        appendToBody = angular.isDefined($attrs.dropdownAppendToBody);
        keynavEnabled = angular.isDefined($attrs.uibKeyboardNav);
        if (appendToBody && self.dropdownMenu) {
          $document.find('body').append(self.dropdownMenu);
          $element.on('$destroy', function handleDestroyEvent() {
            self.dropdownMenu.remove();
          });
        }
      };
      this.toggle = function(open) {
        return scope.isOpen = arguments.length ? !!open : !scope.isOpen;
      };
      this.isOpen = function() {
        return scope.isOpen;
      };
      scope.getToggleElement = function() {
        return self.toggleElement;
      };
      scope.getAutoClose = function() {
        return $attrs.autoClose || 'always';
      };
      scope.getElement = function() {
        return $element;
      };
      scope.isKeynavEnabled = function() {
        return keynavEnabled;
      };
      scope.focusDropdownEntry = function(keyCode) {
        var elems = self.dropdownMenu ? (angular.element(self.dropdownMenu).find('a')) : (angular.element($element).find('ul').eq(0).find('a'));
        switch (keyCode) {
          case (40):
            {
              if (!angular.isNumber(self.selectedOption)) {
                self.selectedOption = 0;
              } else {
                self.selectedOption = (self.selectedOption === elems.length - 1 ? self.selectedOption : self.selectedOption + 1);
              }
              break;
            }
          case (38):
            {
              if (!angular.isNumber(self.selectedOption)) {
                self.selectedOption = elems.length - 1;
              } else {
                self.selectedOption = self.selectedOption === 0 ? 0 : self.selectedOption - 1;
              }
              break;
            }
        }
        elems[self.selectedOption].focus();
      };
      scope.getDropdownElement = function() {
        return self.dropdownMenu;
      };
      scope.focusToggleElement = function() {
        if (self.toggleElement) {
          self.toggleElement[0].focus();
        }
      };
      scope.$watch('isOpen', function(isOpen, wasOpen) {
        if (appendToBody && self.dropdownMenu) {
          var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true);
          var css = {
            top: pos.top + 'px',
            display: isOpen ? 'block' : 'none'
          };
          var rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');
          if (!rightalign) {
            css.left = pos.left + 'px';
            css.right = 'auto';
          } else {
            css.left = 'auto';
            css.right = (window.innerWidth - (pos.left + $element.prop('offsetWidth'))) + 'px';
          }
          self.dropdownMenu.css(css);
        }
        $animate[isOpen ? 'addClass' : 'removeClass']($element, openClass).then(function() {
          if (angular.isDefined(isOpen) && isOpen !== wasOpen) {
            toggleInvoker($scope, {open: !!isOpen});
          }
        });
        if (isOpen) {
          if (self.dropdownMenuTemplateUrl) {
            $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {
              templateScope = scope.$new();
              $compile(tplContent.trim())(templateScope, function(dropdownElement) {
                var newEl = dropdownElement;
                self.dropdownMenu.replaceWith(newEl);
                self.dropdownMenu = newEl;
              });
            });
          }
          scope.focusToggleElement();
          uibDropdownService.open(scope);
        } else {
          if (self.dropdownMenuTemplateUrl) {
            if (templateScope) {
              templateScope.$destroy();
            }
            var newEl = angular.element('<ul class="dropdown-menu"></ul>');
            self.dropdownMenu.replaceWith(newEl);
            self.dropdownMenu = newEl;
          }
          uibDropdownService.close(scope);
          self.selectedOption = null;
        }
        if (angular.isFunction(setIsOpen)) {
          setIsOpen($scope, isOpen);
        }
      });
      $scope.$on('$locationChangeSuccess', function() {
        if (scope.getAutoClose() !== 'disabled') {
          scope.isOpen = false;
        }
      });
      var offDestroy = $scope.$on('$destroy', function() {
        scope.$destroy();
      });
      scope.$on('$destroy', offDestroy);
    }]).directive('dropdown', ['$log', '$dropdownSuppressWarning', function($log, $dropdownSuppressWarning) {
      return {
        controller: 'DropdownController',
        link: function(scope, element, attrs, dropdownCtrl) {
          if (!$dropdownSuppressWarning) {
            $log.warn('dropdown is now deprecated. Use uib-dropdown instead.');
          }
          dropdownCtrl.init();
        }
      };
    }]).directive('dropdownMenu', ['$log', '$dropdownSuppressWarning', function($log, $dropdownSuppressWarning) {
      return {
        restrict: 'AC',
        require: '?^dropdown',
        link: function(scope, element, attrs, dropdownCtrl) {
          if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {
            return;
          }
          if (!$dropdownSuppressWarning) {
            $log.warn('dropdown-menu is now deprecated. Use uib-dropdown-menu instead.');
          }
          element.addClass('dropdown-menu');
          var tplUrl = attrs.templateUrl;
          if (tplUrl) {
            dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;
          }
          if (!dropdownCtrl.dropdownMenu) {
            dropdownCtrl.dropdownMenu = element;
          }
        }
      };
    }]).directive('keyboardNav', ['$log', '$dropdownSuppressWarning', function($log, $dropdownSuppressWarning) {
      return {
        restrict: 'A',
        require: '?^dropdown',
        link: function(scope, element, attrs, dropdownCtrl) {
          if (!$dropdownSuppressWarning) {
            $log.warn('keyboard-nav is now deprecated. Use uib-keyboard-nav instead.');
          }
          element.bind('keydown', function(e) {
            if ([38, 40].indexOf(e.which) !== -1) {
              e.preventDefault();
              e.stopPropagation();
              var elems = dropdownCtrl.dropdownMenu.find('a');
              switch (e.which) {
                case (40):
                  {
                    if (!angular.isNumber(dropdownCtrl.selectedOption)) {
                      dropdownCtrl.selectedOption = 0;
                    } else {
                      dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === elems.length - 1 ? dropdownCtrl.selectedOption : dropdownCtrl.selectedOption + 1;
                    }
                    break;
                  }
                case (38):
                  {
                    if (!angular.isNumber(dropdownCtrl.selectedOption)) {
                      dropdownCtrl.selectedOption = elems.length - 1;
                    } else {
                      dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === 0 ? 0 : dropdownCtrl.selectedOption - 1;
                    }
                    break;
                  }
              }
              elems[dropdownCtrl.selectedOption].focus();
            }
          });
        }
      };
    }]).directive('dropdownToggle', ['$log', '$dropdownSuppressWarning', function($log, $dropdownSuppressWarning) {
      return {
        require: '?^dropdown',
        link: function(scope, element, attrs, dropdownCtrl) {
          if (!$dropdownSuppressWarning) {
            $log.warn('dropdown-toggle is now deprecated. Use uib-dropdown-toggle instead.');
          }
          if (!dropdownCtrl) {
            return;
          }
          element.addClass('dropdown-toggle');
          dropdownCtrl.toggleElement = element;
          var toggleDropdown = function(event) {
            event.preventDefault();
            if (!element.hasClass('disabled') && !attrs.disabled) {
              scope.$apply(function() {
                dropdownCtrl.toggle();
              });
            }
          };
          element.bind('click', toggleDropdown);
          element.attr({
            'aria-haspopup': true,
            'aria-expanded': false
          });
          scope.$watch(dropdownCtrl.isOpen, function(isOpen) {
            element.attr('aria-expanded', !!isOpen);
          });
          scope.$on('$destroy', function() {
            element.unbind('click', toggleDropdown);
          });
        }
      };
    }]);
    angular.module('ui.bootstrap.stackedMap', []).factory('$$stackedMap', function() {
      return {createNew: function() {
          var stack = [];
          return {
            add: function(key, value) {
              stack.push({
                key: key,
                value: value
              });
            },
            get: function(key) {
              for (var i = 0; i < stack.length; i++) {
                if (key == stack[i].key) {
                  return stack[i];
                }
              }
            },
            keys: function() {
              var keys = [];
              for (var i = 0; i < stack.length; i++) {
                keys.push(stack[i].key);
              }
              return keys;
            },
            top: function() {
              return stack[stack.length - 1];
            },
            remove: function(key) {
              var idx = -1;
              for (var i = 0; i < stack.length; i++) {
                if (key == stack[i].key) {
                  idx = i;
                  break;
                }
              }
              return stack.splice(idx, 1)[0];
            },
            removeTop: function() {
              return stack.splice(stack.length - 1, 1)[0];
            },
            length: function() {
              return stack.length;
            }
          };
        }};
    });
    angular.module('ui.bootstrap.modal', ['ui.bootstrap.stackedMap']).factory('$$multiMap', function() {
      return {createNew: function() {
          var map = {};
          return {
            entries: function() {
              return Object.keys(map).map(function(key) {
                return {
                  key: key,
                  value: map[key]
                };
              });
            },
            get: function(key) {
              return map[key];
            },
            hasKey: function(key) {
              return !!map[key];
            },
            keys: function() {
              return Object.keys(map);
            },
            put: function(key, value) {
              if (!map[key]) {
                map[key] = [];
              }
              map[key].push(value);
            },
            remove: function(key, value) {
              var values = map[key];
              if (!values) {
                return;
              }
              var idx = values.indexOf(value);
              if (idx !== -1) {
                values.splice(idx, 1);
              }
              if (!values.length) {
                delete map[key];
              }
            }
          };
        }};
    }).directive('uibModalBackdrop', ['$animate', '$injector', '$uibModalStack', function($animate, $injector, $modalStack) {
      var $animateCss = null;
      if ($injector.has('$animateCss')) {
        $animateCss = $injector.get('$animateCss');
      }
      return {
        replace: true,
        templateUrl: 'template/modal/backdrop.html',
        compile: function(tElement, tAttrs) {
          tElement.addClass(tAttrs.backdropClass);
          return linkFn;
        }
      };
      function linkFn(scope, element, attrs) {
        element.addClass('modal-backdrop');
        if (attrs.modalInClass) {
          if ($animateCss) {
            $animateCss(element, {addClass: attrs.modalInClass}).start();
          } else {
            $animate.addClass(element, attrs.modalInClass);
          }
          scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
            var done = setIsAsync();
            if ($animateCss) {
              $animateCss(element, {removeClass: attrs.modalInClass}).start().then(done);
            } else {
              $animate.removeClass(element, attrs.modalInClass).then(done);
            }
          });
        }
      }
    }]).directive('uibModalWindow', ['$uibModalStack', '$q', '$animate', '$injector', function($modalStack, $q, $animate, $injector) {
      var $animateCss = null;
      if ($injector.has('$animateCss')) {
        $animateCss = $injector.get('$animateCss');
      }
      return {
        scope: {index: '@'},
        replace: true,
        transclude: true,
        templateUrl: function(tElement, tAttrs) {
          return tAttrs.templateUrl || 'template/modal/window.html';
        },
        link: function(scope, element, attrs) {
          element.addClass(attrs.windowClass || '');
          element.addClass(attrs.windowTopClass || '');
          scope.size = attrs.size;
          scope.close = function(evt) {
            var modal = $modalStack.getTop();
            if (modal && modal.value.backdrop && modal.value.backdrop !== 'static' && (evt.target === evt.currentTarget)) {
              evt.preventDefault();
              evt.stopPropagation();
              $modalStack.dismiss(modal.key, 'backdrop click');
            }
          };
          element.on('click', scope.close);
          scope.$isRendered = true;
          var modalRenderDeferObj = $q.defer();
          attrs.$observe('modalRender', function(value) {
            if (value == 'true') {
              modalRenderDeferObj.resolve();
            }
          });
          modalRenderDeferObj.promise.then(function() {
            var animationPromise = null;
            if (attrs.modalInClass) {
              if ($animateCss) {
                animationPromise = $animateCss(element, {addClass: attrs.modalInClass}).start();
              } else {
                animationPromise = $animate.addClass(element, attrs.modalInClass);
              }
              scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
                var done = setIsAsync();
                if ($animateCss) {
                  $animateCss(element, {removeClass: attrs.modalInClass}).start().then(done);
                } else {
                  $animate.removeClass(element, attrs.modalInClass).then(done);
                }
              });
            }
            $q.when(animationPromise).then(function() {
              var inputWithAutofocus = element[0].querySelector('[autofocus]');
              if (inputWithAutofocus) {
                inputWithAutofocus.focus();
              } else {
                element[0].focus();
              }
            });
            var modal = $modalStack.getTop();
            if (modal) {
              $modalStack.modalRendered(modal.key);
            }
          });
        }
      };
    }]).directive('uibModalAnimationClass', function() {
      return {compile: function(tElement, tAttrs) {
          if (tAttrs.modalAnimation) {
            tElement.addClass(tAttrs.uibModalAnimationClass);
          }
        }};
    }).directive('uibModalTransclude', function() {
      return {link: function($scope, $element, $attrs, controller, $transclude) {
          $transclude($scope.$parent, function(clone) {
            $element.empty();
            $element.append(clone);
          });
        }};
    }).factory('$uibModalStack', ['$animate', '$timeout', '$document', '$compile', '$rootScope', '$q', '$injector', '$$multiMap', '$$stackedMap', function($animate, $timeout, $document, $compile, $rootScope, $q, $injector, $$multiMap, $$stackedMap) {
      var $animateCss = null;
      if ($injector.has('$animateCss')) {
        $animateCss = $injector.get('$animateCss');
      }
      var OPENED_MODAL_CLASS = 'modal-open';
      var backdropDomEl,
          backdropScope;
      var openedWindows = $$stackedMap.createNew();
      var openedClasses = $$multiMap.createNew();
      var $modalStack = {NOW_CLOSING_EVENT: 'modal.stack.now-closing'};
      var focusableElementList;
      var focusIndex = 0;
      var tababbleSelector = 'a[href], area[href], input:not([disabled]), ' + 'button:not([disabled]),select:not([disabled]), textarea:not([disabled]), ' + 'iframe, object, embed, *[tabindex], *[contenteditable=true]';
      function backdropIndex() {
        var topBackdropIndex = -1;
        var opened = openedWindows.keys();
        for (var i = 0; i < opened.length; i++) {
          if (openedWindows.get(opened[i]).value.backdrop) {
            topBackdropIndex = i;
          }
        }
        return topBackdropIndex;
      }
      $rootScope.$watch(backdropIndex, function(newBackdropIndex) {
        if (backdropScope) {
          backdropScope.index = newBackdropIndex;
        }
      });
      function removeModalWindow(modalInstance, elementToReceiveFocus) {
        var body = $document.find('body').eq(0);
        var modalWindow = openedWindows.get(modalInstance).value;
        openedWindows.remove(modalInstance);
        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {
          var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;
          openedClasses.remove(modalBodyClass, modalInstance);
          body.toggleClass(modalBodyClass, openedClasses.hasKey(modalBodyClass));
          toggleTopWindowClass(true);
        });
        checkRemoveBackdrop();
        if (elementToReceiveFocus && elementToReceiveFocus.focus) {
          elementToReceiveFocus.focus();
        } else {
          body.focus();
        }
      }
      function toggleTopWindowClass(toggleSwitch) {
        var modalWindow;
        if (openedWindows.length() > 0) {
          modalWindow = openedWindows.top().value;
          modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || '', toggleSwitch);
        }
      }
      function checkRemoveBackdrop() {
        if (backdropDomEl && backdropIndex() == -1) {
          var backdropScopeRef = backdropScope;
          removeAfterAnimate(backdropDomEl, backdropScope, function() {
            backdropScopeRef = null;
          });
          backdropDomEl = undefined;
          backdropScope = undefined;
        }
      }
      function removeAfterAnimate(domEl, scope, done) {
        var asyncDeferred;
        var asyncPromise = null;
        var setIsAsync = function() {
          if (!asyncDeferred) {
            asyncDeferred = $q.defer();
            asyncPromise = asyncDeferred.promise;
          }
          return function asyncDone() {
            asyncDeferred.resolve();
          };
        };
        scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);
        return $q.when(asyncPromise).then(afterAnimating);
        function afterAnimating() {
          if (afterAnimating.done) {
            return;
          }
          afterAnimating.done = true;
          if ($animateCss) {
            $animateCss(domEl, {event: 'leave'}).start().then(function() {
              domEl.remove();
            });
          } else {
            $animate.leave(domEl);
          }
          scope.$destroy();
          if (done) {
            done();
          }
        }
      }
      $document.bind('keydown', function(evt) {
        if (evt.isDefaultPrevented()) {
          return evt;
        }
        var modal = openedWindows.top();
        if (modal && modal.value.keyboard) {
          switch (evt.which) {
            case 27:
              {
                evt.preventDefault();
                $rootScope.$apply(function() {
                  $modalStack.dismiss(modal.key, 'escape key press');
                });
                break;
              }
            case 9:
              {
                $modalStack.loadFocusElementList(modal);
                var focusChanged = false;
                if (evt.shiftKey) {
                  if ($modalStack.isFocusInFirstItem(evt)) {
                    focusChanged = $modalStack.focusLastFocusableElement();
                  }
                } else {
                  if ($modalStack.isFocusInLastItem(evt)) {
                    focusChanged = $modalStack.focusFirstFocusableElement();
                  }
                }
                if (focusChanged) {
                  evt.preventDefault();
                  evt.stopPropagation();
                }
                break;
              }
          }
        }
      });
      $modalStack.open = function(modalInstance, modal) {
        var modalOpener = $document[0].activeElement,
            modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;
        toggleTopWindowClass(false);
        openedWindows.add(modalInstance, {
          deferred: modal.deferred,
          renderDeferred: modal.renderDeferred,
          modalScope: modal.scope,
          backdrop: modal.backdrop,
          keyboard: modal.keyboard,
          openedClass: modal.openedClass,
          windowTopClass: modal.windowTopClass
        });
        openedClasses.put(modalBodyClass, modalInstance);
        var body = $document.find('body').eq(0),
            currBackdropIndex = backdropIndex();
        if (currBackdropIndex >= 0 && !backdropDomEl) {
          backdropScope = $rootScope.$new(true);
          backdropScope.index = currBackdropIndex;
          var angularBackgroundDomEl = angular.element('<div uib-modal-backdrop="modal-backdrop"></div>');
          angularBackgroundDomEl.attr('backdrop-class', modal.backdropClass);
          if (modal.animation) {
            angularBackgroundDomEl.attr('modal-animation', 'true');
          }
          backdropDomEl = $compile(angularBackgroundDomEl)(backdropScope);
          body.append(backdropDomEl);
        }
        var angularDomEl = angular.element('<div uib-modal-window="modal-window"></div>');
        angularDomEl.attr({
          'template-url': modal.windowTemplateUrl,
          'window-class': modal.windowClass,
          'window-top-class': modal.windowTopClass,
          'size': modal.size,
          'index': openedWindows.length() - 1,
          'animate': 'animate'
        }).html(modal.content);
        if (modal.animation) {
          angularDomEl.attr('modal-animation', 'true');
        }
        var modalDomEl = $compile(angularDomEl)(modal.scope);
        openedWindows.top().value.modalDomEl = modalDomEl;
        openedWindows.top().value.modalOpener = modalOpener;
        body.append(modalDomEl);
        body.addClass(modalBodyClass);
        $modalStack.clearFocusListCache();
      };
      function broadcastClosing(modalWindow, resultOrReason, closing) {
        return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;
      }
      $modalStack.close = function(modalInstance, result) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow && broadcastClosing(modalWindow, result, true)) {
          modalWindow.value.modalScope.$$uibDestructionScheduled = true;
          modalWindow.value.deferred.resolve(result);
          removeModalWindow(modalInstance, modalWindow.value.modalOpener);
          return true;
        }
        return !modalWindow;
      };
      $modalStack.dismiss = function(modalInstance, reason) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow && broadcastClosing(modalWindow, reason, false)) {
          modalWindow.value.modalScope.$$uibDestructionScheduled = true;
          modalWindow.value.deferred.reject(reason);
          removeModalWindow(modalInstance, modalWindow.value.modalOpener);
          return true;
        }
        return !modalWindow;
      };
      $modalStack.dismissAll = function(reason) {
        var topModal = this.getTop();
        while (topModal && this.dismiss(topModal.key, reason)) {
          topModal = this.getTop();
        }
      };
      $modalStack.getTop = function() {
        return openedWindows.top();
      };
      $modalStack.modalRendered = function(modalInstance) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow) {
          modalWindow.value.renderDeferred.resolve();
        }
      };
      $modalStack.focusFirstFocusableElement = function() {
        if (focusableElementList.length > 0) {
          focusableElementList[0].focus();
          return true;
        }
        return false;
      };
      $modalStack.focusLastFocusableElement = function() {
        if (focusableElementList.length > 0) {
          focusableElementList[focusableElementList.length - 1].focus();
          return true;
        }
        return false;
      };
      $modalStack.isFocusInFirstItem = function(evt) {
        if (focusableElementList.length > 0) {
          return (evt.target || evt.srcElement) == focusableElementList[0];
        }
        return false;
      };
      $modalStack.isFocusInLastItem = function(evt) {
        if (focusableElementList.length > 0) {
          return (evt.target || evt.srcElement) == focusableElementList[focusableElementList.length - 1];
        }
        return false;
      };
      $modalStack.clearFocusListCache = function() {
        focusableElementList = [];
        focusIndex = 0;
      };
      $modalStack.loadFocusElementList = function(modalWindow) {
        if (focusableElementList === undefined || !focusableElementList.length) {
          if (modalWindow) {
            var modalDomE1 = modalWindow.value.modalDomEl;
            if (modalDomE1 && modalDomE1.length) {
              focusableElementList = modalDomE1[0].querySelectorAll(tababbleSelector);
            }
          }
        }
      };
      return $modalStack;
    }]).provider('$uibModal', function() {
      var $modalProvider = {
        options: {
          animation: true,
          backdrop: true,
          keyboard: true
        },
        $get: ['$injector', '$rootScope', '$q', '$templateRequest', '$controller', '$uibModalStack', '$modalSuppressWarning', '$log', function($injector, $rootScope, $q, $templateRequest, $controller, $modalStack, $modalSuppressWarning, $log) {
          var $modal = {};
          function getTemplatePromise(options) {
            return options.template ? $q.when(options.template) : $templateRequest(angular.isFunction(options.templateUrl) ? (options.templateUrl)() : options.templateUrl);
          }
          function getResolvePromises(resolves) {
            var promisesArr = [];
            angular.forEach(resolves, function(value) {
              if (angular.isFunction(value) || angular.isArray(value)) {
                promisesArr.push($q.when($injector.invoke(value)));
              } else if (angular.isString(value)) {
                promisesArr.push($q.when($injector.get(value)));
              } else {
                promisesArr.push($q.when(value));
              }
            });
            return promisesArr;
          }
          var promiseChain = null;
          $modal.getPromiseChain = function() {
            return promiseChain;
          };
          $modal.open = function(modalOptions) {
            var modalResultDeferred = $q.defer();
            var modalOpenedDeferred = $q.defer();
            var modalRenderDeferred = $q.defer();
            var modalInstance = {
              result: modalResultDeferred.promise,
              opened: modalOpenedDeferred.promise,
              rendered: modalRenderDeferred.promise,
              close: function(result) {
                return $modalStack.close(modalInstance, result);
              },
              dismiss: function(reason) {
                return $modalStack.dismiss(modalInstance, reason);
              }
            };
            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);
            modalOptions.resolve = modalOptions.resolve || {};
            if (!modalOptions.template && !modalOptions.templateUrl) {
              throw new Error('One of template or templateUrl options is required.');
            }
            var templateAndResolvePromise = $q.all([getTemplatePromise(modalOptions)].concat(getResolvePromises(modalOptions.resolve)));
            function resolveWithTemplate() {
              return templateAndResolvePromise;
            }
            var samePromise;
            samePromise = promiseChain = $q.all([promiseChain]).then(resolveWithTemplate, resolveWithTemplate).then(function resolveSuccess(tplAndVars) {
              var modalScope = (modalOptions.scope || $rootScope).$new();
              modalScope.$close = modalInstance.close;
              modalScope.$dismiss = modalInstance.dismiss;
              modalScope.$on('$destroy', function() {
                if (!modalScope.$$uibDestructionScheduled) {
                  modalScope.$dismiss('$uibUnscheduledDestruction');
                }
              });
              var ctrlInstance,
                  ctrlLocals = {};
              var resolveIter = 1;
              if (modalOptions.controller) {
                ctrlLocals.$scope = modalScope;
                ctrlLocals.$uibModalInstance = modalInstance;
                Object.defineProperty(ctrlLocals, '$modalInstance', {get: function() {
                    if (!$modalSuppressWarning) {
                      $log.warn('$modalInstance is now deprecated. Use $uibModalInstance instead.');
                    }
                    return modalInstance;
                  }});
                angular.forEach(modalOptions.resolve, function(value, key) {
                  ctrlLocals[key] = tplAndVars[resolveIter++];
                });
                ctrlInstance = $controller(modalOptions.controller, ctrlLocals);
                if (modalOptions.controllerAs) {
                  if (modalOptions.bindToController) {
                    angular.extend(ctrlInstance, modalScope);
                  }
                  modalScope[modalOptions.controllerAs] = ctrlInstance;
                }
              }
              $modalStack.open(modalInstance, {
                scope: modalScope,
                deferred: modalResultDeferred,
                renderDeferred: modalRenderDeferred,
                content: tplAndVars[0],
                animation: modalOptions.animation,
                backdrop: modalOptions.backdrop,
                keyboard: modalOptions.keyboard,
                backdropClass: modalOptions.backdropClass,
                windowTopClass: modalOptions.windowTopClass,
                windowClass: modalOptions.windowClass,
                windowTemplateUrl: modalOptions.windowTemplateUrl,
                size: modalOptions.size,
                openedClass: modalOptions.openedClass
              });
              modalOpenedDeferred.resolve(true);
            }, function resolveError(reason) {
              modalOpenedDeferred.reject(reason);
              modalResultDeferred.reject(reason);
            }).finally(function() {
              if (promiseChain === samePromise) {
                promiseChain = null;
              }
            });
            return modalInstance;
          };
          return $modal;
        }]
      };
      return $modalProvider;
    });
    angular.module('ui.bootstrap.modal').value('$modalSuppressWarning', false).directive('modalBackdrop', ['$animate', '$injector', '$modalStack', '$log', '$modalSuppressWarning', function($animate, $injector, $modalStack, $log, $modalSuppressWarning) {
      var $animateCss = null;
      if ($injector.has('$animateCss')) {
        $animateCss = $injector.get('$animateCss');
      }
      return {
        replace: true,
        templateUrl: 'template/modal/backdrop.html',
        compile: function(tElement, tAttrs) {
          tElement.addClass(tAttrs.backdropClass);
          return linkFn;
        }
      };
      function linkFn(scope, element, attrs) {
        if (!$modalSuppressWarning) {
          $log.warn('modal-backdrop is now deprecated. Use uib-modal-backdrop instead.');
        }
        element.addClass('modal-backdrop');
        if (attrs.modalInClass) {
          if ($animateCss) {
            $animateCss(element, {addClass: attrs.modalInClass}).start();
          } else {
            $animate.addClass(element, attrs.modalInClass);
          }
          scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
            var done = setIsAsync();
            if ($animateCss) {
              $animateCss(element, {removeClass: attrs.modalInClass}).start().then(done);
            } else {
              $animate.removeClass(element, attrs.modalInClass).then(done);
            }
          });
        }
      }
    }]).directive('modalWindow', ['$modalStack', '$q', '$animate', '$injector', '$log', '$modalSuppressWarning', function($modalStack, $q, $animate, $injector, $log, $modalSuppressWarning) {
      var $animateCss = null;
      if ($injector.has('$animateCss')) {
        $animateCss = $injector.get('$animateCss');
      }
      return {
        scope: {index: '@'},
        replace: true,
        transclude: true,
        templateUrl: function(tElement, tAttrs) {
          return tAttrs.templateUrl || 'template/modal/window.html';
        },
        link: function(scope, element, attrs) {
          if (!$modalSuppressWarning) {
            $log.warn('modal-window is now deprecated. Use uib-modal-window instead.');
          }
          element.addClass(attrs.windowClass || '');
          element.addClass(attrs.windowTopClass || '');
          scope.size = attrs.size;
          scope.close = function(evt) {
            var modal = $modalStack.getTop();
            if (modal && modal.value.backdrop && modal.value.backdrop !== 'static' && (evt.target === evt.currentTarget)) {
              evt.preventDefault();
              evt.stopPropagation();
              $modalStack.dismiss(modal.key, 'backdrop click');
            }
          };
          element.on('click', scope.close);
          scope.$isRendered = true;
          var modalRenderDeferObj = $q.defer();
          attrs.$observe('modalRender', function(value) {
            if (value == 'true') {
              modalRenderDeferObj.resolve();
            }
          });
          modalRenderDeferObj.promise.then(function() {
            var animationPromise = null;
            if (attrs.modalInClass) {
              if ($animateCss) {
                animationPromise = $animateCss(element, {addClass: attrs.modalInClass}).start();
              } else {
                animationPromise = $animate.addClass(element, attrs.modalInClass);
              }
              scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
                var done = setIsAsync();
                if ($animateCss) {
                  $animateCss(element, {removeClass: attrs.modalInClass}).start().then(done);
                } else {
                  $animate.removeClass(element, attrs.modalInClass).then(done);
                }
              });
            }
            $q.when(animationPromise).then(function() {
              var inputWithAutofocus = element[0].querySelector('[autofocus]');
              if (inputWithAutofocus) {
                inputWithAutofocus.focus();
              } else {
                element[0].focus();
              }
            });
            var modal = $modalStack.getTop();
            if (modal) {
              $modalStack.modalRendered(modal.key);
            }
          });
        }
      };
    }]).directive('modalAnimationClass', ['$log', '$modalSuppressWarning', function($log, $modalSuppressWarning) {
      return {compile: function(tElement, tAttrs) {
          if (!$modalSuppressWarning) {
            $log.warn('modal-animation-class is now deprecated. Use uib-modal-animation-class instead.');
          }
          if (tAttrs.modalAnimation) {
            tElement.addClass(tAttrs.modalAnimationClass);
          }
        }};
    }]).directive('modalTransclude', ['$log', '$modalSuppressWarning', function($log, $modalSuppressWarning) {
      return {link: function($scope, $element, $attrs, controller, $transclude) {
          if (!$modalSuppressWarning) {
            $log.warn('modal-transclude is now deprecated. Use uib-modal-transclude instead.');
          }
          $transclude($scope.$parent, function(clone) {
            $element.empty();
            $element.append(clone);
          });
        }};
    }]).service('$modalStack', ['$animate', '$timeout', '$document', '$compile', '$rootScope', '$q', '$injector', '$$multiMap', '$$stackedMap', '$uibModalStack', '$log', '$modalSuppressWarning', function($animate, $timeout, $document, $compile, $rootScope, $q, $injector, $$multiMap, $$stackedMap, $uibModalStack, $log, $modalSuppressWarning) {
      if (!$modalSuppressWarning) {
        $log.warn('$modalStack is now deprecated. Use $uibModalStack instead.');
      }
      angular.extend(this, $uibModalStack);
    }]).provider('$modal', ['$uibModalProvider', function($uibModalProvider) {
      angular.extend(this, $uibModalProvider);
      this.$get = ['$injector', '$log', '$modalSuppressWarning', function($injector, $log, $modalSuppressWarning) {
        if (!$modalSuppressWarning) {
          $log.warn('$modal is now deprecated. Use $uibModal instead.');
        }
        return $injector.invoke($uibModalProvider.$get);
      }];
    }]);
    angular.module('ui.bootstrap.pagination', []).controller('UibPaginationController', ['$scope', '$attrs', '$parse', function($scope, $attrs, $parse) {
      var self = this,
          ngModelCtrl = {$setViewValue: angular.noop},
          setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;
      this.init = function(ngModelCtrl_, config) {
        ngModelCtrl = ngModelCtrl_;
        this.config = config;
        ngModelCtrl.$render = function() {
          self.render();
        };
        if ($attrs.itemsPerPage) {
          $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {
            self.itemsPerPage = parseInt(value, 10);
            $scope.totalPages = self.calculateTotalPages();
          });
        } else {
          this.itemsPerPage = config.itemsPerPage;
        }
        $scope.$watch('totalItems', function() {
          $scope.totalPages = self.calculateTotalPages();
        });
        $scope.$watch('totalPages', function(value) {
          setNumPages($scope.$parent, value);
          if ($scope.page > value) {
            $scope.selectPage(value);
          } else {
            ngModelCtrl.$render();
          }
        });
      };
      this.calculateTotalPages = function() {
        var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);
        return Math.max(totalPages || 0, 1);
      };
      this.render = function() {
        $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;
      };
      $scope.selectPage = function(page, evt) {
        if (evt) {
          evt.preventDefault();
        }
        var clickAllowed = !$scope.ngDisabled || !evt;
        if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {
          if (evt && evt.target) {
            evt.target.blur();
          }
          ngModelCtrl.$setViewValue(page);
          ngModelCtrl.$render();
        }
      };
      $scope.getText = function(key) {
        return $scope[key + 'Text'] || self.config[key + 'Text'];
      };
      $scope.noPrevious = function() {
        return $scope.page === 1;
      };
      $scope.noNext = function() {
        return $scope.page === $scope.totalPages;
      };
    }]).constant('uibPaginationConfig', {
      itemsPerPage: 10,
      boundaryLinks: false,
      directionLinks: true,
      firstText: 'First',
      previousText: 'Previous',
      nextText: 'Next',
      lastText: 'Last',
      rotate: true
    }).directive('uibPagination', ['$parse', 'uibPaginationConfig', function($parse, paginationConfig) {
      return {
        restrict: 'EA',
        scope: {
          totalItems: '=',
          firstText: '@',
          previousText: '@',
          nextText: '@',
          lastText: '@',
          ngDisabled: '='
        },
        require: ['uibPagination', '?ngModel'],
        controller: 'UibPaginationController',
        controllerAs: 'pagination',
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'template/pagination/pagination.html';
        },
        replace: true,
        link: function(scope, element, attrs, ctrls) {
          var paginationCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];
          if (!ngModelCtrl) {
            return;
          }
          var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize,
              rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;
          scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks;
          scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks;
          paginationCtrl.init(ngModelCtrl, paginationConfig);
          if (attrs.maxSize) {
            scope.$parent.$watch($parse(attrs.maxSize), function(value) {
              maxSize = parseInt(value, 10);
              paginationCtrl.render();
            });
          }
          function makePage(number, text, isActive) {
            return {
              number: number,
              text: text,
              active: isActive
            };
          }
          function getPages(currentPage, totalPages) {
            var pages = [];
            var startPage = 1,
                endPage = totalPages;
            var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;
            if (isMaxSized) {
              if (rotate) {
                startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1);
                endPage = startPage + maxSize - 1;
                if (endPage > totalPages) {
                  endPage = totalPages;
                  startPage = endPage - maxSize + 1;
                }
              } else {
                startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;
                endPage = Math.min(startPage + maxSize - 1, totalPages);
              }
            }
            for (var number = startPage; number <= endPage; number++) {
              var page = makePage(number, number, number === currentPage);
              pages.push(page);
            }
            if (isMaxSized && !rotate) {
              if (startPage > 1) {
                var previousPageSet = makePage(startPage - 1, '...', false);
                pages.unshift(previousPageSet);
              }
              if (endPage < totalPages) {
                var nextPageSet = makePage(endPage + 1, '...', false);
                pages.push(nextPageSet);
              }
            }
            return pages;
          }
          var originalRender = paginationCtrl.render;
          paginationCtrl.render = function() {
            originalRender();
            if (scope.page > 0 && scope.page <= scope.totalPages) {
              scope.pages = getPages(scope.page, scope.totalPages);
            }
          };
        }
      };
    }]).constant('uibPagerConfig', {
      itemsPerPage: 10,
      previousText: '« Previous',
      nextText: 'Next »',
      align: true
    }).directive('uibPager', ['uibPagerConfig', function(pagerConfig) {
      return {
        restrict: 'EA',
        scope: {
          totalItems: '=',
          previousText: '@',
          nextText: '@',
          ngDisabled: '='
        },
        require: ['uibPager', '?ngModel'],
        controller: 'UibPaginationController',
        controllerAs: 'pagination',
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'template/pagination/pager.html';
        },
        replace: true,
        link: function(scope, element, attrs, ctrls) {
          var paginationCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];
          if (!ngModelCtrl) {
            return;
          }
          scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align;
          paginationCtrl.init(ngModelCtrl, pagerConfig);
        }
      };
    }]);
    angular.module('ui.bootstrap.pagination').value('$paginationSuppressWarning', false).controller('PaginationController', ['$scope', '$attrs', '$parse', '$log', '$paginationSuppressWarning', function($scope, $attrs, $parse, $log, $paginationSuppressWarning) {
      if (!$paginationSuppressWarning) {
        $log.warn('PaginationController is now deprecated. Use UibPaginationController instead.');
      }
      var self = this,
          ngModelCtrl = {$setViewValue: angular.noop},
          setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;
      this.init = function(ngModelCtrl_, config) {
        ngModelCtrl = ngModelCtrl_;
        this.config = config;
        ngModelCtrl.$render = function() {
          self.render();
        };
        if ($attrs.itemsPerPage) {
          $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {
            self.itemsPerPage = parseInt(value, 10);
            $scope.totalPages = self.calculateTotalPages();
          });
        } else {
          this.itemsPerPage = config.itemsPerPage;
        }
        $scope.$watch('totalItems', function() {
          $scope.totalPages = self.calculateTotalPages();
        });
        $scope.$watch('totalPages', function(value) {
          setNumPages($scope.$parent, value);
          if ($scope.page > value) {
            $scope.selectPage(value);
          } else {
            ngModelCtrl.$render();
          }
        });
      };
      this.calculateTotalPages = function() {
        var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);
        return Math.max(totalPages || 0, 1);
      };
      this.render = function() {
        $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;
      };
      $scope.selectPage = function(page, evt) {
        if (evt) {
          evt.preventDefault();
        }
        var clickAllowed = !$scope.ngDisabled || !evt;
        if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {
          if (evt && evt.target) {
            evt.target.blur();
          }
          ngModelCtrl.$setViewValue(page);
          ngModelCtrl.$render();
        }
      };
      $scope.getText = function(key) {
        return $scope[key + 'Text'] || self.config[key + 'Text'];
      };
      $scope.noPrevious = function() {
        return $scope.page === 1;
      };
      $scope.noNext = function() {
        return $scope.page === $scope.totalPages;
      };
    }]).directive('pagination', ['$parse', 'uibPaginationConfig', '$log', '$paginationSuppressWarning', function($parse, paginationConfig, $log, $paginationSuppressWarning) {
      return {
        restrict: 'EA',
        scope: {
          totalItems: '=',
          firstText: '@',
          previousText: '@',
          nextText: '@',
          lastText: '@',
          ngDisabled: '='
        },
        require: ['pagination', '?ngModel'],
        controller: 'PaginationController',
        controllerAs: 'pagination',
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'template/pagination/pagination.html';
        },
        replace: true,
        link: function(scope, element, attrs, ctrls) {
          if (!$paginationSuppressWarning) {
            $log.warn('pagination is now deprecated. Use uib-pagination instead.');
          }
          var paginationCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];
          if (!ngModelCtrl) {
            return;
          }
          var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize,
              rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;
          scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks;
          scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks;
          paginationCtrl.init(ngModelCtrl, paginationConfig);
          if (attrs.maxSize) {
            scope.$parent.$watch($parse(attrs.maxSize), function(value) {
              maxSize = parseInt(value, 10);
              paginationCtrl.render();
            });
          }
          function makePage(number, text, isActive) {
            return {
              number: number,
              text: text,
              active: isActive
            };
          }
          function getPages(currentPage, totalPages) {
            var pages = [];
            var startPage = 1,
                endPage = totalPages;
            var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;
            if (isMaxSized) {
              if (rotate) {
                startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1);
                endPage = startPage + maxSize - 1;
                if (endPage > totalPages) {
                  endPage = totalPages;
                  startPage = endPage - maxSize + 1;
                }
              } else {
                startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;
                endPage = Math.min(startPage + maxSize - 1, totalPages);
              }
            }
            for (var number = startPage; number <= endPage; number++) {
              var page = makePage(number, number, number === currentPage);
              pages.push(page);
            }
            if (isMaxSized && !rotate) {
              if (startPage > 1) {
                var previousPageSet = makePage(startPage - 1, '...', false);
                pages.unshift(previousPageSet);
              }
              if (endPage < totalPages) {
                var nextPageSet = makePage(endPage + 1, '...', false);
                pages.push(nextPageSet);
              }
            }
            return pages;
          }
          var originalRender = paginationCtrl.render;
          paginationCtrl.render = function() {
            originalRender();
            if (scope.page > 0 && scope.page <= scope.totalPages) {
              scope.pages = getPages(scope.page, scope.totalPages);
            }
          };
        }
      };
    }]).directive('pager', ['uibPagerConfig', '$log', '$paginationSuppressWarning', function(pagerConfig, $log, $paginationSuppressWarning) {
      return {
        restrict: 'EA',
        scope: {
          totalItems: '=',
          previousText: '@',
          nextText: '@',
          ngDisabled: '='
        },
        require: ['pager', '?ngModel'],
        controller: 'PaginationController',
        controllerAs: 'pagination',
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'template/pagination/pager.html';
        },
        replace: true,
        link: function(scope, element, attrs, ctrls) {
          if (!$paginationSuppressWarning) {
            $log.warn('pager is now deprecated. Use uib-pager instead.');
          }
          var paginationCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];
          if (!ngModelCtrl) {
            return;
          }
          scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align;
          paginationCtrl.init(ngModelCtrl, pagerConfig);
        }
      };
    }]);
    angular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.stackedMap']).provider('$uibTooltip', function() {
      var defaultOptions = {
        placement: 'top',
        animation: true,
        popupDelay: 0,
        popupCloseDelay: 0,
        useContentExp: false
      };
      var triggerMap = {
        'mouseenter': 'mouseleave',
        'click': 'click',
        'focus': 'blur',
        'none': ''
      };
      var globalOptions = {};
      this.options = function(value) {
        angular.extend(globalOptions, value);
      };
      this.setTriggers = function setTriggers(triggers) {
        angular.extend(triggerMap, triggers);
      };
      function snake_case(name) {
        var regexp = /[A-Z]/g;
        var separator = '-';
        return name.replace(regexp, function(letter, pos) {
          return (pos ? separator : '') + letter.toLowerCase();
        });
      }
      this.$get = ['$window', '$compile', '$timeout', '$document', '$uibPosition', '$interpolate', '$rootScope', '$parse', '$$stackedMap', function($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {
        var openedTooltips = $$stackedMap.createNew();
        $document.on('keypress', function(e) {
          if (e.which === 27) {
            var last = openedTooltips.top();
            if (last) {
              last.value.close();
              openedTooltips.removeTop();
              last = null;
            }
          }
        });
        return function $tooltip(ttType, prefix, defaultTriggerShow, options) {
          options = angular.extend({}, defaultOptions, globalOptions, options);
          function getTriggers(trigger) {
            var show = (trigger || options.trigger || defaultTriggerShow).split(' ');
            var hide = show.map(function(trigger) {
              return triggerMap[trigger] || trigger;
            });
            return {
              show: show,
              hide: hide
            };
          }
          var directiveName = snake_case(ttType);
          var startSym = $interpolate.startSymbol();
          var endSym = $interpolate.endSymbol();
          var template = '<div ' + directiveName + '-popup ' + 'title="' + startSym + 'title' + endSym + '" ' + (options.useContentExp ? 'content-exp="contentExp()" ' : 'content="' + startSym + 'content' + endSym + '" ') + 'placement="' + startSym + 'placement' + endSym + '" ' + 'popup-class="' + startSym + 'popupClass' + endSym + '" ' + 'animation="animation" ' + 'is-open="isOpen"' + 'origin-scope="origScope" ' + 'style="visibility: hidden; display: block; top: -9999px; left: -9999px;"' + '>' + '</div>';
          return {compile: function(tElem, tAttrs) {
              var tooltipLinker = $compile(template);
              return function link(scope, element, attrs, tooltipCtrl) {
                var tooltip;
                var tooltipLinkedScope;
                var transitionTimeout;
                var showTimeout;
                var hideTimeout;
                var positionTimeout;
                var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;
                var triggers = getTriggers(undefined);
                var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);
                var ttScope = scope.$new(true);
                var repositionScheduled = false;
                var isOpenParse = angular.isDefined(attrs[prefix + 'IsOpen']) ? $parse(attrs[prefix + 'IsOpen']) : false;
                var contentParse = options.useContentExp ? $parse(attrs[ttType]) : false;
                var observers = [];
                var positionTooltip = function() {
                  if (!tooltip || !tooltip.html()) {
                    return;
                  }
                  if (!positionTimeout) {
                    positionTimeout = $timeout(function() {
                      tooltip.css({
                        top: 0,
                        left: 0
                      });
                      var ttCss = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);
                      ttCss.top += 'px';
                      ttCss.left += 'px';
                      ttCss.visibility = 'visible';
                      tooltip.css(ttCss);
                      positionTimeout = null;
                    }, 0, false);
                  }
                };
                ttScope.origScope = scope;
                ttScope.isOpen = false;
                openedTooltips.add(ttScope, {close: hide});
                function toggleTooltipBind() {
                  if (!ttScope.isOpen) {
                    showTooltipBind();
                  } else {
                    hideTooltipBind();
                  }
                }
                function showTooltipBind() {
                  if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {
                    return;
                  }
                  cancelHide();
                  prepareTooltip();
                  if (ttScope.popupDelay) {
                    if (!showTimeout) {
                      showTimeout = $timeout(show, ttScope.popupDelay, false);
                    }
                  } else {
                    show();
                  }
                }
                function hideTooltipBind() {
                  cancelShow();
                  if (ttScope.popupCloseDelay) {
                    if (!hideTimeout) {
                      hideTimeout = $timeout(hide, ttScope.popupCloseDelay, false);
                    }
                  } else {
                    hide();
                  }
                }
                function show() {
                  cancelShow();
                  cancelHide();
                  if (!ttScope.content) {
                    return angular.noop;
                  }
                  createTooltip();
                  ttScope.$evalAsync(function() {
                    ttScope.isOpen = true;
                    assignIsOpen(true);
                    positionTooltip();
                  });
                }
                function cancelShow() {
                  if (showTimeout) {
                    $timeout.cancel(showTimeout);
                    showTimeout = null;
                  }
                  if (positionTimeout) {
                    $timeout.cancel(positionTimeout);
                    positionTimeout = null;
                  }
                }
                function hide() {
                  cancelShow();
                  cancelHide();
                  if (!ttScope) {
                    return;
                  }
                  ttScope.$evalAsync(function() {
                    ttScope.isOpen = false;
                    assignIsOpen(false);
                    if (ttScope.animation) {
                      if (!transitionTimeout) {
                        transitionTimeout = $timeout(removeTooltip, 150, false);
                      }
                    } else {
                      removeTooltip();
                    }
                  });
                }
                function cancelHide() {
                  if (hideTimeout) {
                    $timeout.cancel(hideTimeout);
                    hideTimeout = null;
                  }
                  if (transitionTimeout) {
                    $timeout.cancel(transitionTimeout);
                    transitionTimeout = null;
                  }
                }
                function createTooltip() {
                  if (tooltip) {
                    return;
                  }
                  tooltipLinkedScope = ttScope.$new();
                  tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {
                    if (appendToBody) {
                      $document.find('body').append(tooltip);
                    } else {
                      element.after(tooltip);
                    }
                  });
                  prepObservers();
                }
                function removeTooltip() {
                  unregisterObservers();
                  transitionTimeout = null;
                  if (tooltip) {
                    tooltip.remove();
                    tooltip = null;
                  }
                  if (tooltipLinkedScope) {
                    tooltipLinkedScope.$destroy();
                    tooltipLinkedScope = null;
                  }
                }
                function prepareTooltip() {
                  ttScope.title = attrs[prefix + 'Title'];
                  if (contentParse) {
                    ttScope.content = contentParse(scope);
                  } else {
                    ttScope.content = attrs[ttType];
                  }
                  ttScope.popupClass = attrs[prefix + 'Class'];
                  ttScope.placement = angular.isDefined(attrs[prefix + 'Placement']) ? attrs[prefix + 'Placement'] : options.placement;
                  var delay = parseInt(attrs[prefix + 'PopupDelay'], 10);
                  var closeDelay = parseInt(attrs[prefix + 'PopupCloseDelay'], 10);
                  ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;
                  ttScope.popupCloseDelay = !isNaN(closeDelay) ? closeDelay : options.popupCloseDelay;
                }
                function assignIsOpen(isOpen) {
                  if (isOpenParse && angular.isFunction(isOpenParse.assign)) {
                    isOpenParse.assign(scope, isOpen);
                  }
                }
                ttScope.contentExp = function() {
                  return ttScope.content;
                };
                attrs.$observe('disabled', function(val) {
                  if (val) {
                    cancelShow();
                  }
                  if (val && ttScope.isOpen) {
                    hide();
                  }
                });
                if (isOpenParse) {
                  scope.$watch(isOpenParse, function(val) {
                    if (ttScope && !val === ttScope.isOpen) {
                      toggleTooltipBind();
                    }
                  });
                }
                function prepObservers() {
                  observers.length = 0;
                  if (contentParse) {
                    observers.push(scope.$watch(contentParse, function(val) {
                      ttScope.content = val;
                      if (!val && ttScope.isOpen) {
                        hide();
                      }
                    }));
                    observers.push(tooltipLinkedScope.$watch(function() {
                      if (!repositionScheduled) {
                        repositionScheduled = true;
                        tooltipLinkedScope.$$postDigest(function() {
                          repositionScheduled = false;
                          if (ttScope && ttScope.isOpen) {
                            positionTooltip();
                          }
                        });
                      }
                    }));
                  } else {
                    observers.push(attrs.$observe(ttType, function(val) {
                      ttScope.content = val;
                      if (!val && ttScope.isOpen) {
                        hide();
                      } else {
                        positionTooltip();
                      }
                    }));
                  }
                  observers.push(attrs.$observe(prefix + 'Title', function(val) {
                    ttScope.title = val;
                    if (ttScope.isOpen) {
                      positionTooltip();
                    }
                  }));
                  observers.push(attrs.$observe(prefix + 'Placement', function(val) {
                    ttScope.placement = val ? val : options.placement;
                    if (ttScope.isOpen) {
                      positionTooltip();
                    }
                  }));
                }
                function unregisterObservers() {
                  if (observers.length) {
                    angular.forEach(observers, function(observer) {
                      observer();
                    });
                    observers.length = 0;
                  }
                }
                var unregisterTriggers = function() {
                  triggers.show.forEach(function(trigger) {
                    element.unbind(trigger, showTooltipBind);
                  });
                  triggers.hide.forEach(function(trigger) {
                    trigger.split(' ').forEach(function(hideTrigger) {
                      element[0].removeEventListener(hideTrigger, hideTooltipBind);
                    });
                  });
                };
                function prepTriggers() {
                  var val = attrs[prefix + 'Trigger'];
                  unregisterTriggers();
                  triggers = getTriggers(val);
                  if (triggers.show !== 'none') {
                    triggers.show.forEach(function(trigger, idx) {
                      if (trigger === triggers.hide[idx]) {
                        element[0].addEventListener(trigger, toggleTooltipBind);
                      } else if (trigger) {
                        element[0].addEventListener(trigger, showTooltipBind);
                        triggers.hide[idx].split(' ').forEach(function(trigger) {
                          element[0].addEventListener(trigger, hideTooltipBind);
                        });
                      }
                      element.on('keypress', function(e) {
                        if (e.which === 27) {
                          hideTooltipBind();
                        }
                      });
                    });
                  }
                }
                prepTriggers();
                var animation = scope.$eval(attrs[prefix + 'Animation']);
                ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;
                var appendToBodyVal = scope.$eval(attrs[prefix + 'AppendToBody']);
                appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;
                if (appendToBody) {
                  scope.$on('$locationChangeSuccess', function closeTooltipOnLocationChangeSuccess() {
                    if (ttScope.isOpen) {
                      hide();
                    }
                  });
                }
                scope.$on('$destroy', function onDestroyTooltip() {
                  cancelShow();
                  cancelHide();
                  unregisterTriggers();
                  removeTooltip();
                  openedTooltips.remove(ttScope);
                  ttScope = null;
                });
              };
            }};
        };
      }];
    }).directive('uibTooltipTemplateTransclude', ['$animate', '$sce', '$compile', '$templateRequest', function($animate, $sce, $compile, $templateRequest) {
      return {link: function(scope, elem, attrs) {
          var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);
          var changeCounter = 0,
              currentScope,
              previousElement,
              currentElement;
          var cleanupLastIncludeContent = function() {
            if (previousElement) {
              previousElement.remove();
              previousElement = null;
            }
            if (currentScope) {
              currentScope.$destroy();
              currentScope = null;
            }
            if (currentElement) {
              $animate.leave(currentElement).then(function() {
                previousElement = null;
              });
              previousElement = currentElement;
              currentElement = null;
            }
          };
          scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function(src) {
            var thisChangeId = ++changeCounter;
            if (src) {
              $templateRequest(src, true).then(function(response) {
                if (thisChangeId !== changeCounter) {
                  return;
                }
                var newScope = origScope.$new();
                var template = response;
                var clone = $compile(template)(newScope, function(clone) {
                  cleanupLastIncludeContent();
                  $animate.enter(clone, elem);
                });
                currentScope = newScope;
                currentElement = clone;
                currentScope.$emit('$includeContentLoaded', src);
              }, function() {
                if (thisChangeId === changeCounter) {
                  cleanupLastIncludeContent();
                  scope.$emit('$includeContentError', src);
                }
              });
              scope.$emit('$includeContentRequested', src);
            } else {
              cleanupLastIncludeContent();
            }
          });
          scope.$on('$destroy', cleanupLastIncludeContent);
        }};
    }]).directive('uibTooltipClasses', function() {
      return {
        restrict: 'A',
        link: function(scope, element, attrs) {
          if (scope.placement) {
            element.addClass(scope.placement);
          }
          if (scope.popupClass) {
            element.addClass(scope.popupClass);
          }
          if (scope.animation()) {
            element.addClass(attrs.tooltipAnimationClass);
          }
        }
      };
    }).directive('uibTooltipPopup', function() {
      return {
        replace: true,
        scope: {
          content: '@',
          placement: '@',
          popupClass: '@',
          animation: '&',
          isOpen: '&'
        },
        templateUrl: 'template/tooltip/tooltip-popup.html',
        link: function(scope, element) {
          element.addClass('tooltip');
        }
      };
    }).directive('uibTooltip', ['$uibTooltip', function($uibTooltip) {
      return $uibTooltip('uibTooltip', 'tooltip', 'mouseenter');
    }]).directive('uibTooltipTemplatePopup', function() {
      return {
        replace: true,
        scope: {
          contentExp: '&',
          placement: '@',
          popupClass: '@',
          animation: '&',
          isOpen: '&',
          originScope: '&'
        },
        templateUrl: 'template/tooltip/tooltip-template-popup.html',
        link: function(scope, element) {
          element.addClass('tooltip');
        }
      };
    }).directive('uibTooltipTemplate', ['$uibTooltip', function($uibTooltip) {
      return $uibTooltip('uibTooltipTemplate', 'tooltip', 'mouseenter', {useContentExp: true});
    }]).directive('uibTooltipHtmlPopup', function() {
      return {
        replace: true,
        scope: {
          contentExp: '&',
          placement: '@',
          popupClass: '@',
          animation: '&',
          isOpen: '&'
        },
        templateUrl: 'template/tooltip/tooltip-html-popup.html',
        link: function(scope, element) {
          element.addClass('tooltip');
        }
      };
    }).directive('uibTooltipHtml', ['$uibTooltip', function($uibTooltip) {
      return $uibTooltip('uibTooltipHtml', 'tooltip', 'mouseenter', {useContentExp: true});
    }]);
    angular.module('ui.bootstrap.tooltip').value('$tooltipSuppressWarning', false).provider('$tooltip', ['$uibTooltipProvider', function($uibTooltipProvider) {
      angular.extend(this, $uibTooltipProvider);
      this.$get = ['$log', '$tooltipSuppressWarning', '$injector', function($log, $tooltipSuppressWarning, $injector) {
        if (!$tooltipSuppressWarning) {
          $log.warn('$tooltip is now deprecated. Use $uibTooltip instead.');
        }
        return $injector.invoke($uibTooltipProvider.$get);
      }];
    }]).directive('tooltipTemplateTransclude', ['$animate', '$sce', '$compile', '$templateRequest', '$log', '$tooltipSuppressWarning', function($animate, $sce, $compile, $templateRequest, $log, $tooltipSuppressWarning) {
      return {link: function(scope, elem, attrs) {
          if (!$tooltipSuppressWarning) {
            $log.warn('tooltip-template-transclude is now deprecated. Use uib-tooltip-template-transclude instead.');
          }
          var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);
          var changeCounter = 0,
              currentScope,
              previousElement,
              currentElement;
          var cleanupLastIncludeContent = function() {
            if (previousElement) {
              previousElement.remove();
              previousElement = null;
            }
            if (currentScope) {
              currentScope.$destroy();
              currentScope = null;
            }
            if (currentElement) {
              $animate.leave(currentElement).then(function() {
                previousElement = null;
              });
              previousElement = currentElement;
              currentElement = null;
            }
          };
          scope.$watch($sce.parseAsResourceUrl(attrs.tooltipTemplateTransclude), function(src) {
            var thisChangeId = ++changeCounter;
            if (src) {
              $templateRequest(src, true).then(function(response) {
                if (thisChangeId !== changeCounter) {
                  return;
                }
                var newScope = origScope.$new();
                var template = response;
                var clone = $compile(template)(newScope, function(clone) {
                  cleanupLastIncludeContent();
                  $animate.enter(clone, elem);
                });
                currentScope = newScope;
                currentElement = clone;
                currentScope.$emit('$includeContentLoaded', src);
              }, function() {
                if (thisChangeId === changeCounter) {
                  cleanupLastIncludeContent();
                  scope.$emit('$includeContentError', src);
                }
              });
              scope.$emit('$includeContentRequested', src);
            } else {
              cleanupLastIncludeContent();
            }
          });
          scope.$on('$destroy', cleanupLastIncludeContent);
        }};
    }]).directive('tooltipClasses', ['$log', '$tooltipSuppressWarning', function($log, $tooltipSuppressWarning) {
      return {
        restrict: 'A',
        link: function(scope, element, attrs) {
          if (!$tooltipSuppressWarning) {
            $log.warn('tooltip-classes is now deprecated. Use uib-tooltip-classes instead.');
          }
          if (scope.placement) {
            element.addClass(scope.placement);
          }
          if (scope.popupClass) {
            element.addClass(scope.popupClass);
          }
          if (scope.animation()) {
            element.addClass(attrs.tooltipAnimationClass);
          }
        }
      };
    }]).directive('tooltipPopup', ['$log', '$tooltipSuppressWarning', function($log, $tooltipSuppressWarning) {
      return {
        replace: true,
        scope: {
          content: '@',
          placement: '@',
          popupClass: '@',
          animation: '&',
          isOpen: '&'
        },
        templateUrl: 'template/tooltip/tooltip-popup.html',
        link: function(scope, element) {
          if (!$tooltipSuppressWarning) {
            $log.warn('tooltip-popup is now deprecated. Use uib-tooltip-popup instead.');
          }
          element.addClass('tooltip');
        }
      };
    }]).directive('tooltip', ['$tooltip', function($tooltip) {
      return $tooltip('tooltip', 'tooltip', 'mouseenter');
    }]).directive('tooltipTemplatePopup', ['$log', '$tooltipSuppressWarning', function($log, $tooltipSuppressWarning) {
      return {
        replace: true,
        scope: {
          contentExp: '&',
          placement: '@',
          popupClass: '@',
          animation: '&',
          isOpen: '&',
          originScope: '&'
        },
        templateUrl: 'template/tooltip/tooltip-template-popup.html',
        link: function(scope, element) {
          if (!$tooltipSuppressWarning) {
            $log.warn('tooltip-template-popup is now deprecated. Use uib-tooltip-template-popup instead.');
          }
          element.addClass('tooltip');
        }
      };
    }]).directive('tooltipTemplate', ['$tooltip', function($tooltip) {
      return $tooltip('tooltipTemplate', 'tooltip', 'mouseenter', {useContentExp: true});
    }]).directive('tooltipHtmlPopup', ['$log', '$tooltipSuppressWarning', function($log, $tooltipSuppressWarning) {
      return {
        replace: true,
        scope: {
          contentExp: '&',
          placement: '@',
          popupClass: '@',
          animation: '&',
          isOpen: '&'
        },
        templateUrl: 'template/tooltip/tooltip-html-popup.html',
        link: function(scope, element) {
          if (!$tooltipSuppressWarning) {
            $log.warn('tooltip-html-popup is now deprecated. Use uib-tooltip-html-popup instead.');
          }
          element.addClass('tooltip');
        }
      };
    }]).directive('tooltipHtml', ['$tooltip', function($tooltip) {
      return $tooltip('tooltipHtml', 'tooltip', 'mouseenter', {useContentExp: true});
    }]);
    angular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip']).directive('uibPopoverTemplatePopup', function() {
      return {
        replace: true,
        scope: {
          title: '@',
          contentExp: '&',
          placement: '@',
          popupClass: '@',
          animation: '&',
          isOpen: '&',
          originScope: '&'
        },
        templateUrl: 'template/popover/popover-template.html',
        link: function(scope, element) {
          element.addClass('popover');
        }
      };
    }).directive('uibPopoverTemplate', ['$uibTooltip', function($uibTooltip) {
      return $uibTooltip('uibPopoverTemplate', 'popover', 'click', {useContentExp: true});
    }]).directive('uibPopoverHtmlPopup', function() {
      return {
        replace: true,
        scope: {
          contentExp: '&',
          title: '@',
          placement: '@',
          popupClass: '@',
          animation: '&',
          isOpen: '&'
        },
        templateUrl: 'template/popover/popover-html.html',
        link: function(scope, element) {
          element.addClass('popover');
        }
      };
    }).directive('uibPopoverHtml', ['$uibTooltip', function($uibTooltip) {
      return $uibTooltip('uibPopoverHtml', 'popover', 'click', {useContentExp: true});
    }]).directive('uibPopoverPopup', function() {
      return {
        replace: true,
        scope: {
          title: '@',
          content: '@',
          placement: '@',
          popupClass: '@',
          animation: '&',
          isOpen: '&'
        },
        templateUrl: 'template/popover/popover.html',
        link: function(scope, element) {
          element.addClass('popover');
        }
      };
    }).directive('uibPopover', ['$uibTooltip', function($uibTooltip) {
      return $uibTooltip('uibPopover', 'popover', 'click');
    }]);
    angular.module('ui.bootstrap.popover').value('$popoverSuppressWarning', false).directive('popoverTemplatePopup', ['$log', '$popoverSuppressWarning', function($log, $popoverSuppressWarning) {
      return {
        replace: true,
        scope: {
          title: '@',
          contentExp: '&',
          placement: '@',
          popupClass: '@',
          animation: '&',
          isOpen: '&',
          originScope: '&'
        },
        templateUrl: 'template/popover/popover-template.html',
        link: function(scope, element) {
          if (!$popoverSuppressWarning) {
            $log.warn('popover-template-popup is now deprecated. Use uib-popover-template-popup instead.');
          }
          element.addClass('popover');
        }
      };
    }]).directive('popoverTemplate', ['$tooltip', function($tooltip) {
      return $tooltip('popoverTemplate', 'popover', 'click', {useContentExp: true});
    }]).directive('popoverHtmlPopup', ['$log', '$popoverSuppressWarning', function($log, $popoverSuppressWarning) {
      return {
        replace: true,
        scope: {
          contentExp: '&',
          title: '@',
          placement: '@',
          popupClass: '@',
          animation: '&',
          isOpen: '&'
        },
        templateUrl: 'template/popover/popover-html.html',
        link: function(scope, element) {
          if (!$popoverSuppressWarning) {
            $log.warn('popover-html-popup is now deprecated. Use uib-popover-html-popup instead.');
          }
          element.addClass('popover');
        }
      };
    }]).directive('popoverHtml', ['$tooltip', function($tooltip) {
      return $tooltip('popoverHtml', 'popover', 'click', {useContentExp: true});
    }]).directive('popoverPopup', ['$log', '$popoverSuppressWarning', function($log, $popoverSuppressWarning) {
      return {
        replace: true,
        scope: {
          title: '@',
          content: '@',
          placement: '@',
          popupClass: '@',
          animation: '&',
          isOpen: '&'
        },
        templateUrl: 'template/popover/popover.html',
        link: function(scope, element) {
          if (!$popoverSuppressWarning) {
            $log.warn('popover-popup is now deprecated. Use uib-popover-popup instead.');
          }
          element.addClass('popover');
        }
      };
    }]).directive('popover', ['$tooltip', function($tooltip) {
      return $tooltip('popover', 'popover', 'click');
    }]);
    angular.module('ui.bootstrap.progressbar', []).constant('uibProgressConfig', {
      animate: true,
      max: 100
    }).controller('UibProgressController', ['$scope', '$attrs', 'uibProgressConfig', function($scope, $attrs, progressConfig) {
      var self = this,
          animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;
      this.bars = [];
      $scope.max = angular.isDefined($scope.max) ? $scope.max : progressConfig.max;
      this.addBar = function(bar, element, attrs) {
        if (!animate) {
          element.css({'transition': 'none'});
        }
        this.bars.push(bar);
        bar.max = $scope.max;
        bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';
        bar.$watch('value', function(value) {
          bar.recalculatePercentage();
        });
        bar.recalculatePercentage = function() {
          var totalPercentage = self.bars.reduce(function(total, bar) {
            bar.percent = +(100 * bar.value / bar.max).toFixed(2);
            return total + bar.percent;
          }, 0);
          if (totalPercentage > 100) {
            bar.percent -= totalPercentage - 100;
          }
        };
        bar.$on('$destroy', function() {
          element = null;
          self.removeBar(bar);
        });
      };
      this.removeBar = function(bar) {
        this.bars.splice(this.bars.indexOf(bar), 1);
        this.bars.forEach(function(bar) {
          bar.recalculatePercentage();
        });
      };
      $scope.$watch('max', function(max) {
        self.bars.forEach(function(bar) {
          bar.max = $scope.max;
          bar.recalculatePercentage();
        });
      });
    }]).directive('uibProgress', function() {
      return {
        replace: true,
        transclude: true,
        controller: 'UibProgressController',
        require: 'uibProgress',
        scope: {max: '=?'},
        templateUrl: 'template/progressbar/progress.html'
      };
    }).directive('uibBar', function() {
      return {
        replace: true,
        transclude: true,
        require: '^uibProgress',
        scope: {
          value: '=',
          type: '@'
        },
        templateUrl: 'template/progressbar/bar.html',
        link: function(scope, element, attrs, progressCtrl) {
          progressCtrl.addBar(scope, element, attrs);
        }
      };
    }).directive('uibProgressbar', function() {
      return {
        replace: true,
        transclude: true,
        controller: 'UibProgressController',
        scope: {
          value: '=',
          max: '=?',
          type: '@'
        },
        templateUrl: 'template/progressbar/progressbar.html',
        link: function(scope, element, attrs, progressCtrl) {
          progressCtrl.addBar(scope, angular.element(element.children()[0]), {title: attrs.title});
        }
      };
    });
    angular.module('ui.bootstrap.progressbar').value('$progressSuppressWarning', false).controller('ProgressController', ['$scope', '$attrs', 'uibProgressConfig', '$log', '$progressSuppressWarning', function($scope, $attrs, progressConfig, $log, $progressSuppressWarning) {
      if (!$progressSuppressWarning) {
        $log.warn('ProgressController is now deprecated. Use UibProgressController instead.');
      }
      var self = this,
          animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;
      this.bars = [];
      $scope.max = angular.isDefined($scope.max) ? $scope.max : progressConfig.max;
      this.addBar = function(bar, element, attrs) {
        if (!animate) {
          element.css({'transition': 'none'});
        }
        this.bars.push(bar);
        bar.max = $scope.max;
        bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';
        bar.$watch('value', function(value) {
          bar.recalculatePercentage();
        });
        bar.recalculatePercentage = function() {
          bar.percent = +(100 * bar.value / bar.max).toFixed(2);
          var totalPercentage = self.bars.reduce(function(total, bar) {
            return total + bar.percent;
          }, 0);
          if (totalPercentage > 100) {
            bar.percent -= totalPercentage - 100;
          }
        };
        bar.$on('$destroy', function() {
          element = null;
          self.removeBar(bar);
        });
      };
      this.removeBar = function(bar) {
        this.bars.splice(this.bars.indexOf(bar), 1);
      };
      $scope.$watch('max', function(max) {
        self.bars.forEach(function(bar) {
          bar.max = $scope.max;
          bar.recalculatePercentage();
        });
      });
    }]).directive('progress', ['$log', '$progressSuppressWarning', function($log, $progressSuppressWarning) {
      return {
        replace: true,
        transclude: true,
        controller: 'ProgressController',
        require: 'progress',
        scope: {
          max: '=?',
          title: '@?'
        },
        templateUrl: 'template/progressbar/progress.html',
        link: function() {
          if (!$progressSuppressWarning) {
            $log.warn('progress is now deprecated. Use uib-progress instead.');
          }
        }
      };
    }]).directive('bar', ['$log', '$progressSuppressWarning', function($log, $progressSuppressWarning) {
      return {
        replace: true,
        transclude: true,
        require: '^progress',
        scope: {
          value: '=',
          type: '@'
        },
        templateUrl: 'template/progressbar/bar.html',
        link: function(scope, element, attrs, progressCtrl) {
          if (!$progressSuppressWarning) {
            $log.warn('bar is now deprecated. Use uib-bar instead.');
          }
          progressCtrl.addBar(scope, element);
        }
      };
    }]).directive('progressbar', ['$log', '$progressSuppressWarning', function($log, $progressSuppressWarning) {
      return {
        replace: true,
        transclude: true,
        controller: 'ProgressController',
        scope: {
          value: '=',
          max: '=?',
          type: '@'
        },
        templateUrl: 'template/progressbar/progressbar.html',
        link: function(scope, element, attrs, progressCtrl) {
          if (!$progressSuppressWarning) {
            $log.warn('progressbar is now deprecated. Use uib-progressbar instead.');
          }
          progressCtrl.addBar(scope, angular.element(element.children()[0]), {title: attrs.title});
        }
      };
    }]);
    angular.module('ui.bootstrap.rating', []).constant('uibRatingConfig', {
      max: 5,
      stateOn: null,
      stateOff: null,
      titles: ['one', 'two', 'three', 'four', 'five']
    }).controller('UibRatingController', ['$scope', '$attrs', 'uibRatingConfig', function($scope, $attrs, ratingConfig) {
      var ngModelCtrl = {$setViewValue: angular.noop};
      this.init = function(ngModelCtrl_) {
        ngModelCtrl = ngModelCtrl_;
        ngModelCtrl.$render = this.render;
        ngModelCtrl.$formatters.push(function(value) {
          if (angular.isNumber(value) && value << 0 !== value) {
            value = Math.round(value);
          }
          return value;
        });
        this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;
        this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;
        var tmpTitles = angular.isDefined($attrs.titles) ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles;
        this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ? tmpTitles : ratingConfig.titles;
        var ratingStates = angular.isDefined($attrs.ratingStates) ? $scope.$parent.$eval($attrs.ratingStates) : new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);
        $scope.range = this.buildTemplateObjects(ratingStates);
      };
      this.buildTemplateObjects = function(states) {
        for (var i = 0,
            n = states.length; i < n; i++) {
          states[i] = angular.extend({index: i}, {
            stateOn: this.stateOn,
            stateOff: this.stateOff,
            title: this.getTitle(i)
          }, states[i]);
        }
        return states;
      };
      this.getTitle = function(index) {
        if (index >= this.titles.length) {
          return index + 1;
        } else {
          return this.titles[index];
        }
      };
      $scope.rate = function(value) {
        if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {
          ngModelCtrl.$setViewValue(ngModelCtrl.$viewValue === value ? 0 : value);
          ngModelCtrl.$render();
        }
      };
      $scope.enter = function(value) {
        if (!$scope.readonly) {
          $scope.value = value;
        }
        $scope.onHover({value: value});
      };
      $scope.reset = function() {
        $scope.value = ngModelCtrl.$viewValue;
        $scope.onLeave();
      };
      $scope.onKeydown = function(evt) {
        if (/(37|38|39|40)/.test(evt.which)) {
          evt.preventDefault();
          evt.stopPropagation();
          $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));
        }
      };
      this.render = function() {
        $scope.value = ngModelCtrl.$viewValue;
      };
    }]).directive('uibRating', function() {
      return {
        require: ['uibRating', 'ngModel'],
        scope: {
          readonly: '=?',
          onHover: '&',
          onLeave: '&'
        },
        controller: 'UibRatingController',
        templateUrl: 'template/rating/rating.html',
        replace: true,
        link: function(scope, element, attrs, ctrls) {
          var ratingCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];
          ratingCtrl.init(ngModelCtrl);
        }
      };
    });
    angular.module('ui.bootstrap.rating').value('$ratingSuppressWarning', false).controller('RatingController', ['$scope', '$attrs', '$controller', '$log', '$ratingSuppressWarning', function($scope, $attrs, $controller, $log, $ratingSuppressWarning) {
      if (!$ratingSuppressWarning) {
        $log.warn('RatingController is now deprecated. Use UibRatingController instead.');
      }
      angular.extend(this, $controller('UibRatingController', {
        $scope: $scope,
        $attrs: $attrs
      }));
    }]).directive('rating', ['$log', '$ratingSuppressWarning', function($log, $ratingSuppressWarning) {
      return {
        require: ['rating', 'ngModel'],
        scope: {
          readonly: '=?',
          onHover: '&',
          onLeave: '&'
        },
        controller: 'RatingController',
        templateUrl: 'template/rating/rating.html',
        replace: true,
        link: function(scope, element, attrs, ctrls) {
          if (!$ratingSuppressWarning) {
            $log.warn('rating is now deprecated. Use uib-rating instead.');
          }
          var ratingCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];
          ratingCtrl.init(ngModelCtrl);
        }
      };
    }]);
    angular.module('ui.bootstrap.tabs', []).controller('UibTabsetController', ['$scope', function($scope) {
      var ctrl = this,
          tabs = ctrl.tabs = $scope.tabs = [];
      ctrl.select = function(selectedTab) {
        angular.forEach(tabs, function(tab) {
          if (tab.active && tab !== selectedTab) {
            tab.active = false;
            tab.onDeselect();
            selectedTab.selectCalled = false;
          }
        });
        selectedTab.active = true;
        if (!selectedTab.selectCalled) {
          selectedTab.onSelect();
          selectedTab.selectCalled = true;
        }
      };
      ctrl.addTab = function addTab(tab) {
        tabs.push(tab);
        if (tabs.length === 1 && tab.active !== false) {
          tab.active = true;
        } else if (tab.active) {
          ctrl.select(tab);
        } else {
          tab.active = false;
        }
      };
      ctrl.removeTab = function removeTab(tab) {
        var index = tabs.indexOf(tab);
        if (tab.active && tabs.length > 1 && !destroyed) {
          var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;
          ctrl.select(tabs[newActiveIndex]);
        }
        tabs.splice(index, 1);
      };
      var destroyed;
      $scope.$on('$destroy', function() {
        destroyed = true;
      });
    }]).directive('uibTabset', function() {
      return {
        restrict: 'EA',
        transclude: true,
        replace: true,
        scope: {type: '@'},
        controller: 'UibTabsetController',
        templateUrl: 'template/tabs/tabset.html',
        link: function(scope, element, attrs) {
          scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;
          scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;
        }
      };
    }).directive('uibTab', ['$parse', function($parse) {
      return {
        require: '^uibTabset',
        restrict: 'EA',
        replace: true,
        templateUrl: 'template/tabs/tab.html',
        transclude: true,
        scope: {
          active: '=?',
          heading: '@',
          onSelect: '&select',
          onDeselect: '&deselect'
        },
        controller: function() {},
        link: function(scope, elm, attrs, tabsetCtrl, transclude) {
          scope.$watch('active', function(active) {
            if (active) {
              tabsetCtrl.select(scope);
            }
          });
          scope.disabled = false;
          if (attrs.disable) {
            scope.$parent.$watch($parse(attrs.disable), function(value) {
              scope.disabled = !!value;
            });
          }
          scope.select = function() {
            if (!scope.disabled) {
              scope.active = true;
            }
          };
          tabsetCtrl.addTab(scope);
          scope.$on('$destroy', function() {
            tabsetCtrl.removeTab(scope);
          });
          scope.$transcludeFn = transclude;
        }
      };
    }]).directive('uibTabHeadingTransclude', function() {
      return {
        restrict: 'A',
        require: ['?^uibTab', '?^tab'],
        link: function(scope, elm) {
          scope.$watch('headingElement', function updateHeadingElement(heading) {
            if (heading) {
              elm.html('');
              elm.append(heading);
            }
          });
        }
      };
    }).directive('uibTabContentTransclude', function() {
      return {
        restrict: 'A',
        require: ['?^uibTabset', '?^tabset'],
        link: function(scope, elm, attrs) {
          var tab = scope.$eval(attrs.uibTabContentTransclude);
          tab.$transcludeFn(tab.$parent, function(contents) {
            angular.forEach(contents, function(node) {
              if (isTabHeading(node)) {
                tab.headingElement = node;
              } else {
                elm.append(node);
              }
            });
          });
        }
      };
      function isTabHeading(node) {
        return node.tagName && (node.hasAttribute('tab-heading') || node.hasAttribute('data-tab-heading') || node.hasAttribute('x-tab-heading') || node.hasAttribute('uib-tab-heading') || node.hasAttribute('data-uib-tab-heading') || node.hasAttribute('x-uib-tab-heading') || node.tagName.toLowerCase() === 'tab-heading' || node.tagName.toLowerCase() === 'data-tab-heading' || node.tagName.toLowerCase() === 'x-tab-heading' || node.tagName.toLowerCase() === 'uib-tab-heading' || node.tagName.toLowerCase() === 'data-uib-tab-heading' || node.tagName.toLowerCase() === 'x-uib-tab-heading');
      }
    });
    angular.module('ui.bootstrap.tabs').value('$tabsSuppressWarning', false).controller('TabsetController', ['$scope', '$controller', '$log', '$tabsSuppressWarning', function($scope, $controller, $log, $tabsSuppressWarning) {
      if (!$tabsSuppressWarning) {
        $log.warn('TabsetController is now deprecated. Use UibTabsetController instead.');
      }
      angular.extend(this, $controller('UibTabsetController', {$scope: $scope}));
    }]).directive('tabset', ['$log', '$tabsSuppressWarning', function($log, $tabsSuppressWarning) {
      return {
        restrict: 'EA',
        transclude: true,
        replace: true,
        scope: {type: '@'},
        controller: 'TabsetController',
        templateUrl: 'template/tabs/tabset.html',
        link: function(scope, element, attrs) {
          if (!$tabsSuppressWarning) {
            $log.warn('tabset is now deprecated. Use uib-tabset instead.');
          }
          scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;
          scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;
        }
      };
    }]).directive('tab', ['$parse', '$log', '$tabsSuppressWarning', function($parse, $log, $tabsSuppressWarning) {
      return {
        require: '^tabset',
        restrict: 'EA',
        replace: true,
        templateUrl: 'template/tabs/tab.html',
        transclude: true,
        scope: {
          active: '=?',
          heading: '@',
          onSelect: '&select',
          onDeselect: '&deselect'
        },
        controller: function() {},
        link: function(scope, elm, attrs, tabsetCtrl, transclude) {
          if (!$tabsSuppressWarning) {
            $log.warn('tab is now deprecated. Use uib-tab instead.');
          }
          scope.$watch('active', function(active) {
            if (active) {
              tabsetCtrl.select(scope);
            }
          });
          scope.disabled = false;
          if (attrs.disable) {
            scope.$parent.$watch($parse(attrs.disable), function(value) {
              scope.disabled = !!value;
            });
          }
          scope.select = function() {
            if (!scope.disabled) {
              scope.active = true;
            }
          };
          tabsetCtrl.addTab(scope);
          scope.$on('$destroy', function() {
            tabsetCtrl.removeTab(scope);
          });
          scope.$transcludeFn = transclude;
        }
      };
    }]).directive('tabHeadingTransclude', ['$log', '$tabsSuppressWarning', function($log, $tabsSuppressWarning) {
      return {
        restrict: 'A',
        require: '^tab',
        link: function(scope, elm) {
          if (!$tabsSuppressWarning) {
            $log.warn('tab-heading-transclude is now deprecated. Use uib-tab-heading-transclude instead.');
          }
          scope.$watch('headingElement', function updateHeadingElement(heading) {
            if (heading) {
              elm.html('');
              elm.append(heading);
            }
          });
        }
      };
    }]).directive('tabContentTransclude', ['$log', '$tabsSuppressWarning', function($log, $tabsSuppressWarning) {
      return {
        restrict: 'A',
        require: '^tabset',
        link: function(scope, elm, attrs) {
          if (!$tabsSuppressWarning) {
            $log.warn('tab-content-transclude is now deprecated. Use uib-tab-content-transclude instead.');
          }
          var tab = scope.$eval(attrs.tabContentTransclude);
          tab.$transcludeFn(tab.$parent, function(contents) {
            angular.forEach(contents, function(node) {
              if (isTabHeading(node)) {
                tab.headingElement = node;
              } else {
                elm.append(node);
              }
            });
          });
        }
      };
      function isTabHeading(node) {
        return node.tagName && (node.hasAttribute('tab-heading') || node.hasAttribute('data-tab-heading') || node.hasAttribute('x-tab-heading') || node.tagName.toLowerCase() === 'tab-heading' || node.tagName.toLowerCase() === 'data-tab-heading' || node.tagName.toLowerCase() === 'x-tab-heading');
      }
    }]);
    angular.module('ui.bootstrap.timepicker', []).constant('uibTimepickerConfig', {
      hourStep: 1,
      minuteStep: 1,
      showMeridian: true,
      meridians: null,
      readonlyInput: false,
      mousewheel: true,
      arrowkeys: true,
      showSpinners: true
    }).controller('UibTimepickerController', ['$scope', '$element', '$attrs', '$parse', '$log', '$locale', 'uibTimepickerConfig', function($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {
      var selected = new Date(),
          ngModelCtrl = {$setViewValue: angular.noop},
          meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS;
      $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0;
      $element.removeAttr('tabindex');
      this.init = function(ngModelCtrl_, inputs) {
        ngModelCtrl = ngModelCtrl_;
        ngModelCtrl.$render = this.render;
        ngModelCtrl.$formatters.unshift(function(modelValue) {
          return modelValue ? new Date(modelValue) : null;
        });
        var hoursInputEl = inputs.eq(0),
            minutesInputEl = inputs.eq(1);
        var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;
        if (mousewheel) {
          this.setupMousewheelEvents(hoursInputEl, minutesInputEl);
        }
        var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;
        if (arrowkeys) {
          this.setupArrowkeyEvents(hoursInputEl, minutesInputEl);
        }
        $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;
        this.setupInputEvents(hoursInputEl, minutesInputEl);
      };
      var hourStep = timepickerConfig.hourStep;
      if ($attrs.hourStep) {
        $scope.$parent.$watch($parse($attrs.hourStep), function(value) {
          hourStep = parseInt(value, 10);
        });
      }
      var minuteStep = timepickerConfig.minuteStep;
      if ($attrs.minuteStep) {
        $scope.$parent.$watch($parse($attrs.minuteStep), function(value) {
          minuteStep = parseInt(value, 10);
        });
      }
      var min;
      $scope.$parent.$watch($parse($attrs.min), function(value) {
        var dt = new Date(value);
        min = isNaN(dt) ? undefined : dt;
      });
      var max;
      $scope.$parent.$watch($parse($attrs.max), function(value) {
        var dt = new Date(value);
        max = isNaN(dt) ? undefined : dt;
      });
      $scope.noIncrementHours = function() {
        var incrementedSelected = addMinutes(selected, hourStep * 60);
        return incrementedSelected > max || (incrementedSelected < selected && incrementedSelected < min);
      };
      $scope.noDecrementHours = function() {
        var decrementedSelected = addMinutes(selected, -hourStep * 60);
        return decrementedSelected < min || (decrementedSelected > selected && decrementedSelected > max);
      };
      $scope.noIncrementMinutes = function() {
        var incrementedSelected = addMinutes(selected, minuteStep);
        return incrementedSelected > max || (incrementedSelected < selected && incrementedSelected < min);
      };
      $scope.noDecrementMinutes = function() {
        var decrementedSelected = addMinutes(selected, -minuteStep);
        return decrementedSelected < min || (decrementedSelected > selected && decrementedSelected > max);
      };
      $scope.noToggleMeridian = function() {
        if (selected.getHours() < 13) {
          return addMinutes(selected, 12 * 60) > max;
        } else {
          return addMinutes(selected, -12 * 60) < min;
        }
      };
      $scope.showMeridian = timepickerConfig.showMeridian;
      if ($attrs.showMeridian) {
        $scope.$parent.$watch($parse($attrs.showMeridian), function(value) {
          $scope.showMeridian = !!value;
          if (ngModelCtrl.$error.time) {
            var hours = getHoursFromTemplate(),
                minutes = getMinutesFromTemplate();
            if (angular.isDefined(hours) && angular.isDefined(minutes)) {
              selected.setHours(hours);
              refresh();
            }
          } else {
            updateTemplate();
          }
        });
      }
      function getHoursFromTemplate() {
        var hours = parseInt($scope.hours, 10);
        var valid = $scope.showMeridian ? (hours > 0 && hours < 13) : (hours >= 0 && hours < 24);
        if (!valid) {
          return undefined;
        }
        if ($scope.showMeridian) {
          if (hours === 12) {
            hours = 0;
          }
          if ($scope.meridian === meridians[1]) {
            hours = hours + 12;
          }
        }
        return hours;
      }
      function getMinutesFromTemplate() {
        var minutes = parseInt($scope.minutes, 10);
        return (minutes >= 0 && minutes < 60) ? minutes : undefined;
      }
      function pad(value) {
        return (angular.isDefined(value) && value.toString().length < 2) ? '0' + value : value.toString();
      }
      this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl) {
        var isScrollingUp = function(e) {
          if (e.originalEvent) {
            e = e.originalEvent;
          }
          var delta = (e.wheelDelta) ? e.wheelDelta : -e.deltaY;
          return (e.detail || delta > 0);
        };
        hoursInputEl.bind('mousewheel wheel', function(e) {
          $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());
          e.preventDefault();
        });
        minutesInputEl.bind('mousewheel wheel', function(e) {
          $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());
          e.preventDefault();
        });
      };
      this.setupArrowkeyEvents = function(hoursInputEl, minutesInputEl) {
        hoursInputEl.bind('keydown', function(e) {
          if (e.which === 38) {
            e.preventDefault();
            $scope.incrementHours();
            $scope.$apply();
          } else if (e.which === 40) {
            e.preventDefault();
            $scope.decrementHours();
            $scope.$apply();
          }
        });
        minutesInputEl.bind('keydown', function(e) {
          if (e.which === 38) {
            e.preventDefault();
            $scope.incrementMinutes();
            $scope.$apply();
          } else if (e.which === 40) {
            e.preventDefault();
            $scope.decrementMinutes();
            $scope.$apply();
          }
        });
      };
      this.setupInputEvents = function(hoursInputEl, minutesInputEl) {
        if ($scope.readonlyInput) {
          $scope.updateHours = angular.noop;
          $scope.updateMinutes = angular.noop;
          return;
        }
        var invalidate = function(invalidHours, invalidMinutes) {
          ngModelCtrl.$setViewValue(null);
          ngModelCtrl.$setValidity('time', false);
          if (angular.isDefined(invalidHours)) {
            $scope.invalidHours = invalidHours;
          }
          if (angular.isDefined(invalidMinutes)) {
            $scope.invalidMinutes = invalidMinutes;
          }
        };
        $scope.updateHours = function() {
          var hours = getHoursFromTemplate(),
              minutes = getMinutesFromTemplate();
          if (angular.isDefined(hours) && angular.isDefined(minutes)) {
            selected.setHours(hours);
            if (selected < min || selected > max) {
              invalidate(true);
            } else {
              refresh('h');
            }
          } else {
            invalidate(true);
          }
        };
        hoursInputEl.bind('blur', function(e) {
          if (!$scope.invalidHours && $scope.hours < 10) {
            $scope.$apply(function() {
              $scope.hours = pad($scope.hours);
            });
          }
        });
        $scope.updateMinutes = function() {
          var minutes = getMinutesFromTemplate(),
              hours = getHoursFromTemplate();
          if (angular.isDefined(minutes) && angular.isDefined(hours)) {
            selected.setMinutes(minutes);
            if (selected < min || selected > max) {
              invalidate(undefined, true);
            } else {
              refresh('m');
            }
          } else {
            invalidate(undefined, true);
          }
        };
        minutesInputEl.bind('blur', function(e) {
          if (!$scope.invalidMinutes && $scope.minutes < 10) {
            $scope.$apply(function() {
              $scope.minutes = pad($scope.minutes);
            });
          }
        });
      };
      this.render = function() {
        var date = ngModelCtrl.$viewValue;
        if (isNaN(date)) {
          ngModelCtrl.$setValidity('time', false);
          $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
        } else {
          if (date) {
            selected = date;
          }
          if (selected < min || selected > max) {
            ngModelCtrl.$setValidity('time', false);
            $scope.invalidHours = true;
            $scope.invalidMinutes = true;
          } else {
            makeValid();
          }
          updateTemplate();
        }
      };
      function refresh(keyboardChange) {
        makeValid();
        ngModelCtrl.$setViewValue(new Date(selected));
        updateTemplate(keyboardChange);
      }
      function makeValid() {
        ngModelCtrl.$setValidity('time', true);
        $scope.invalidHours = false;
        $scope.invalidMinutes = false;
      }
      function updateTemplate(keyboardChange) {
        var hours = selected.getHours(),
            minutes = selected.getMinutes();
        if ($scope.showMeridian) {
          hours = (hours === 0 || hours === 12) ? 12 : hours % 12;
        }
        $scope.hours = keyboardChange === 'h' ? hours : pad(hours);
        if (keyboardChange !== 'm') {
          $scope.minutes = pad(minutes);
        }
        $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
      }
      function addMinutes(date, minutes) {
        var dt = new Date(date.getTime() + minutes * 60000);
        var newDate = new Date(date);
        newDate.setHours(dt.getHours(), dt.getMinutes());
        return newDate;
      }
      function addMinutesToSelected(minutes) {
        selected = addMinutes(selected, minutes);
        refresh();
      }
      $scope.showSpinners = angular.isDefined($attrs.showSpinners) ? $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;
      $scope.incrementHours = function() {
        if (!$scope.noIncrementHours()) {
          addMinutesToSelected(hourStep * 60);
        }
      };
      $scope.decrementHours = function() {
        if (!$scope.noDecrementHours()) {
          addMinutesToSelected(-hourStep * 60);
        }
      };
      $scope.incrementMinutes = function() {
        if (!$scope.noIncrementMinutes()) {
          addMinutesToSelected(minuteStep);
        }
      };
      $scope.decrementMinutes = function() {
        if (!$scope.noDecrementMinutes()) {
          addMinutesToSelected(-minuteStep);
        }
      };
      $scope.toggleMeridian = function() {
        if (!$scope.noToggleMeridian()) {
          addMinutesToSelected(12 * 60 * (selected.getHours() < 12 ? 1 : -1));
        }
      };
    }]).directive('uibTimepicker', function() {
      return {
        restrict: 'EA',
        require: ['uibTimepicker', '?^ngModel'],
        controller: 'UibTimepickerController',
        controllerAs: 'timepicker',
        replace: true,
        scope: {},
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'template/timepicker/timepicker.html';
        },
        link: function(scope, element, attrs, ctrls) {
          var timepickerCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];
          if (ngModelCtrl) {
            timepickerCtrl.init(ngModelCtrl, element.find('input'));
          }
        }
      };
    });
    angular.module('ui.bootstrap.timepicker').value('$timepickerSuppressWarning', false).controller('TimepickerController', ['$scope', '$element', '$attrs', '$controller', '$log', '$timepickerSuppressWarning', function($scope, $element, $attrs, $controller, $log, $timepickerSuppressWarning) {
      if (!$timepickerSuppressWarning) {
        $log.warn('TimepickerController is now deprecated. Use UibTimepickerController instead.');
      }
      angular.extend(this, $controller('UibTimepickerController', {
        $scope: $scope,
        $element: $element,
        $attrs: $attrs
      }));
    }]).directive('timepicker', ['$log', '$timepickerSuppressWarning', function($log, $timepickerSuppressWarning) {
      return {
        restrict: 'EA',
        require: ['timepicker', '?^ngModel'],
        controller: 'TimepickerController',
        controllerAs: 'timepicker',
        replace: true,
        scope: {},
        templateUrl: function(element, attrs) {
          return attrs.templateUrl || 'template/timepicker/timepicker.html';
        },
        link: function(scope, element, attrs, ctrls) {
          if (!$timepickerSuppressWarning) {
            $log.warn('timepicker is now deprecated. Use uib-timepicker instead.');
          }
          var timepickerCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];
          if (ngModelCtrl) {
            timepickerCtrl.init(ngModelCtrl, element.find('input'));
          }
        }
      };
    }]);
    angular.module('ui.bootstrap.typeahead', ['ui.bootstrap.position']).factory('uibTypeaheadParser', ['$parse', function($parse) {
      var TYPEAHEAD_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/;
      return {parse: function(input) {
          var match = input.match(TYPEAHEAD_REGEXP);
          if (!match) {
            throw new Error('Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_"' + ' but got "' + input + '".');
          }
          return {
            itemName: match[3],
            source: $parse(match[4]),
            viewMapper: $parse(match[2] || match[1]),
            modelMapper: $parse(match[1])
          };
        }};
    }]).controller('UibTypeaheadController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$uibPosition', 'uibTypeaheadParser', function(originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $position, typeaheadParser) {
      var HOT_KEYS = [9, 13, 27, 38, 40];
      var eventDebounceTime = 200;
      var modelCtrl,
          ngModelOptions;
      var minLength = originalScope.$eval(attrs.typeaheadMinLength);
      if (!minLength && minLength !== 0) {
        minLength = 1;
      }
      var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;
      var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;
      var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;
      var onSelectCallback = $parse(attrs.typeaheadOnSelect);
      var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;
      var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;
      var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;
      var appendToBody = attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;
      var appendToElementId = attrs.typeaheadAppendToElementId || false;
      var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;
      var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;
      var parsedModel = $parse(attrs.ngModel);
      var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');
      var $setModelValue = function(scope, newValue) {
        if (angular.isFunction(parsedModel(originalScope)) && ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {
          return invokeModelSetter(scope, {$$$p: newValue});
        } else {
          return parsedModel.assign(scope, newValue);
        }
      };
      var parserResult = typeaheadParser.parse(attrs.uibTypeahead);
      var hasFocus;
      var selected;
      var scope = originalScope.$new();
      var offDestroy = originalScope.$on('$destroy', function() {
        scope.$destroy();
      });
      scope.$on('$destroy', offDestroy);
      var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
      element.attr({
        'aria-autocomplete': 'list',
        'aria-expanded': false,
        'aria-owns': popupId
      });
      var popUpEl = angular.element('<div uib-typeahead-popup></div>');
      popUpEl.attr({
        id: popupId,
        matches: 'matches',
        active: 'activeIdx',
        select: 'select(activeIdx)',
        'move-in-progress': 'moveInProgress',
        query: 'query',
        position: 'position'
      });
      if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
        popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);
      }
      if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {
        popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);
      }
      var resetMatches = function() {
        scope.matches = [];
        scope.activeIdx = -1;
        element.attr('aria-expanded', false);
      };
      var getMatchId = function(index) {
        return popupId + '-option-' + index;
      };
      scope.$watch('activeIdx', function(index) {
        if (index < 0) {
          element.removeAttr('aria-activedescendant');
        } else {
          element.attr('aria-activedescendant', getMatchId(index));
        }
      });
      var inputIsExactMatch = function(inputValue, index) {
        if (scope.matches.length > index && inputValue) {
          return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();
        }
        return false;
      };
      var getMatchesAsync = function(inputValue) {
        var locals = {$viewValue: inputValue};
        isLoadingSetter(originalScope, true);
        isNoResultsSetter(originalScope, false);
        $q.when(parserResult.source(originalScope, locals)).then(function(matches) {
          var onCurrentRequest = (inputValue === modelCtrl.$viewValue);
          if (onCurrentRequest && hasFocus) {
            if (matches && matches.length > 0) {
              scope.activeIdx = focusFirst ? 0 : -1;
              isNoResultsSetter(originalScope, false);
              scope.matches.length = 0;
              for (var i = 0; i < matches.length; i++) {
                locals[parserResult.itemName] = matches[i];
                scope.matches.push({
                  id: getMatchId(i),
                  label: parserResult.viewMapper(scope, locals),
                  model: matches[i]
                });
              }
              scope.query = inputValue;
              recalculatePosition();
              element.attr('aria-expanded', true);
              if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {
                scope.select(0);
              }
            } else {
              resetMatches();
              isNoResultsSetter(originalScope, true);
            }
          }
          if (onCurrentRequest) {
            isLoadingSetter(originalScope, false);
          }
        }, function() {
          resetMatches();
          isLoadingSetter(originalScope, false);
          isNoResultsSetter(originalScope, true);
        });
      };
      if (appendToBody) {
        angular.element($window).bind('resize', fireRecalculating);
        $document.find('body').bind('scroll', fireRecalculating);
      }
      var timeoutEventPromise;
      scope.moveInProgress = false;
      function fireRecalculating() {
        if (!scope.moveInProgress) {
          scope.moveInProgress = true;
          scope.$digest();
        }
        if (timeoutEventPromise) {
          $timeout.cancel(timeoutEventPromise);
        }
        timeoutEventPromise = $timeout(function() {
          if (scope.matches.length) {
            recalculatePosition();
          }
          scope.moveInProgress = false;
        }, eventDebounceTime);
      }
      function recalculatePosition() {
        scope.position = appendToBody ? $position.offset(element) : $position.position(element);
        scope.position.top += element.prop('offsetHeight');
      }
      scope.query = undefined;
      var timeoutPromise;
      var scheduleSearchWithTimeout = function(inputValue) {
        timeoutPromise = $timeout(function() {
          getMatchesAsync(inputValue);
        }, waitTime);
      };
      var cancelPreviousTimeout = function() {
        if (timeoutPromise) {
          $timeout.cancel(timeoutPromise);
        }
      };
      resetMatches();
      scope.select = function(activeIdx) {
        var locals = {};
        var model,
            item;
        selected = true;
        locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
        model = parserResult.modelMapper(originalScope, locals);
        $setModelValue(originalScope, model);
        modelCtrl.$setValidity('editable', true);
        modelCtrl.$setValidity('parse', true);
        onSelectCallback(originalScope, {
          $item: item,
          $model: model,
          $label: parserResult.viewMapper(originalScope, locals)
        });
        resetMatches();
        if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {
          $timeout(function() {
            element[0].focus();
          }, 0, false);
        }
      };
      element.bind('keydown', function(evt) {
        if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
          return;
        }
        if (scope.activeIdx === -1 && (evt.which === 9 || evt.which === 13)) {
          resetMatches();
          scope.$digest();
          return;
        }
        evt.preventDefault();
        if (evt.which === 40) {
          scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
          scope.$digest();
        } else if (evt.which === 38) {
          scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;
          scope.$digest();
        } else if (evt.which === 13 || evt.which === 9) {
          scope.$apply(function() {
            scope.select(scope.activeIdx);
          });
        } else if (evt.which === 27) {
          evt.stopPropagation();
          resetMatches();
          scope.$digest();
        }
      });
      element.bind('blur', function() {
        if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {
          selected = true;
          scope.$apply(function() {
            scope.select(scope.activeIdx);
          });
        }
        hasFocus = false;
        selected = false;
      });
      var dismissClickHandler = function(evt) {
        if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {
          resetMatches();
          if (!$rootScope.$$phase) {
            scope.$digest();
          }
        }
      };
      $document.bind('click', dismissClickHandler);
      originalScope.$on('$destroy', function() {
        $document.unbind('click', dismissClickHandler);
        if (appendToBody || appendToElementId) {
          $popup.remove();
        }
        if (appendToBody) {
          angular.element($window).unbind('resize', fireRecalculating);
          $document.find('body').unbind('scroll', fireRecalculating);
        }
        popUpEl.remove();
      });
      var $popup = $compile(popUpEl)(scope);
      if (appendToBody) {
        $document.find('body').append($popup);
      } else if (appendToElementId !== false) {
        angular.element($document[0].getElementById(appendToElementId)).append($popup);
      } else {
        element.after($popup);
      }
      this.init = function(_modelCtrl, _ngModelOptions) {
        modelCtrl = _modelCtrl;
        ngModelOptions = _ngModelOptions;
        modelCtrl.$parsers.unshift(function(inputValue) {
          hasFocus = true;
          if (minLength === 0 || inputValue && inputValue.length >= minLength) {
            if (waitTime > 0) {
              cancelPreviousTimeout();
              scheduleSearchWithTimeout(inputValue);
            } else {
              getMatchesAsync(inputValue);
            }
          } else {
            isLoadingSetter(originalScope, false);
            cancelPreviousTimeout();
            resetMatches();
          }
          if (isEditable) {
            return inputValue;
          } else {
            if (!inputValue) {
              modelCtrl.$setValidity('editable', true);
              return null;
            } else {
              modelCtrl.$setValidity('editable', false);
              return undefined;
            }
          }
        });
        modelCtrl.$formatters.push(function(modelValue) {
          var candidateViewValue,
              emptyViewValue;
          var locals = {};
          if (!isEditable) {
            modelCtrl.$setValidity('editable', true);
          }
          if (inputFormatter) {
            locals.$model = modelValue;
            return inputFormatter(originalScope, locals);
          } else {
            locals[parserResult.itemName] = modelValue;
            candidateViewValue = parserResult.viewMapper(originalScope, locals);
            locals[parserResult.itemName] = undefined;
            emptyViewValue = parserResult.viewMapper(originalScope, locals);
            return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;
          }
        });
      };
    }]).directive('uibTypeahead', function() {
      return {
        controller: 'UibTypeaheadController',
        require: ['ngModel', '^?ngModelOptions', 'uibTypeahead'],
        link: function(originalScope, element, attrs, ctrls) {
          ctrls[2].init(ctrls[0], ctrls[1]);
        }
      };
    }).directive('uibTypeaheadPopup', function() {
      return {
        scope: {
          matches: '=',
          query: '=',
          active: '=',
          position: '&',
          moveInProgress: '=',
          select: '&'
        },
        replace: true,
        templateUrl: function(element, attrs) {
          return attrs.popupTemplateUrl || 'template/typeahead/typeahead-popup.html';
        },
        link: function(scope, element, attrs) {
          scope.templateUrl = attrs.templateUrl;
          scope.isOpen = function() {
            return scope.matches.length > 0;
          };
          scope.isActive = function(matchIdx) {
            return scope.active == matchIdx;
          };
          scope.selectActive = function(matchIdx) {
            scope.active = matchIdx;
          };
          scope.selectMatch = function(activeIdx) {
            scope.select({activeIdx: activeIdx});
          };
        }
      };
    }).directive('uibTypeaheadMatch', ['$templateRequest', '$compile', '$parse', function($templateRequest, $compile, $parse) {
      return {
        scope: {
          index: '=',
          match: '=',
          query: '='
        },
        link: function(scope, element, attrs) {
          var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'template/typeahead/typeahead-match.html';
          $templateRequest(tplUrl).then(function(tplContent) {
            $compile(tplContent.trim())(scope, function(clonedElement) {
              element.replaceWith(clonedElement);
            });
          });
        }
      };
    }]).filter('uibTypeaheadHighlight', ['$sce', '$injector', '$log', function($sce, $injector, $log) {
      var isSanitizePresent;
      isSanitizePresent = $injector.has('$sanitize');
      function escapeRegexp(queryToEscape) {
        return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
      }
      function containsHtml(matchItem) {
        return /<.*>/g.test(matchItem);
      }
      return function(matchItem, query) {
        if (!isSanitizePresent && containsHtml(matchItem)) {
          $log.warn('Unsafe use of typeahead please use ngSanitize');
        }
        matchItem = query ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem;
        if (!isSanitizePresent) {
          matchItem = $sce.trustAsHtml(matchItem);
        }
        return matchItem;
      };
    }]);
    angular.module('ui.bootstrap.typeahead').value('$typeaheadSuppressWarning', false).service('typeaheadParser', ['$parse', 'uibTypeaheadParser', '$log', '$typeaheadSuppressWarning', function($parse, uibTypeaheadParser, $log, $typeaheadSuppressWarning) {
      if (!$typeaheadSuppressWarning) {
        $log.warn('typeaheadParser is now deprecated. Use uibTypeaheadParser instead.');
      }
      return uibTypeaheadParser;
    }]).directive('typeahead', ['$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$uibPosition', 'typeaheadParser', '$log', '$typeaheadSuppressWarning', function($compile, $parse, $q, $timeout, $document, $window, $rootScope, $position, typeaheadParser, $log, $typeaheadSuppressWarning) {
      var HOT_KEYS = [9, 13, 27, 38, 40];
      var eventDebounceTime = 200;
      return {
        require: ['ngModel', '^?ngModelOptions'],
        link: function(originalScope, element, attrs, ctrls) {
          if (!$typeaheadSuppressWarning) {
            $log.warn('typeahead is now deprecated. Use uib-typeahead instead.');
          }
          var modelCtrl = ctrls[0];
          var ngModelOptions = ctrls[1];
          var minLength = originalScope.$eval(attrs.typeaheadMinLength);
          if (!minLength && minLength !== 0) {
            minLength = 1;
          }
          var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;
          var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;
          var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;
          var onSelectCallback = $parse(attrs.typeaheadOnSelect);
          var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;
          var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;
          var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;
          var appendToBody = attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;
          var appendToElementId = attrs.typeaheadAppendToElementId || false;
          var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;
          var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;
          var parsedModel = $parse(attrs.ngModel);
          var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');
          var $setModelValue = function(scope, newValue) {
            if (angular.isFunction(parsedModel(originalScope)) && ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {
              return invokeModelSetter(scope, {$$$p: newValue});
            } else {
              return parsedModel.assign(scope, newValue);
            }
          };
          var parserResult = typeaheadParser.parse(attrs.typeahead);
          var hasFocus;
          var selected;
          var scope = originalScope.$new();
          var offDestroy = originalScope.$on('$destroy', function() {
            scope.$destroy();
          });
          scope.$on('$destroy', offDestroy);
          var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
          element.attr({
            'aria-autocomplete': 'list',
            'aria-expanded': false,
            'aria-owns': popupId
          });
          var popUpEl = angular.element('<div typeahead-popup></div>');
          popUpEl.attr({
            id: popupId,
            matches: 'matches',
            active: 'activeIdx',
            select: 'select(activeIdx)',
            'move-in-progress': 'moveInProgress',
            query: 'query',
            position: 'position'
          });
          if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
            popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);
          }
          if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {
            popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);
          }
          var resetMatches = function() {
            scope.matches = [];
            scope.activeIdx = -1;
            element.attr('aria-expanded', false);
          };
          var getMatchId = function(index) {
            return popupId + '-option-' + index;
          };
          scope.$watch('activeIdx', function(index) {
            if (index < 0) {
              element.removeAttr('aria-activedescendant');
            } else {
              element.attr('aria-activedescendant', getMatchId(index));
            }
          });
          var inputIsExactMatch = function(inputValue, index) {
            if (scope.matches.length > index && inputValue) {
              return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();
            }
            return false;
          };
          var getMatchesAsync = function(inputValue) {
            var locals = {$viewValue: inputValue};
            isLoadingSetter(originalScope, true);
            isNoResultsSetter(originalScope, false);
            $q.when(parserResult.source(originalScope, locals)).then(function(matches) {
              var onCurrentRequest = (inputValue === modelCtrl.$viewValue);
              if (onCurrentRequest && hasFocus) {
                if (matches && matches.length > 0) {
                  scope.activeIdx = focusFirst ? 0 : -1;
                  isNoResultsSetter(originalScope, false);
                  scope.matches.length = 0;
                  for (var i = 0; i < matches.length; i++) {
                    locals[parserResult.itemName] = matches[i];
                    scope.matches.push({
                      id: getMatchId(i),
                      label: parserResult.viewMapper(scope, locals),
                      model: matches[i]
                    });
                  }
                  scope.query = inputValue;
                  recalculatePosition();
                  element.attr('aria-expanded', true);
                  if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {
                    scope.select(0);
                  }
                } else {
                  resetMatches();
                  isNoResultsSetter(originalScope, true);
                }
              }
              if (onCurrentRequest) {
                isLoadingSetter(originalScope, false);
              }
            }, function() {
              resetMatches();
              isLoadingSetter(originalScope, false);
              isNoResultsSetter(originalScope, true);
            });
          };
          if (appendToBody) {
            angular.element($window).bind('resize', fireRecalculating);
            $document.find('body').bind('scroll', fireRecalculating);
          }
          var timeoutEventPromise;
          scope.moveInProgress = false;
          function fireRecalculating() {
            if (!scope.moveInProgress) {
              scope.moveInProgress = true;
              scope.$digest();
            }
            if (timeoutEventPromise) {
              $timeout.cancel(timeoutEventPromise);
            }
            timeoutEventPromise = $timeout(function() {
              if (scope.matches.length) {
                recalculatePosition();
              }
              scope.moveInProgress = false;
            }, eventDebounceTime);
          }
          function recalculatePosition() {
            scope.position = appendToBody ? $position.offset(element) : $position.position(element);
            scope.position.top += element.prop('offsetHeight');
          }
          resetMatches();
          scope.query = undefined;
          var timeoutPromise;
          var scheduleSearchWithTimeout = function(inputValue) {
            timeoutPromise = $timeout(function() {
              getMatchesAsync(inputValue);
            }, waitTime);
          };
          var cancelPreviousTimeout = function() {
            if (timeoutPromise) {
              $timeout.cancel(timeoutPromise);
            }
          };
          modelCtrl.$parsers.unshift(function(inputValue) {
            hasFocus = true;
            if (minLength === 0 || inputValue && inputValue.length >= minLength) {
              if (waitTime > 0) {
                cancelPreviousTimeout();
                scheduleSearchWithTimeout(inputValue);
              } else {
                getMatchesAsync(inputValue);
              }
            } else {
              isLoadingSetter(originalScope, false);
              cancelPreviousTimeout();
              resetMatches();
            }
            if (isEditable) {
              return inputValue;
            } else {
              if (!inputValue) {
                modelCtrl.$setValidity('editable', true);
                return null;
              } else {
                modelCtrl.$setValidity('editable', false);
                return undefined;
              }
            }
          });
          modelCtrl.$formatters.push(function(modelValue) {
            var candidateViewValue,
                emptyViewValue;
            var locals = {};
            if (!isEditable) {
              modelCtrl.$setValidity('editable', true);
            }
            if (inputFormatter) {
              locals.$model = modelValue;
              return inputFormatter(originalScope, locals);
            } else {
              locals[parserResult.itemName] = modelValue;
              candidateViewValue = parserResult.viewMapper(originalScope, locals);
              locals[parserResult.itemName] = undefined;
              emptyViewValue = parserResult.viewMapper(originalScope, locals);
              return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;
            }
          });
          scope.select = function(activeIdx) {
            var locals = {};
            var model,
                item;
            selected = true;
            locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
            model = parserResult.modelMapper(originalScope, locals);
            $setModelValue(originalScope, model);
            modelCtrl.$setValidity('editable', true);
            modelCtrl.$setValidity('parse', true);
            onSelectCallback(originalScope, {
              $item: item,
              $model: model,
              $label: parserResult.viewMapper(originalScope, locals)
            });
            resetMatches();
            if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {
              $timeout(function() {
                element[0].focus();
              }, 0, false);
            }
          };
          element.bind('keydown', function(evt) {
            if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
              return;
            }
            if (scope.activeIdx === -1 && (evt.which === 9 || evt.which === 13)) {
              resetMatches();
              scope.$digest();
              return;
            }
            evt.preventDefault();
            if (evt.which === 40) {
              scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
              scope.$digest();
            } else if (evt.which === 38) {
              scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;
              scope.$digest();
            } else if (evt.which === 13 || evt.which === 9) {
              scope.$apply(function() {
                scope.select(scope.activeIdx);
              });
            } else if (evt.which === 27) {
              evt.stopPropagation();
              resetMatches();
              scope.$digest();
            }
          });
          element.bind('blur', function() {
            if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {
              selected = true;
              scope.$apply(function() {
                scope.select(scope.activeIdx);
              });
            }
            hasFocus = false;
            selected = false;
          });
          var dismissClickHandler = function(evt) {
            if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {
              resetMatches();
              if (!$rootScope.$$phase) {
                scope.$digest();
              }
            }
          };
          $document.bind('click', dismissClickHandler);
          originalScope.$on('$destroy', function() {
            $document.unbind('click', dismissClickHandler);
            if (appendToBody || appendToElementId) {
              $popup.remove();
            }
            if (appendToBody) {
              angular.element($window).unbind('resize', fireRecalculating);
              $document.find('body').unbind('scroll', fireRecalculating);
            }
            popUpEl.remove();
          });
          var $popup = $compile(popUpEl)(scope);
          if (appendToBody) {
            $document.find('body').append($popup);
          } else if (appendToElementId !== false) {
            angular.element($document[0].getElementById(appendToElementId)).append($popup);
          } else {
            element.after($popup);
          }
        }
      };
    }]).directive('typeaheadPopup', ['$typeaheadSuppressWarning', '$log', function($typeaheadSuppressWarning, $log) {
      return {
        scope: {
          matches: '=',
          query: '=',
          active: '=',
          position: '&',
          moveInProgress: '=',
          select: '&'
        },
        replace: true,
        templateUrl: function(element, attrs) {
          return attrs.popupTemplateUrl || 'template/typeahead/typeahead-popup.html';
        },
        link: function(scope, element, attrs) {
          if (!$typeaheadSuppressWarning) {
            $log.warn('typeahead-popup is now deprecated. Use uib-typeahead-popup instead.');
          }
          scope.templateUrl = attrs.templateUrl;
          scope.isOpen = function() {
            return scope.matches.length > 0;
          };
          scope.isActive = function(matchIdx) {
            return scope.active == matchIdx;
          };
          scope.selectActive = function(matchIdx) {
            scope.active = matchIdx;
          };
          scope.selectMatch = function(activeIdx) {
            scope.select({activeIdx: activeIdx});
          };
        }
      };
    }]).directive('typeaheadMatch', ['$templateRequest', '$compile', '$parse', '$typeaheadSuppressWarning', '$log', function($templateRequest, $compile, $parse, $typeaheadSuppressWarning, $log) {
      return {
        restrict: 'EA',
        scope: {
          index: '=',
          match: '=',
          query: '='
        },
        link: function(scope, element, attrs) {
          if (!$typeaheadSuppressWarning) {
            $log.warn('typeahead-match is now deprecated. Use uib-typeahead-match instead.');
          }
          var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'template/typeahead/typeahead-match.html';
          $templateRequest(tplUrl).then(function(tplContent) {
            $compile(tplContent.trim())(scope, function(clonedElement) {
              element.replaceWith(clonedElement);
            });
          });
        }
      };
    }]).filter('typeaheadHighlight', ['$sce', '$injector', '$log', '$typeaheadSuppressWarning', function($sce, $injector, $log, $typeaheadSuppressWarning) {
      var isSanitizePresent;
      isSanitizePresent = $injector.has('$sanitize');
      function escapeRegexp(queryToEscape) {
        return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
      }
      function containsHtml(matchItem) {
        return /<.*>/g.test(matchItem);
      }
      return function(matchItem, query) {
        if (!$typeaheadSuppressWarning) {
          $log.warn('typeaheadHighlight is now deprecated. Use uibTypeaheadHighlight instead.');
        }
        if (!isSanitizePresent && containsHtml(matchItem)) {
          $log.warn('Unsafe use of typeahead please use ngSanitize');
        }
        matchItem = query ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem;
        if (!isSanitizePresent) {
          matchItem = $sce.trustAsHtml(matchItem);
        }
        return matchItem;
      };
    }]);
    angular.module("template/accordion/accordion-group.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/accordion/accordion-group.html", "<div class=\"panel {{panelClass || 'panel-default'}}\">\n" + "  <div class=\"panel-heading\" ng-keypress=\"toggleOpen($event)\">\n" + "    <h4 class=\"panel-title\">\n" + "      <a href tabindex=\"0\" class=\"accordion-toggle\" ng-click=\"toggleOpen()\" uib-accordion-transclude=\"heading\"><span ng-class=\"{'text-muted': isDisabled}\">{{heading}}</span></a>\n" + "    </h4>\n" + "  </div>\n" + "  <div class=\"panel-collapse collapse\" uib-collapse=\"!isOpen\">\n" + "	  <div class=\"panel-body\" ng-transclude></div>\n" + "  </div>\n" + "</div>\n" + "");
    }]);
    angular.module("template/accordion/accordion.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/accordion/accordion.html", "<div class=\"panel-group\" ng-transclude></div>");
    }]);
    angular.module("template/alert/alert.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/alert/alert.html", "<div class=\"alert\" ng-class=\"['alert-' + (type || 'warning'), closeable ? 'alert-dismissible' : null]\" role=\"alert\">\n" + "    <button ng-show=\"closeable\" type=\"button\" class=\"close\" ng-click=\"close({$event: $event})\">\n" + "        <span aria-hidden=\"true\">&times;</span>\n" + "        <span class=\"sr-only\">Close</span>\n" + "    </button>\n" + "    <div ng-transclude></div>\n" + "</div>\n" + "");
    }]);
    angular.module("template/carousel/carousel.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/carousel/carousel.html", "<div ng-mouseenter=\"pause()\" ng-mouseleave=\"play()\" class=\"carousel\" ng-swipe-right=\"prev()\" ng-swipe-left=\"next()\">\n" + "  <div class=\"carousel-inner\" ng-transclude></div>\n" + "  <a role=\"button\" href class=\"left carousel-control\" ng-click=\"prev()\" ng-show=\"slides.length > 1\">\n" + "    <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></span>\n" + "    <span class=\"sr-only\">previous</span>\n" + "  </a>\n" + "  <a role=\"button\" href class=\"right carousel-control\" ng-click=\"next()\" ng-show=\"slides.length > 1\">\n" + "    <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></span>\n" + "    <span class=\"sr-only\">next</span>\n" + "  </a>\n" + "  <ol class=\"carousel-indicators\" ng-show=\"slides.length > 1\">\n" + "    <li ng-repeat=\"slide in slides | orderBy:indexOfSlide track by $index\" ng-class=\"{ active: isActive(slide) }\" ng-click=\"select(slide)\">\n" + "      <span class=\"sr-only\">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if=\"isActive(slide)\">, currently active</span></span>\n" + "    </li>\n" + "  </ol>\n" + "</div>");
    }]);
    angular.module("template/carousel/slide.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/carousel/slide.html", "<div ng-class=\"{\n" + "    'active': active\n" + "  }\" class=\"item text-center\" ng-transclude></div>\n" + "");
    }]);
    angular.module("template/datepicker/datepicker.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/datepicker/datepicker.html", "<div ng-switch=\"datepickerMode\" role=\"application\" ng-keydown=\"keydown($event)\">\n" + "  <uib-daypicker ng-switch-when=\"day\" tabindex=\"0\"></uib-daypicker>\n" + "  <uib-monthpicker ng-switch-when=\"month\" tabindex=\"0\"></uib-monthpicker>\n" + "  <uib-yearpicker ng-switch-when=\"year\" tabindex=\"0\"></uib-yearpicker>\n" + "</div>");
    }]);
    angular.module("template/datepicker/day.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/datepicker/day.html", "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" + "  <thead>\n" + "    <tr>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" + "      <th colspan=\"{{::5 + showWeeks}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\" style=\"width:100%;\"><strong>{{title}}</strong></button></th>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" + "    </tr>\n" + "    <tr>\n" + "      <th ng-if=\"showWeeks\" class=\"text-center\"></th>\n" + "      <th ng-repeat=\"label in ::labels track by $index\" class=\"text-center\"><small aria-label=\"{{::label.full}}\">{{::label.abbr}}</small></th>\n" + "    </tr>\n" + "  </thead>\n" + "  <tbody>\n" + "    <tr ng-repeat=\"row in rows track by $index\">\n" + "      <td ng-if=\"showWeeks\" class=\"text-center h6\"><em>{{ weekNumbers[$index] }}</em></td>\n" + "      <td ng-repeat=\"dt in row track by dt.date\" class=\"text-center\" role=\"gridcell\" id=\"{{::dt.uid}}\" ng-class=\"::dt.customClass\">\n" + "        <button type=\"button\" style=\"min-width:100%;\" class=\"btn btn-default btn-sm\" ng-class=\"{'btn-info': dt.selected, active: isActive(dt)}\" ng-click=\"select(dt.date)\" ng-disabled=\"dt.disabled\" tabindex=\"-1\"><span ng-class=\"::{'text-muted': dt.secondary, 'text-info': dt.current}\">{{::dt.label}}</span></button>\n" + "      </td>\n" + "    </tr>\n" + "  </tbody>\n" + "</table>\n" + "");
    }]);
    angular.module("template/datepicker/month.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/datepicker/month.html", "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" + "  <thead>\n" + "    <tr>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" + "      <th><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\" style=\"width:100%;\"><strong>{{title}}</strong></button></th>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" + "    </tr>\n" + "  </thead>\n" + "  <tbody>\n" + "    <tr ng-repeat=\"row in rows track by $index\">\n" + "      <td ng-repeat=\"dt in row track by dt.date\" class=\"text-center\" role=\"gridcell\" id=\"{{::dt.uid}}\" ng-class=\"::dt.customClass\">\n" + "        <button type=\"button\" style=\"min-width:100%;\" class=\"btn btn-default\" ng-class=\"{'btn-info': dt.selected, active: isActive(dt)}\" ng-click=\"select(dt.date)\" ng-disabled=\"dt.disabled\" tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" + "      </td>\n" + "    </tr>\n" + "  </tbody>\n" + "</table>\n" + "");
    }]);
    angular.module("template/datepicker/popup.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/datepicker/popup.html", "<ul class=\"dropdown-menu\" dropdown-nested ng-if=\"isOpen\" style=\"display: block\" ng-style=\"{top: position.top+'px', left: position.left+'px'}\" ng-keydown=\"keydown($event)\" ng-click=\"$event.stopPropagation()\">\n" + "	<li ng-transclude></li>\n" + "	<li ng-if=\"showButtonBar\" style=\"padding:10px 9px 2px\">\n" + "		<span class=\"btn-group pull-left\">\n" + "			<button type=\"button\" class=\"btn btn-sm btn-info\" ng-click=\"select('today')\" ng-disabled=\"isDisabled('today')\">{{ getText('current') }}</button>\n" + "			<button type=\"button\" class=\"btn btn-sm btn-danger\" ng-click=\"select(null)\">{{ getText('clear') }}</button>\n" + "		</span>\n" + "		<button type=\"button\" class=\"btn btn-sm btn-success pull-right\" ng-click=\"close()\">{{ getText('close') }}</button>\n" + "	</li>\n" + "</ul>\n" + "");
    }]);
    angular.module("template/datepicker/year.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/datepicker/year.html", "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" + "  <thead>\n" + "    <tr>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" + "      <th colspan=\"3\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\" style=\"width:100%;\"><strong>{{title}}</strong></button></th>\n" + "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" + "    </tr>\n" + "  </thead>\n" + "  <tbody>\n" + "    <tr ng-repeat=\"row in rows track by $index\">\n" + "      <td ng-repeat=\"dt in row track by dt.date\" class=\"text-center\" role=\"gridcell\" id=\"{{::dt.uid}}\" ng-class=\"::dt.customClass\">\n" + "        <button type=\"button\" style=\"min-width:100%;\" class=\"btn btn-default\" ng-class=\"{'btn-info': dt.selected, active: isActive(dt)}\" ng-click=\"select(dt.date)\" ng-disabled=\"dt.disabled\" tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" + "      </td>\n" + "    </tr>\n" + "  </tbody>\n" + "</table>\n" + "");
    }]);
    angular.module("template/modal/backdrop.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/modal/backdrop.html", "<div uib-modal-animation-class=\"fade\"\n" + "     modal-in-class=\"in\"\n" + "     ng-style=\"{'z-index': 1040 + (index && 1 || 0) + index*10}\"\n" + "></div>\n" + "");
    }]);
    angular.module("template/modal/window.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/modal/window.html", "<div modal-render=\"{{$isRendered}}\" tabindex=\"-1\" role=\"dialog\" class=\"modal\"\n" + "    uib-modal-animation-class=\"fade\"\n" + "    modal-in-class=\"in\"\n" + "    ng-style=\"{'z-index': 1050 + index*10, display: 'block'}\">\n" + "    <div class=\"modal-dialog\" ng-class=\"size ? 'modal-' + size : ''\"><div class=\"modal-content\" uib-modal-transclude></div></div>\n" + "</div>\n" + "");
    }]);
    angular.module("template/pagination/pager.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/pagination/pager.html", "<ul class=\"pager\">\n" + "  <li ng-class=\"{disabled: noPrevious()||ngDisabled, previous: align}\"><a href ng-click=\"selectPage(page - 1, $event)\">{{::getText('previous')}}</a></li>\n" + "  <li ng-class=\"{disabled: noNext()||ngDisabled, next: align}\"><a href ng-click=\"selectPage(page + 1, $event)\">{{::getText('next')}}</a></li>\n" + "</ul>\n" + "");
    }]);
    angular.module("template/pagination/pagination.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/pagination/pagination.html", "<ul class=\"pagination\">\n" + "  <li ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-first\"><a href ng-click=\"selectPage(1, $event)\">{{::getText('first')}}</a></li>\n" + "  <li ng-if=\"::directionLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-prev\"><a href ng-click=\"selectPage(page - 1, $event)\">{{::getText('previous')}}</a></li>\n" + "  <li ng-repeat=\"page in pages track by $index\" ng-class=\"{active: page.active,disabled: ngDisabled&&!page.active}\" class=\"pagination-page\"><a href ng-click=\"selectPage(page.number, $event)\">{{page.text}}</a></li>\n" + "  <li ng-if=\"::directionLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-next\"><a href ng-click=\"selectPage(page + 1, $event)\">{{::getText('next')}}</a></li>\n" + "  <li ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-last\"><a href ng-click=\"selectPage(totalPages, $event)\">{{::getText('last')}}</a></li>\n" + "</ul>\n" + "");
    }]);
    angular.module("template/tooltip/tooltip-html-popup.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/tooltip/tooltip-html-popup.html", "<div\n" + "  tooltip-animation-class=\"fade\"\n" + "  uib-tooltip-classes\n" + "  ng-class=\"{ in: isOpen() }\">\n" + "  <div class=\"tooltip-arrow\"></div>\n" + "  <div class=\"tooltip-inner\" ng-bind-html=\"contentExp()\"></div>\n" + "</div>\n" + "");
    }]);
    angular.module("template/tooltip/tooltip-popup.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/tooltip/tooltip-popup.html", "<div\n" + "  tooltip-animation-class=\"fade\"\n" + "  uib-tooltip-classes\n" + "  ng-class=\"{ in: isOpen() }\">\n" + "  <div class=\"tooltip-arrow\"></div>\n" + "  <div class=\"tooltip-inner\" ng-bind=\"content\"></div>\n" + "</div>\n" + "");
    }]);
    angular.module("template/tooltip/tooltip-template-popup.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/tooltip/tooltip-template-popup.html", "<div\n" + "  tooltip-animation-class=\"fade\"\n" + "  uib-tooltip-classes\n" + "  ng-class=\"{ in: isOpen() }\">\n" + "  <div class=\"tooltip-arrow\"></div>\n" + "  <div class=\"tooltip-inner\"\n" + "    uib-tooltip-template-transclude=\"contentExp()\"\n" + "    tooltip-template-transclude-scope=\"originScope()\"></div>\n" + "</div>\n" + "");
    }]);
    angular.module("template/popover/popover-html.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/popover/popover-html.html", "<div tooltip-animation-class=\"fade\"\n" + "  uib-tooltip-classes\n" + "  ng-class=\"{ in: isOpen() }\">\n" + "  <div class=\"arrow\"></div>\n" + "\n" + "  <div class=\"popover-inner\">\n" + "      <h3 class=\"popover-title\" ng-bind=\"title\" ng-if=\"title\"></h3>\n" + "      <div class=\"popover-content\" ng-bind-html=\"contentExp()\"></div>\n" + "  </div>\n" + "</div>\n" + "");
    }]);
    angular.module("template/popover/popover-template.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/popover/popover-template.html", "<div tooltip-animation-class=\"fade\"\n" + "  uib-tooltip-classes\n" + "  ng-class=\"{ in: isOpen() }\">\n" + "  <div class=\"arrow\"></div>\n" + "\n" + "  <div class=\"popover-inner\">\n" + "      <h3 class=\"popover-title\" ng-bind=\"title\" ng-if=\"title\"></h3>\n" + "      <div class=\"popover-content\"\n" + "        uib-tooltip-template-transclude=\"contentExp()\"\n" + "        tooltip-template-transclude-scope=\"originScope()\"></div>\n" + "  </div>\n" + "</div>\n" + "");
    }]);
    angular.module("template/popover/popover.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/popover/popover.html", "<div tooltip-animation-class=\"fade\"\n" + "  uib-tooltip-classes\n" + "  ng-class=\"{ in: isOpen() }\">\n" + "  <div class=\"arrow\"></div>\n" + "\n" + "  <div class=\"popover-inner\">\n" + "      <h3 class=\"popover-title\" ng-bind=\"title\" ng-if=\"title\"></h3>\n" + "      <div class=\"popover-content\" ng-bind=\"content\"></div>\n" + "  </div>\n" + "</div>\n" + "");
    }]);
    angular.module("template/progressbar/bar.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/progressbar/bar.html", "<div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" aria-labelledby=\"{{::title}}\" style=\"min-width: 0;\" ng-transclude></div>\n" + "");
    }]);
    angular.module("template/progressbar/progress.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/progressbar/progress.html", "<div class=\"progress\" ng-transclude aria-labelledby=\"{{::title}}\"></div>");
    }]);
    angular.module("template/progressbar/progressbar.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/progressbar/progressbar.html", "<div class=\"progress\">\n" + "  <div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" aria-labelledby=\"{{::title}}\" style=\"min-width: 0;\" ng-transclude></div>\n" + "</div>\n" + "");
    }]);
    angular.module("template/rating/rating.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/rating/rating.html", "<span ng-mouseleave=\"reset()\" ng-keydown=\"onKeydown($event)\" tabindex=\"0\" role=\"slider\" aria-valuemin=\"0\" aria-valuemax=\"{{range.length}}\" aria-valuenow=\"{{value}}\">\n" + "    <span ng-repeat-start=\"r in range track by $index\" class=\"sr-only\">({{ $index < value ? '*' : ' ' }})</span>\n" + "    <i ng-repeat-end ng-mouseenter=\"enter($index + 1)\" ng-click=\"rate($index + 1)\" class=\"glyphicon\" ng-class=\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\" ng-attr-title=\"{{r.title}}\" aria-valuetext=\"{{r.title}}\"></i>\n" + "</span>\n" + "");
    }]);
    angular.module("template/tabs/tab.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/tabs/tab.html", "<li ng-class=\"{active: active, disabled: disabled}\">\n" + "  <a href ng-click=\"select()\" uib-tab-heading-transclude>{{heading}}</a>\n" + "</li>\n" + "");
    }]);
    angular.module("template/tabs/tabset.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/tabs/tabset.html", "<div>\n" + "  <ul class=\"nav nav-{{type || 'tabs'}}\" ng-class=\"{'nav-stacked': vertical, 'nav-justified': justified}\" ng-transclude></ul>\n" + "  <div class=\"tab-content\">\n" + "    <div class=\"tab-pane\" \n" + "         ng-repeat=\"tab in tabs\" \n" + "         ng-class=\"{active: tab.active}\"\n" + "         uib-tab-content-transclude=\"tab\">\n" + "    </div>\n" + "  </div>\n" + "</div>\n" + "");
    }]);
    angular.module("template/timepicker/timepicker.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/timepicker/timepicker.html", "<table>\n" + "  <tbody>\n" + "    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" + "      <td><a ng-click=\"incrementHours()\" ng-class=\"{disabled: noIncrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementHours()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" + "      <td>&nbsp;</td>\n" + "      <td><a ng-click=\"incrementMinutes()\" ng-class=\"{disabled: noIncrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementMinutes()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" + "      <td ng-show=\"showMeridian\"></td>\n" + "    </tr>\n" + "    <tr>\n" + "      <td class=\"form-group\" ng-class=\"{'has-error': invalidHours}\">\n" + "        <input style=\"width:50px;\" type=\"text\" ng-model=\"hours\" ng-change=\"updateHours()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\">\n" + "      </td>\n" + "      <td>:</td>\n" + "      <td class=\"form-group\" ng-class=\"{'has-error': invalidMinutes}\">\n" + "        <input style=\"width:50px;\" type=\"text\" ng-model=\"minutes\" ng-change=\"updateMinutes()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\">\n" + "      </td>\n" + "      <td ng-show=\"showMeridian\"><button type=\"button\" ng-class=\"{disabled: noToggleMeridian()}\" class=\"btn btn-default text-center\" ng-click=\"toggleMeridian()\" ng-disabled=\"noToggleMeridian()\" tabindex=\"{{::tabindex}}\">{{meridian}}</button></td>\n" + "    </tr>\n" + "    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" + "      <td><a ng-click=\"decrementHours()\" ng-class=\"{disabled: noDecrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementHours()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" + "      <td>&nbsp;</td>\n" + "      <td><a ng-click=\"decrementMinutes()\" ng-class=\"{disabled: noDecrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementMinutes()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" + "      <td ng-show=\"showMeridian\"></td>\n" + "    </tr>\n" + "  </tbody>\n" + "</table>\n" + "");
    }]);
    angular.module("template/typeahead/typeahead-match.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/typeahead/typeahead-match.html", "<a href tabindex=\"-1\" ng-bind-html=\"match.label | uibTypeaheadHighlight:query\"></a>\n" + "");
    }]);
    angular.module("template/typeahead/typeahead-popup.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/typeahead/typeahead-popup.html", "<ul class=\"dropdown-menu\" ng-show=\"isOpen() && !moveInProgress\" ng-style=\"{top: position().top+'px', left: position().left+'px'}\" style=\"display: block;\" role=\"listbox\" aria-hidden=\"{{!isOpen()}}\">\n" + "    <li ng-repeat=\"match in matches track by $index\" ng-class=\"{active: isActive($index) }\" ng-mouseenter=\"selectActive($index)\" ng-click=\"selectMatch($index)\" role=\"option\" id=\"{{::match.id}}\">\n" + "        <div uib-typeahead-match index=\"$index\" match=\"match\" query=\"query\" template-url=\"templateUrl\"></div>\n" + "    </li>\n" + "</ul>\n" + "");
    }]);
    !angular.$$csp() && angular.element(document).find('head').prepend('<style type="text/css">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>');
  })();
  return _retrieveGlobal();
});

System.registerDynamic("github:angular-ui/bootstrap-bower@0.14.3/index", ["./ui-bootstrap-tpls"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('./ui-bootstrap-tpls');
  module.exports = 'ui.bootstrap';
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:angular-ui/bootstrap-bower@0.14.3", ["github:angular-ui/bootstrap-bower@0.14.3/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('github:angular-ui/bootstrap-bower@0.14.3/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:angular/bower-angular@1.4.8/angular", [], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, "angular", null);
  (function() {
    "format global";
    "exports angular";
    (function(window, document, undefined) {
      'use strict';
      function minErr(module, ErrorConstructor) {
        ErrorConstructor = ErrorConstructor || Error;
        return function() {
          var SKIP_INDEXES = 2;
          var templateArgs = arguments,
              code = templateArgs[0],
              message = '[' + (module ? module + ':' : '') + code + '] ',
              template = templateArgs[1],
              paramPrefix,
              i;
          message += template.replace(/\{\d+\}/g, function(match) {
            var index = +match.slice(1, -1),
                shiftedIndex = index + SKIP_INDEXES;
            if (shiftedIndex < templateArgs.length) {
              return toDebugString(templateArgs[shiftedIndex]);
            }
            return match;
          });
          message += '\nhttp://errors.angularjs.org/1.4.8/' + (module ? module + '/' : '') + code;
          for (i = SKIP_INDEXES, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {
            message += paramPrefix + 'p' + (i - SKIP_INDEXES) + '=' + encodeURIComponent(toDebugString(templateArgs[i]));
          }
          return new ErrorConstructor(message);
        };
      }
      var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
      var VALIDITY_STATE_PROPERTY = 'validity';
      var lowercase = function(string) {
        return isString(string) ? string.toLowerCase() : string;
      };
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var uppercase = function(string) {
        return isString(string) ? string.toUpperCase() : string;
      };
      var manualLowercase = function(s) {
        return isString(s) ? s.replace(/[A-Z]/g, function(ch) {
          return String.fromCharCode(ch.charCodeAt(0) | 32);
        }) : s;
      };
      var manualUppercase = function(s) {
        return isString(s) ? s.replace(/[a-z]/g, function(ch) {
          return String.fromCharCode(ch.charCodeAt(0) & ~32);
        }) : s;
      };
      if ('i' !== 'I'.toLowerCase()) {
        lowercase = manualLowercase;
        uppercase = manualUppercase;
      }
      var msie,
          jqLite,
          jQuery,
          slice = [].slice,
          splice = [].splice,
          push = [].push,
          toString = Object.prototype.toString,
          getPrototypeOf = Object.getPrototypeOf,
          ngMinErr = minErr('ng'),
          angular = window.angular || (window.angular = {}),
          angularModule,
          uid = 0;
      msie = document.documentMode;
      function isArrayLike(obj) {
        if (obj == null || isWindow(obj))
          return false;
        if (isArray(obj) || isString(obj) || (jqLite && obj instanceof jqLite))
          return true;
        var length = "length" in Object(obj) && obj.length;
        return isNumber(length) && (length >= 0 && (length - 1) in obj || typeof obj.item == 'function');
      }
      function forEach(obj, iterator, context) {
        var key,
            length;
        if (obj) {
          if (isFunction(obj)) {
            for (key in obj) {
              if (key != 'prototype' && key != 'length' && key != 'name' && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else if (isArray(obj) || isArrayLike(obj)) {
            var isPrimitive = typeof obj !== 'object';
            for (key = 0, length = obj.length; key < length; key++) {
              if (isPrimitive || key in obj) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else if (obj.forEach && obj.forEach !== forEach) {
            obj.forEach(iterator, context, obj);
          } else if (isBlankObject(obj)) {
            for (key in obj) {
              iterator.call(context, obj[key], key, obj);
            }
          } else if (typeof obj.hasOwnProperty === 'function') {
            for (key in obj) {
              if (obj.hasOwnProperty(key)) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else {
            for (key in obj) {
              if (hasOwnProperty.call(obj, key)) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          }
        }
        return obj;
      }
      function forEachSorted(obj, iterator, context) {
        var keys = Object.keys(obj).sort();
        for (var i = 0; i < keys.length; i++) {
          iterator.call(context, obj[keys[i]], keys[i]);
        }
        return keys;
      }
      function reverseParams(iteratorFn) {
        return function(value, key) {
          iteratorFn(key, value);
        };
      }
      function nextUid() {
        return ++uid;
      }
      function setHashKey(obj, h) {
        if (h) {
          obj.$$hashKey = h;
        } else {
          delete obj.$$hashKey;
        }
      }
      function baseExtend(dst, objs, deep) {
        var h = dst.$$hashKey;
        for (var i = 0,
            ii = objs.length; i < ii; ++i) {
          var obj = objs[i];
          if (!isObject(obj) && !isFunction(obj))
            continue;
          var keys = Object.keys(obj);
          for (var j = 0,
              jj = keys.length; j < jj; j++) {
            var key = keys[j];
            var src = obj[key];
            if (deep && isObject(src)) {
              if (isDate(src)) {
                dst[key] = new Date(src.valueOf());
              } else if (isRegExp(src)) {
                dst[key] = new RegExp(src);
              } else if (src.nodeName) {
                dst[key] = src.cloneNode(true);
              } else if (isElement(src)) {
                dst[key] = src.clone();
              } else {
                if (!isObject(dst[key]))
                  dst[key] = isArray(src) ? [] : {};
                baseExtend(dst[key], [src], true);
              }
            } else {
              dst[key] = src;
            }
          }
        }
        setHashKey(dst, h);
        return dst;
      }
      function extend(dst) {
        return baseExtend(dst, slice.call(arguments, 1), false);
      }
      function merge(dst) {
        return baseExtend(dst, slice.call(arguments, 1), true);
      }
      function toInt(str) {
        return parseInt(str, 10);
      }
      function inherit(parent, extra) {
        return extend(Object.create(parent), extra);
      }
      function noop() {}
      noop.$inject = [];
      function identity($) {
        return $;
      }
      identity.$inject = [];
      function valueFn(value) {
        return function() {
          return value;
        };
      }
      function hasCustomToString(obj) {
        return isFunction(obj.toString) && obj.toString !== toString;
      }
      function isUndefined(value) {
        return typeof value === 'undefined';
      }
      function isDefined(value) {
        return typeof value !== 'undefined';
      }
      function isObject(value) {
        return value !== null && typeof value === 'object';
      }
      function isBlankObject(value) {
        return value !== null && typeof value === 'object' && !getPrototypeOf(value);
      }
      function isString(value) {
        return typeof value === 'string';
      }
      function isNumber(value) {
        return typeof value === 'number';
      }
      function isDate(value) {
        return toString.call(value) === '[object Date]';
      }
      var isArray = Array.isArray;
      function isFunction(value) {
        return typeof value === 'function';
      }
      function isRegExp(value) {
        return toString.call(value) === '[object RegExp]';
      }
      function isWindow(obj) {
        return obj && obj.window === obj;
      }
      function isScope(obj) {
        return obj && obj.$evalAsync && obj.$watch;
      }
      function isFile(obj) {
        return toString.call(obj) === '[object File]';
      }
      function isFormData(obj) {
        return toString.call(obj) === '[object FormData]';
      }
      function isBlob(obj) {
        return toString.call(obj) === '[object Blob]';
      }
      function isBoolean(value) {
        return typeof value === 'boolean';
      }
      function isPromiseLike(obj) {
        return obj && isFunction(obj.then);
      }
      var TYPED_ARRAY_REGEXP = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array\]$/;
      function isTypedArray(value) {
        return value && isNumber(value.length) && TYPED_ARRAY_REGEXP.test(toString.call(value));
      }
      var trim = function(value) {
        return isString(value) ? value.trim() : value;
      };
      var escapeForRegexp = function(s) {
        return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
      };
      function isElement(node) {
        return !!(node && (node.nodeName || (node.prop && node.attr && node.find)));
      }
      function makeMap(str) {
        var obj = {},
            items = str.split(","),
            i;
        for (i = 0; i < items.length; i++) {
          obj[items[i]] = true;
        }
        return obj;
      }
      function nodeName_(element) {
        return lowercase(element.nodeName || (element[0] && element[0].nodeName));
      }
      function includes(array, obj) {
        return Array.prototype.indexOf.call(array, obj) != -1;
      }
      function arrayRemove(array, value) {
        var index = array.indexOf(value);
        if (index >= 0) {
          array.splice(index, 1);
        }
        return index;
      }
      function copy(source, destination) {
        var stackSource = [];
        var stackDest = [];
        if (destination) {
          if (isTypedArray(destination)) {
            throw ngMinErr('cpta', "Can't copy! TypedArray destination cannot be mutated.");
          }
          if (source === destination) {
            throw ngMinErr('cpi', "Can't copy! Source and destination are identical.");
          }
          if (isArray(destination)) {
            destination.length = 0;
          } else {
            forEach(destination, function(value, key) {
              if (key !== '$$hashKey') {
                delete destination[key];
              }
            });
          }
          stackSource.push(source);
          stackDest.push(destination);
          return copyRecurse(source, destination);
        }
        return copyElement(source);
        function copyRecurse(source, destination) {
          var h = destination.$$hashKey;
          var result,
              key;
          if (isArray(source)) {
            for (var i = 0,
                ii = source.length; i < ii; i++) {
              destination.push(copyElement(source[i]));
            }
          } else if (isBlankObject(source)) {
            for (key in source) {
              destination[key] = copyElement(source[key]);
            }
          } else if (source && typeof source.hasOwnProperty === 'function') {
            for (key in source) {
              if (source.hasOwnProperty(key)) {
                destination[key] = copyElement(source[key]);
              }
            }
          } else {
            for (key in source) {
              if (hasOwnProperty.call(source, key)) {
                destination[key] = copyElement(source[key]);
              }
            }
          }
          setHashKey(destination, h);
          return destination;
        }
        function copyElement(source) {
          if (!isObject(source)) {
            return source;
          }
          var index = stackSource.indexOf(source);
          if (index !== -1) {
            return stackDest[index];
          }
          if (isWindow(source) || isScope(source)) {
            throw ngMinErr('cpws', "Can't copy! Making copies of Window or Scope instances is not supported.");
          }
          var needsRecurse = false;
          var destination;
          if (isArray(source)) {
            destination = [];
            needsRecurse = true;
          } else if (isTypedArray(source)) {
            destination = new source.constructor(source);
          } else if (isDate(source)) {
            destination = new Date(source.getTime());
          } else if (isRegExp(source)) {
            destination = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
            destination.lastIndex = source.lastIndex;
          } else if (isFunction(source.cloneNode)) {
            destination = source.cloneNode(true);
          } else {
            destination = Object.create(getPrototypeOf(source));
            needsRecurse = true;
          }
          stackSource.push(source);
          stackDest.push(destination);
          return needsRecurse ? copyRecurse(source, destination) : destination;
        }
      }
      function shallowCopy(src, dst) {
        if (isArray(src)) {
          dst = dst || [];
          for (var i = 0,
              ii = src.length; i < ii; i++) {
            dst[i] = src[i];
          }
        } else if (isObject(src)) {
          dst = dst || {};
          for (var key in src) {
            if (!(key.charAt(0) === '$' && key.charAt(1) === '$')) {
              dst[key] = src[key];
            }
          }
        }
        return dst || src;
      }
      function equals(o1, o2) {
        if (o1 === o2)
          return true;
        if (o1 === null || o2 === null)
          return false;
        if (o1 !== o1 && o2 !== o2)
          return true;
        var t1 = typeof o1,
            t2 = typeof o2,
            length,
            key,
            keySet;
        if (t1 == t2) {
          if (t1 == 'object') {
            if (isArray(o1)) {
              if (!isArray(o2))
                return false;
              if ((length = o1.length) == o2.length) {
                for (key = 0; key < length; key++) {
                  if (!equals(o1[key], o2[key]))
                    return false;
                }
                return true;
              }
            } else if (isDate(o1)) {
              if (!isDate(o2))
                return false;
              return equals(o1.getTime(), o2.getTime());
            } else if (isRegExp(o1)) {
              return isRegExp(o2) ? o1.toString() == o2.toString() : false;
            } else {
              if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2) || isDate(o2) || isRegExp(o2))
                return false;
              keySet = createMap();
              for (key in o1) {
                if (key.charAt(0) === '$' || isFunction(o1[key]))
                  continue;
                if (!equals(o1[key], o2[key]))
                  return false;
                keySet[key] = true;
              }
              for (key in o2) {
                if (!(key in keySet) && key.charAt(0) !== '$' && isDefined(o2[key]) && !isFunction(o2[key]))
                  return false;
              }
              return true;
            }
          }
        }
        return false;
      }
      var csp = function() {
        if (!isDefined(csp.rules)) {
          var ngCspElement = (document.querySelector('[ng-csp]') || document.querySelector('[data-ng-csp]'));
          if (ngCspElement) {
            var ngCspAttribute = ngCspElement.getAttribute('ng-csp') || ngCspElement.getAttribute('data-ng-csp');
            csp.rules = {
              noUnsafeEval: !ngCspAttribute || (ngCspAttribute.indexOf('no-unsafe-eval') !== -1),
              noInlineStyle: !ngCspAttribute || (ngCspAttribute.indexOf('no-inline-style') !== -1)
            };
          } else {
            csp.rules = {
              noUnsafeEval: noUnsafeEval(),
              noInlineStyle: false
            };
          }
        }
        return csp.rules;
        function noUnsafeEval() {
          try {
            new Function('');
            return false;
          } catch (e) {
            return true;
          }
        }
      };
      var jq = function() {
        if (isDefined(jq.name_))
          return jq.name_;
        var el;
        var i,
            ii = ngAttrPrefixes.length,
            prefix,
            name;
        for (i = 0; i < ii; ++i) {
          prefix = ngAttrPrefixes[i];
          if (el = document.querySelector('[' + prefix.replace(':', '\\:') + 'jq]')) {
            name = el.getAttribute(prefix + 'jq');
            break;
          }
        }
        return (jq.name_ = name);
      };
      function concat(array1, array2, index) {
        return array1.concat(slice.call(array2, index));
      }
      function sliceArgs(args, startIndex) {
        return slice.call(args, startIndex || 0);
      }
      function bind(self, fn) {
        var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
        if (isFunction(fn) && !(fn instanceof RegExp)) {
          return curryArgs.length ? function() {
            return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs);
          } : function() {
            return arguments.length ? fn.apply(self, arguments) : fn.call(self);
          };
        } else {
          return fn;
        }
      }
      function toJsonReplacer(key, value) {
        var val = value;
        if (typeof key === 'string' && key.charAt(0) === '$' && key.charAt(1) === '$') {
          val = undefined;
        } else if (isWindow(value)) {
          val = '$WINDOW';
        } else if (value && document === value) {
          val = '$DOCUMENT';
        } else if (isScope(value)) {
          val = '$SCOPE';
        }
        return val;
      }
      function toJson(obj, pretty) {
        if (typeof obj === 'undefined')
          return undefined;
        if (!isNumber(pretty)) {
          pretty = pretty ? 2 : null;
        }
        return JSON.stringify(obj, toJsonReplacer, pretty);
      }
      function fromJson(json) {
        return isString(json) ? JSON.parse(json) : json;
      }
      function timezoneToOffset(timezone, fallback) {
        var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
        return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
      }
      function addDateMinutes(date, minutes) {
        date = new Date(date.getTime());
        date.setMinutes(date.getMinutes() + minutes);
        return date;
      }
      function convertTimezoneToLocal(date, timezone, reverse) {
        reverse = reverse ? -1 : 1;
        var timezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());
        return addDateMinutes(date, reverse * (timezoneOffset - date.getTimezoneOffset()));
      }
      function startingTag(element) {
        element = jqLite(element).clone();
        try {
          element.empty();
        } catch (e) {}
        var elemHtml = jqLite('<div>').append(element).html();
        try {
          return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function(match, nodeName) {
            return '<' + lowercase(nodeName);
          });
        } catch (e) {
          return lowercase(elemHtml);
        }
      }
      function tryDecodeURIComponent(value) {
        try {
          return decodeURIComponent(value);
        } catch (e) {}
      }
      function parseKeyValue(keyValue) {
        var obj = {};
        forEach((keyValue || "").split('&'), function(keyValue) {
          var splitPoint,
              key,
              val;
          if (keyValue) {
            key = keyValue = keyValue.replace(/\+/g, '%20');
            splitPoint = keyValue.indexOf('=');
            if (splitPoint !== -1) {
              key = keyValue.substring(0, splitPoint);
              val = keyValue.substring(splitPoint + 1);
            }
            key = tryDecodeURIComponent(key);
            if (isDefined(key)) {
              val = isDefined(val) ? tryDecodeURIComponent(val) : true;
              if (!hasOwnProperty.call(obj, key)) {
                obj[key] = val;
              } else if (isArray(obj[key])) {
                obj[key].push(val);
              } else {
                obj[key] = [obj[key], val];
              }
            }
          }
        });
        return obj;
      }
      function toKeyValue(obj) {
        var parts = [];
        forEach(obj, function(value, key) {
          if (isArray(value)) {
            forEach(value, function(arrayValue) {
              parts.push(encodeUriQuery(key, true) + (arrayValue === true ? '' : '=' + encodeUriQuery(arrayValue, true)));
            });
          } else {
            parts.push(encodeUriQuery(key, true) + (value === true ? '' : '=' + encodeUriQuery(value, true)));
          }
        });
        return parts.length ? parts.join('&') : '';
      }
      function encodeUriSegment(val) {
        return encodeUriQuery(val, true).replace(/%26/gi, '&').replace(/%3D/gi, '=').replace(/%2B/gi, '+');
      }
      function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%3B/gi, ';').replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));
      }
      var ngAttrPrefixes = ['ng-', 'data-ng-', 'ng:', 'x-ng-'];
      function getNgAttribute(element, ngAttr) {
        var attr,
            i,
            ii = ngAttrPrefixes.length;
        for (i = 0; i < ii; ++i) {
          attr = ngAttrPrefixes[i] + ngAttr;
          if (isString(attr = element.getAttribute(attr))) {
            return attr;
          }
        }
        return null;
      }
      function angularInit(element, bootstrap) {
        var appElement,
            module,
            config = {};
        forEach(ngAttrPrefixes, function(prefix) {
          var name = prefix + 'app';
          if (!appElement && element.hasAttribute && element.hasAttribute(name)) {
            appElement = element;
            module = element.getAttribute(name);
          }
        });
        forEach(ngAttrPrefixes, function(prefix) {
          var name = prefix + 'app';
          var candidate;
          if (!appElement && (candidate = element.querySelector('[' + name.replace(':', '\\:') + ']'))) {
            appElement = candidate;
            module = candidate.getAttribute(name);
          }
        });
        if (appElement) {
          config.strictDi = getNgAttribute(appElement, "strict-di") !== null;
          bootstrap(appElement, module ? [module] : [], config);
        }
      }
      function bootstrap(element, modules, config) {
        if (!isObject(config))
          config = {};
        var defaultConfig = {strictDi: false};
        config = extend(defaultConfig, config);
        var doBootstrap = function() {
          element = jqLite(element);
          if (element.injector()) {
            var tag = (element[0] === document) ? 'document' : startingTag(element);
            throw ngMinErr('btstrpd', "App Already Bootstrapped with this Element '{0}'", tag.replace(/</, '&lt;').replace(/>/, '&gt;'));
          }
          modules = modules || [];
          modules.unshift(['$provide', function($provide) {
            $provide.value('$rootElement', element);
          }]);
          if (config.debugInfoEnabled) {
            modules.push(['$compileProvider', function($compileProvider) {
              $compileProvider.debugInfoEnabled(true);
            }]);
          }
          modules.unshift('ng');
          var injector = createInjector(modules, config.strictDi);
          injector.invoke(['$rootScope', '$rootElement', '$compile', '$injector', function bootstrapApply(scope, element, compile, injector) {
            scope.$apply(function() {
              element.data('$injector', injector);
              compile(element)(scope);
            });
          }]);
          return injector;
        };
        var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;
        var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
        if (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {
          config.debugInfoEnabled = true;
          window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, '');
        }
        if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
          return doBootstrap();
        }
        window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');
        angular.resumeBootstrap = function(extraModules) {
          forEach(extraModules, function(module) {
            modules.push(module);
          });
          return doBootstrap();
        };
        if (isFunction(angular.resumeDeferredBootstrap)) {
          angular.resumeDeferredBootstrap();
        }
      }
      function reloadWithDebugInfo() {
        window.name = 'NG_ENABLE_DEBUG_INFO!' + window.name;
        window.location.reload();
      }
      function getTestability(rootElement) {
        var injector = angular.element(rootElement).injector();
        if (!injector) {
          throw ngMinErr('test', 'no injector found for element argument to getTestability');
        }
        return injector.get('$$testability');
      }
      var SNAKE_CASE_REGEXP = /[A-Z]/g;
      function snake_case(name, separator) {
        separator = separator || '_';
        return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
          return (pos ? separator : '') + letter.toLowerCase();
        });
      }
      var bindJQueryFired = false;
      var skipDestroyOnNextJQueryCleanData;
      function bindJQuery() {
        var originalCleanData;
        if (bindJQueryFired) {
          return;
        }
        var jqName = jq();
        jQuery = isUndefined(jqName) ? window.jQuery : !jqName ? undefined : window[jqName];
        if (jQuery && jQuery.fn.on) {
          jqLite = jQuery;
          extend(jQuery.fn, {
            scope: JQLitePrototype.scope,
            isolateScope: JQLitePrototype.isolateScope,
            controller: JQLitePrototype.controller,
            injector: JQLitePrototype.injector,
            inheritedData: JQLitePrototype.inheritedData
          });
          originalCleanData = jQuery.cleanData;
          jQuery.cleanData = function(elems) {
            var events;
            if (!skipDestroyOnNextJQueryCleanData) {
              for (var i = 0,
                  elem; (elem = elems[i]) != null; i++) {
                events = jQuery._data(elem, "events");
                if (events && events.$destroy) {
                  jQuery(elem).triggerHandler('$destroy');
                }
              }
            } else {
              skipDestroyOnNextJQueryCleanData = false;
            }
            originalCleanData(elems);
          };
        } else {
          jqLite = JQLite;
        }
        angular.element = jqLite;
        bindJQueryFired = true;
      }
      function assertArg(arg, name, reason) {
        if (!arg) {
          throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
        }
        return arg;
      }
      function assertArgFn(arg, name, acceptArrayAnnotation) {
        if (acceptArrayAnnotation && isArray(arg)) {
          arg = arg[arg.length - 1];
        }
        assertArg(isFunction(arg), name, 'not a function, got ' + (arg && typeof arg === 'object' ? arg.constructor.name || 'Object' : typeof arg));
        return arg;
      }
      function assertNotHasOwnProperty(name, context) {
        if (name === 'hasOwnProperty') {
          throw ngMinErr('badname', "hasOwnProperty is not a valid {0} name", context);
        }
      }
      function getter(obj, path, bindFnToScope) {
        if (!path)
          return obj;
        var keys = path.split('.');
        var key;
        var lastInstance = obj;
        var len = keys.length;
        for (var i = 0; i < len; i++) {
          key = keys[i];
          if (obj) {
            obj = (lastInstance = obj)[key];
          }
        }
        if (!bindFnToScope && isFunction(obj)) {
          return bind(lastInstance, obj);
        }
        return obj;
      }
      function getBlockNodes(nodes) {
        var node = nodes[0];
        var endNode = nodes[nodes.length - 1];
        var blockNodes;
        for (var i = 1; node !== endNode && (node = node.nextSibling); i++) {
          if (blockNodes || nodes[i] !== node) {
            if (!blockNodes) {
              blockNodes = jqLite(slice.call(nodes, 0, i));
            }
            blockNodes.push(node);
          }
        }
        return blockNodes || nodes;
      }
      function createMap() {
        return Object.create(null);
      }
      var NODE_TYPE_ELEMENT = 1;
      var NODE_TYPE_ATTRIBUTE = 2;
      var NODE_TYPE_TEXT = 3;
      var NODE_TYPE_COMMENT = 8;
      var NODE_TYPE_DOCUMENT = 9;
      var NODE_TYPE_DOCUMENT_FRAGMENT = 11;
      function setupModuleLoader(window) {
        var $injectorMinErr = minErr('$injector');
        var ngMinErr = minErr('ng');
        function ensure(obj, name, factory) {
          return obj[name] || (obj[name] = factory());
        }
        var angular = ensure(window, 'angular', Object);
        angular.$$minErr = angular.$$minErr || minErr;
        return ensure(angular, 'module', function() {
          var modules = {};
          return function module(name, requires, configFn) {
            var assertNotHasOwnProperty = function(name, context) {
              if (name === 'hasOwnProperty') {
                throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);
              }
            };
            assertNotHasOwnProperty(name, 'module');
            if (requires && modules.hasOwnProperty(name)) {
              modules[name] = null;
            }
            return ensure(modules, name, function() {
              if (!requires) {
                throw $injectorMinErr('nomod', "Module '{0}' is not available! You either misspelled " + "the module name or forgot to load it. If registering a module ensure that you " + "specify the dependencies as the second argument.", name);
              }
              var invokeQueue = [];
              var configBlocks = [];
              var runBlocks = [];
              var config = invokeLater('$injector', 'invoke', 'push', configBlocks);
              var moduleInstance = {
                _invokeQueue: invokeQueue,
                _configBlocks: configBlocks,
                _runBlocks: runBlocks,
                requires: requires,
                name: name,
                provider: invokeLaterAndSetModuleName('$provide', 'provider'),
                factory: invokeLaterAndSetModuleName('$provide', 'factory'),
                service: invokeLaterAndSetModuleName('$provide', 'service'),
                value: invokeLater('$provide', 'value'),
                constant: invokeLater('$provide', 'constant', 'unshift'),
                decorator: invokeLaterAndSetModuleName('$provide', 'decorator'),
                animation: invokeLaterAndSetModuleName('$animateProvider', 'register'),
                filter: invokeLaterAndSetModuleName('$filterProvider', 'register'),
                controller: invokeLaterAndSetModuleName('$controllerProvider', 'register'),
                directive: invokeLaterAndSetModuleName('$compileProvider', 'directive'),
                config: config,
                run: function(block) {
                  runBlocks.push(block);
                  return this;
                }
              };
              if (configFn) {
                config(configFn);
              }
              return moduleInstance;
              function invokeLater(provider, method, insertMethod, queue) {
                if (!queue)
                  queue = invokeQueue;
                return function() {
                  queue[insertMethod || 'push']([provider, method, arguments]);
                  return moduleInstance;
                };
              }
              function invokeLaterAndSetModuleName(provider, method) {
                return function(recipeName, factoryFunction) {
                  if (factoryFunction && isFunction(factoryFunction))
                    factoryFunction.$$moduleName = name;
                  invokeQueue.push([provider, method, arguments]);
                  return moduleInstance;
                };
              }
            });
          };
        });
      }
      function serializeObject(obj) {
        var seen = [];
        return JSON.stringify(obj, function(key, val) {
          val = toJsonReplacer(key, val);
          if (isObject(val)) {
            if (seen.indexOf(val) >= 0)
              return '...';
            seen.push(val);
          }
          return val;
        });
      }
      function toDebugString(obj) {
        if (typeof obj === 'function') {
          return obj.toString().replace(/ \{[\s\S]*$/, '');
        } else if (isUndefined(obj)) {
          return 'undefined';
        } else if (typeof obj !== 'string') {
          return serializeObject(obj);
        }
        return obj;
      }
      var version = {
        full: '1.4.8',
        major: 1,
        minor: 4,
        dot: 8,
        codeName: 'ice-manipulation'
      };
      function publishExternalAPI(angular) {
        extend(angular, {
          'bootstrap': bootstrap,
          'copy': copy,
          'extend': extend,
          'merge': merge,
          'equals': equals,
          'element': jqLite,
          'forEach': forEach,
          'injector': createInjector,
          'noop': noop,
          'bind': bind,
          'toJson': toJson,
          'fromJson': fromJson,
          'identity': identity,
          'isUndefined': isUndefined,
          'isDefined': isDefined,
          'isString': isString,
          'isFunction': isFunction,
          'isObject': isObject,
          'isNumber': isNumber,
          'isElement': isElement,
          'isArray': isArray,
          'version': version,
          'isDate': isDate,
          'lowercase': lowercase,
          'uppercase': uppercase,
          'callbacks': {counter: 0},
          'getTestability': getTestability,
          '$$minErr': minErr,
          '$$csp': csp,
          'reloadWithDebugInfo': reloadWithDebugInfo
        });
        angularModule = setupModuleLoader(window);
        angularModule('ng', ['ngLocale'], ['$provide', function ngModule($provide) {
          $provide.provider({$$sanitizeUri: $$SanitizeUriProvider});
          $provide.provider('$compile', $CompileProvider).directive({
            a: htmlAnchorDirective,
            input: inputDirective,
            textarea: inputDirective,
            form: formDirective,
            script: scriptDirective,
            select: selectDirective,
            style: styleDirective,
            option: optionDirective,
            ngBind: ngBindDirective,
            ngBindHtml: ngBindHtmlDirective,
            ngBindTemplate: ngBindTemplateDirective,
            ngClass: ngClassDirective,
            ngClassEven: ngClassEvenDirective,
            ngClassOdd: ngClassOddDirective,
            ngCloak: ngCloakDirective,
            ngController: ngControllerDirective,
            ngForm: ngFormDirective,
            ngHide: ngHideDirective,
            ngIf: ngIfDirective,
            ngInclude: ngIncludeDirective,
            ngInit: ngInitDirective,
            ngNonBindable: ngNonBindableDirective,
            ngPluralize: ngPluralizeDirective,
            ngRepeat: ngRepeatDirective,
            ngShow: ngShowDirective,
            ngStyle: ngStyleDirective,
            ngSwitch: ngSwitchDirective,
            ngSwitchWhen: ngSwitchWhenDirective,
            ngSwitchDefault: ngSwitchDefaultDirective,
            ngOptions: ngOptionsDirective,
            ngTransclude: ngTranscludeDirective,
            ngModel: ngModelDirective,
            ngList: ngListDirective,
            ngChange: ngChangeDirective,
            pattern: patternDirective,
            ngPattern: patternDirective,
            required: requiredDirective,
            ngRequired: requiredDirective,
            minlength: minlengthDirective,
            ngMinlength: minlengthDirective,
            maxlength: maxlengthDirective,
            ngMaxlength: maxlengthDirective,
            ngValue: ngValueDirective,
            ngModelOptions: ngModelOptionsDirective
          }).directive({ngInclude: ngIncludeFillContentDirective}).directive(ngAttributeAliasDirectives).directive(ngEventDirectives);
          $provide.provider({
            $anchorScroll: $AnchorScrollProvider,
            $animate: $AnimateProvider,
            $animateCss: $CoreAnimateCssProvider,
            $$animateQueue: $$CoreAnimateQueueProvider,
            $$AnimateRunner: $$CoreAnimateRunnerProvider,
            $browser: $BrowserProvider,
            $cacheFactory: $CacheFactoryProvider,
            $controller: $ControllerProvider,
            $document: $DocumentProvider,
            $exceptionHandler: $ExceptionHandlerProvider,
            $filter: $FilterProvider,
            $$forceReflow: $$ForceReflowProvider,
            $interpolate: $InterpolateProvider,
            $interval: $IntervalProvider,
            $http: $HttpProvider,
            $httpParamSerializer: $HttpParamSerializerProvider,
            $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
            $httpBackend: $HttpBackendProvider,
            $xhrFactory: $xhrFactoryProvider,
            $location: $LocationProvider,
            $log: $LogProvider,
            $parse: $ParseProvider,
            $rootScope: $RootScopeProvider,
            $q: $QProvider,
            $$q: $$QProvider,
            $sce: $SceProvider,
            $sceDelegate: $SceDelegateProvider,
            $sniffer: $SnifferProvider,
            $templateCache: $TemplateCacheProvider,
            $templateRequest: $TemplateRequestProvider,
            $$testability: $$TestabilityProvider,
            $timeout: $TimeoutProvider,
            $window: $WindowProvider,
            $$rAF: $$RAFProvider,
            $$jqLite: $$jqLiteProvider,
            $$HashMap: $$HashMapProvider,
            $$cookieReader: $$CookieReaderProvider
          });
        }]);
      }
      JQLite.expando = 'ng339';
      var jqCache = JQLite.cache = {},
          jqId = 1,
          addEventListenerFn = function(element, type, fn) {
            element.addEventListener(type, fn, false);
          },
          removeEventListenerFn = function(element, type, fn) {
            element.removeEventListener(type, fn, false);
          };
      JQLite._data = function(node) {
        return this.cache[node[this.expando]] || {};
      };
      function jqNextId() {
        return ++jqId;
      }
      var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
      var MOZ_HACK_REGEXP = /^moz([A-Z])/;
      var MOUSE_EVENT_MAP = {
        mouseleave: "mouseout",
        mouseenter: "mouseover"
      };
      var jqLiteMinErr = minErr('jqLite');
      function camelCase(name) {
        return name.replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
          return offset ? letter.toUpperCase() : letter;
        }).replace(MOZ_HACK_REGEXP, 'Moz$1');
      }
      var SINGLE_TAG_REGEXP = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/;
      var HTML_REGEXP = /<|&#?\w+;/;
      var TAG_NAME_REGEXP = /<([\w:-]+)/;
      var XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi;
      var wrapMap = {
        'option': [1, '<select multiple="multiple">', '</select>'],
        'thead': [1, '<table>', '</table>'],
        'col': [2, '<table><colgroup>', '</colgroup></table>'],
        'tr': [2, '<table><tbody>', '</tbody></table>'],
        'td': [3, '<table><tbody><tr>', '</tr></tbody></table>'],
        '_default': [0, "", ""]
      };
      wrapMap.optgroup = wrapMap.option;
      wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
      wrapMap.th = wrapMap.td;
      function jqLiteIsTextNode(html) {
        return !HTML_REGEXP.test(html);
      }
      function jqLiteAcceptsData(node) {
        var nodeType = node.nodeType;
        return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
      }
      function jqLiteHasData(node) {
        for (var key in jqCache[node.ng339]) {
          return true;
        }
        return false;
      }
      function jqLiteBuildFragment(html, context) {
        var tmp,
            tag,
            wrap,
            fragment = context.createDocumentFragment(),
            nodes = [],
            i;
        if (jqLiteIsTextNode(html)) {
          nodes.push(context.createTextNode(html));
        } else {
          tmp = tmp || fragment.appendChild(context.createElement("div"));
          tag = (TAG_NAME_REGEXP.exec(html) || ["", ""])[1].toLowerCase();
          wrap = wrapMap[tag] || wrapMap._default;
          tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2];
          i = wrap[0];
          while (i--) {
            tmp = tmp.lastChild;
          }
          nodes = concat(nodes, tmp.childNodes);
          tmp = fragment.firstChild;
          tmp.textContent = "";
        }
        fragment.textContent = "";
        fragment.innerHTML = "";
        forEach(nodes, function(node) {
          fragment.appendChild(node);
        });
        return fragment;
      }
      function jqLiteParseHTML(html, context) {
        context = context || document;
        var parsed;
        if ((parsed = SINGLE_TAG_REGEXP.exec(html))) {
          return [context.createElement(parsed[1])];
        }
        if ((parsed = jqLiteBuildFragment(html, context))) {
          return parsed.childNodes;
        }
        return [];
      }
      var jqLiteContains = Node.prototype.contains || function(arg) {
        return !!(this.compareDocumentPosition(arg) & 16);
      };
      function JQLite(element) {
        if (element instanceof JQLite) {
          return element;
        }
        var argIsString;
        if (isString(element)) {
          element = trim(element);
          argIsString = true;
        }
        if (!(this instanceof JQLite)) {
          if (argIsString && element.charAt(0) != '<') {
            throw jqLiteMinErr('nosel', 'Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element');
          }
          return new JQLite(element);
        }
        if (argIsString) {
          jqLiteAddNodes(this, jqLiteParseHTML(element));
        } else {
          jqLiteAddNodes(this, element);
        }
      }
      function jqLiteClone(element) {
        return element.cloneNode(true);
      }
      function jqLiteDealoc(element, onlyDescendants) {
        if (!onlyDescendants)
          jqLiteRemoveData(element);
        if (element.querySelectorAll) {
          var descendants = element.querySelectorAll('*');
          for (var i = 0,
              l = descendants.length; i < l; i++) {
            jqLiteRemoveData(descendants[i]);
          }
        }
      }
      function jqLiteOff(element, type, fn, unsupported) {
        if (isDefined(unsupported))
          throw jqLiteMinErr('offargs', 'jqLite#off() does not support the `selector` argument');
        var expandoStore = jqLiteExpandoStore(element);
        var events = expandoStore && expandoStore.events;
        var handle = expandoStore && expandoStore.handle;
        if (!handle)
          return;
        if (!type) {
          for (type in events) {
            if (type !== '$destroy') {
              removeEventListenerFn(element, type, handle);
            }
            delete events[type];
          }
        } else {
          var removeHandler = function(type) {
            var listenerFns = events[type];
            if (isDefined(fn)) {
              arrayRemove(listenerFns || [], fn);
            }
            if (!(isDefined(fn) && listenerFns && listenerFns.length > 0)) {
              removeEventListenerFn(element, type, handle);
              delete events[type];
            }
          };
          forEach(type.split(' '), function(type) {
            removeHandler(type);
            if (MOUSE_EVENT_MAP[type]) {
              removeHandler(MOUSE_EVENT_MAP[type]);
            }
          });
        }
      }
      function jqLiteRemoveData(element, name) {
        var expandoId = element.ng339;
        var expandoStore = expandoId && jqCache[expandoId];
        if (expandoStore) {
          if (name) {
            delete expandoStore.data[name];
            return;
          }
          if (expandoStore.handle) {
            if (expandoStore.events.$destroy) {
              expandoStore.handle({}, '$destroy');
            }
            jqLiteOff(element);
          }
          delete jqCache[expandoId];
          element.ng339 = undefined;
        }
      }
      function jqLiteExpandoStore(element, createIfNecessary) {
        var expandoId = element.ng339,
            expandoStore = expandoId && jqCache[expandoId];
        if (createIfNecessary && !expandoStore) {
          element.ng339 = expandoId = jqNextId();
          expandoStore = jqCache[expandoId] = {
            events: {},
            data: {},
            handle: undefined
          };
        }
        return expandoStore;
      }
      function jqLiteData(element, key, value) {
        if (jqLiteAcceptsData(element)) {
          var isSimpleSetter = isDefined(value);
          var isSimpleGetter = !isSimpleSetter && key && !isObject(key);
          var massGetter = !key;
          var expandoStore = jqLiteExpandoStore(element, !isSimpleGetter);
          var data = expandoStore && expandoStore.data;
          if (isSimpleSetter) {
            data[key] = value;
          } else {
            if (massGetter) {
              return data;
            } else {
              if (isSimpleGetter) {
                return data && data[key];
              } else {
                extend(data, key);
              }
            }
          }
        }
      }
      function jqLiteHasClass(element, selector) {
        if (!element.getAttribute)
          return false;
        return ((" " + (element.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1);
      }
      function jqLiteRemoveClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
          forEach(cssClasses.split(' '), function(cssClass) {
            element.setAttribute('class', trim((" " + (element.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").replace(" " + trim(cssClass) + " ", " ")));
          });
        }
      }
      function jqLiteAddClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
          var existingClasses = (' ' + (element.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, " ");
          forEach(cssClasses.split(' '), function(cssClass) {
            cssClass = trim(cssClass);
            if (existingClasses.indexOf(' ' + cssClass + ' ') === -1) {
              existingClasses += cssClass + ' ';
            }
          });
          element.setAttribute('class', trim(existingClasses));
        }
      }
      function jqLiteAddNodes(root, elements) {
        if (elements) {
          if (elements.nodeType) {
            root[root.length++] = elements;
          } else {
            var length = elements.length;
            if (typeof length === 'number' && elements.window !== elements) {
              if (length) {
                for (var i = 0; i < length; i++) {
                  root[root.length++] = elements[i];
                }
              }
            } else {
              root[root.length++] = elements;
            }
          }
        }
      }
      function jqLiteController(element, name) {
        return jqLiteInheritedData(element, '$' + (name || 'ngController') + 'Controller');
      }
      function jqLiteInheritedData(element, name, value) {
        if (element.nodeType == NODE_TYPE_DOCUMENT) {
          element = element.documentElement;
        }
        var names = isArray(name) ? name : [name];
        while (element) {
          for (var i = 0,
              ii = names.length; i < ii; i++) {
            if (isDefined(value = jqLite.data(element, names[i])))
              return value;
          }
          element = element.parentNode || (element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host);
        }
      }
      function jqLiteEmpty(element) {
        jqLiteDealoc(element, true);
        while (element.firstChild) {
          element.removeChild(element.firstChild);
        }
      }
      function jqLiteRemove(element, keepData) {
        if (!keepData)
          jqLiteDealoc(element);
        var parent = element.parentNode;
        if (parent)
          parent.removeChild(element);
      }
      function jqLiteDocumentLoaded(action, win) {
        win = win || window;
        if (win.document.readyState === 'complete') {
          win.setTimeout(action);
        } else {
          jqLite(win).on('load', action);
        }
      }
      var JQLitePrototype = JQLite.prototype = {
        ready: function(fn) {
          var fired = false;
          function trigger() {
            if (fired)
              return;
            fired = true;
            fn();
          }
          if (document.readyState === 'complete') {
            setTimeout(trigger);
          } else {
            this.on('DOMContentLoaded', trigger);
            JQLite(window).on('load', trigger);
          }
        },
        toString: function() {
          var value = [];
          forEach(this, function(e) {
            value.push('' + e);
          });
          return '[' + value.join(', ') + ']';
        },
        eq: function(index) {
          return (index >= 0) ? jqLite(this[index]) : jqLite(this[this.length + index]);
        },
        length: 0,
        push: push,
        sort: [].sort,
        splice: [].splice
      };
      var BOOLEAN_ATTR = {};
      forEach('multiple,selected,checked,disabled,readOnly,required,open'.split(','), function(value) {
        BOOLEAN_ATTR[lowercase(value)] = value;
      });
      var BOOLEAN_ELEMENTS = {};
      forEach('input,select,option,textarea,button,form,details'.split(','), function(value) {
        BOOLEAN_ELEMENTS[value] = true;
      });
      var ALIASED_ATTR = {
        'ngMinlength': 'minlength',
        'ngMaxlength': 'maxlength',
        'ngMin': 'min',
        'ngMax': 'max',
        'ngPattern': 'pattern'
      };
      function getBooleanAttrName(element, name) {
        var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
        return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
      }
      function getAliasedAttrName(name) {
        return ALIASED_ATTR[name];
      }
      forEach({
        data: jqLiteData,
        removeData: jqLiteRemoveData,
        hasData: jqLiteHasData
      }, function(fn, name) {
        JQLite[name] = fn;
      });
      forEach({
        data: jqLiteData,
        inheritedData: jqLiteInheritedData,
        scope: function(element) {
          return jqLite.data(element, '$scope') || jqLiteInheritedData(element.parentNode || element, ['$isolateScope', '$scope']);
        },
        isolateScope: function(element) {
          return jqLite.data(element, '$isolateScope') || jqLite.data(element, '$isolateScopeNoTemplate');
        },
        controller: jqLiteController,
        injector: function(element) {
          return jqLiteInheritedData(element, '$injector');
        },
        removeAttr: function(element, name) {
          element.removeAttribute(name);
        },
        hasClass: jqLiteHasClass,
        css: function(element, name, value) {
          name = camelCase(name);
          if (isDefined(value)) {
            element.style[name] = value;
          } else {
            return element.style[name];
          }
        },
        attr: function(element, name, value) {
          var nodeType = element.nodeType;
          if (nodeType === NODE_TYPE_TEXT || nodeType === NODE_TYPE_ATTRIBUTE || nodeType === NODE_TYPE_COMMENT) {
            return;
          }
          var lowercasedName = lowercase(name);
          if (BOOLEAN_ATTR[lowercasedName]) {
            if (isDefined(value)) {
              if (!!value) {
                element[name] = true;
                element.setAttribute(name, lowercasedName);
              } else {
                element[name] = false;
                element.removeAttribute(lowercasedName);
              }
            } else {
              return (element[name] || (element.attributes.getNamedItem(name) || noop).specified) ? lowercasedName : undefined;
            }
          } else if (isDefined(value)) {
            element.setAttribute(name, value);
          } else if (element.getAttribute) {
            var ret = element.getAttribute(name, 2);
            return ret === null ? undefined : ret;
          }
        },
        prop: function(element, name, value) {
          if (isDefined(value)) {
            element[name] = value;
          } else {
            return element[name];
          }
        },
        text: (function() {
          getText.$dv = '';
          return getText;
          function getText(element, value) {
            if (isUndefined(value)) {
              var nodeType = element.nodeType;
              return (nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT) ? element.textContent : '';
            }
            element.textContent = value;
          }
        })(),
        val: function(element, value) {
          if (isUndefined(value)) {
            if (element.multiple && nodeName_(element) === 'select') {
              var result = [];
              forEach(element.options, function(option) {
                if (option.selected) {
                  result.push(option.value || option.text);
                }
              });
              return result.length === 0 ? null : result;
            }
            return element.value;
          }
          element.value = value;
        },
        html: function(element, value) {
          if (isUndefined(value)) {
            return element.innerHTML;
          }
          jqLiteDealoc(element, true);
          element.innerHTML = value;
        },
        empty: jqLiteEmpty
      }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2) {
          var i,
              key;
          var nodeCount = this.length;
          if (fn !== jqLiteEmpty && (isUndefined((fn.length == 2 && (fn !== jqLiteHasClass && fn !== jqLiteController)) ? arg1 : arg2))) {
            if (isObject(arg1)) {
              for (i = 0; i < nodeCount; i++) {
                if (fn === jqLiteData) {
                  fn(this[i], arg1);
                } else {
                  for (key in arg1) {
                    fn(this[i], key, arg1[key]);
                  }
                }
              }
              return this;
            } else {
              var value = fn.$dv;
              var jj = (isUndefined(value)) ? Math.min(nodeCount, 1) : nodeCount;
              for (var j = 0; j < jj; j++) {
                var nodeValue = fn(this[j], arg1, arg2);
                value = value ? value + nodeValue : nodeValue;
              }
              return value;
            }
          } else {
            for (i = 0; i < nodeCount; i++) {
              fn(this[i], arg1, arg2);
            }
            return this;
          }
        };
      });
      function createEventHandler(element, events) {
        var eventHandler = function(event, type) {
          event.isDefaultPrevented = function() {
            return event.defaultPrevented;
          };
          var eventFns = events[type || event.type];
          var eventFnsLength = eventFns ? eventFns.length : 0;
          if (!eventFnsLength)
            return;
          if (isUndefined(event.immediatePropagationStopped)) {
            var originalStopImmediatePropagation = event.stopImmediatePropagation;
            event.stopImmediatePropagation = function() {
              event.immediatePropagationStopped = true;
              if (event.stopPropagation) {
                event.stopPropagation();
              }
              if (originalStopImmediatePropagation) {
                originalStopImmediatePropagation.call(event);
              }
            };
          }
          event.isImmediatePropagationStopped = function() {
            return event.immediatePropagationStopped === true;
          };
          var handlerWrapper = eventFns.specialHandlerWrapper || defaultHandlerWrapper;
          if ((eventFnsLength > 1)) {
            eventFns = shallowCopy(eventFns);
          }
          for (var i = 0; i < eventFnsLength; i++) {
            if (!event.isImmediatePropagationStopped()) {
              handlerWrapper(element, event, eventFns[i]);
            }
          }
        };
        eventHandler.elem = element;
        return eventHandler;
      }
      function defaultHandlerWrapper(element, event, handler) {
        handler.call(element, event);
      }
      function specialMouseHandlerWrapper(target, event, handler) {
        var related = event.relatedTarget;
        if (!related || (related !== target && !jqLiteContains.call(target, related))) {
          handler.call(target, event);
        }
      }
      forEach({
        removeData: jqLiteRemoveData,
        on: function jqLiteOn(element, type, fn, unsupported) {
          if (isDefined(unsupported))
            throw jqLiteMinErr('onargs', 'jqLite#on() does not support the `selector` or `eventData` parameters');
          if (!jqLiteAcceptsData(element)) {
            return;
          }
          var expandoStore = jqLiteExpandoStore(element, true);
          var events = expandoStore.events;
          var handle = expandoStore.handle;
          if (!handle) {
            handle = expandoStore.handle = createEventHandler(element, events);
          }
          var types = type.indexOf(' ') >= 0 ? type.split(' ') : [type];
          var i = types.length;
          var addHandler = function(type, specialHandlerWrapper, noEventListener) {
            var eventFns = events[type];
            if (!eventFns) {
              eventFns = events[type] = [];
              eventFns.specialHandlerWrapper = specialHandlerWrapper;
              if (type !== '$destroy' && !noEventListener) {
                addEventListenerFn(element, type, handle);
              }
            }
            eventFns.push(fn);
          };
          while (i--) {
            type = types[i];
            if (MOUSE_EVENT_MAP[type]) {
              addHandler(MOUSE_EVENT_MAP[type], specialMouseHandlerWrapper);
              addHandler(type, undefined, true);
            } else {
              addHandler(type);
            }
          }
        },
        off: jqLiteOff,
        one: function(element, type, fn) {
          element = jqLite(element);
          element.on(type, function onFn() {
            element.off(type, fn);
            element.off(type, onFn);
          });
          element.on(type, fn);
        },
        replaceWith: function(element, replaceNode) {
          var index,
              parent = element.parentNode;
          jqLiteDealoc(element);
          forEach(new JQLite(replaceNode), function(node) {
            if (index) {
              parent.insertBefore(node, index.nextSibling);
            } else {
              parent.replaceChild(node, element);
            }
            index = node;
          });
        },
        children: function(element) {
          var children = [];
          forEach(element.childNodes, function(element) {
            if (element.nodeType === NODE_TYPE_ELEMENT) {
              children.push(element);
            }
          });
          return children;
        },
        contents: function(element) {
          return element.contentDocument || element.childNodes || [];
        },
        append: function(element, node) {
          var nodeType = element.nodeType;
          if (nodeType !== NODE_TYPE_ELEMENT && nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT)
            return;
          node = new JQLite(node);
          for (var i = 0,
              ii = node.length; i < ii; i++) {
            var child = node[i];
            element.appendChild(child);
          }
        },
        prepend: function(element, node) {
          if (element.nodeType === NODE_TYPE_ELEMENT) {
            var index = element.firstChild;
            forEach(new JQLite(node), function(child) {
              element.insertBefore(child, index);
            });
          }
        },
        wrap: function(element, wrapNode) {
          wrapNode = jqLite(wrapNode).eq(0).clone()[0];
          var parent = element.parentNode;
          if (parent) {
            parent.replaceChild(wrapNode, element);
          }
          wrapNode.appendChild(element);
        },
        remove: jqLiteRemove,
        detach: function(element) {
          jqLiteRemove(element, true);
        },
        after: function(element, newElement) {
          var index = element,
              parent = element.parentNode;
          newElement = new JQLite(newElement);
          for (var i = 0,
              ii = newElement.length; i < ii; i++) {
            var node = newElement[i];
            parent.insertBefore(node, index.nextSibling);
            index = node;
          }
        },
        addClass: jqLiteAddClass,
        removeClass: jqLiteRemoveClass,
        toggleClass: function(element, selector, condition) {
          if (selector) {
            forEach(selector.split(' '), function(className) {
              var classCondition = condition;
              if (isUndefined(classCondition)) {
                classCondition = !jqLiteHasClass(element, className);
              }
              (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
            });
          }
        },
        parent: function(element) {
          var parent = element.parentNode;
          return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
        },
        next: function(element) {
          return element.nextElementSibling;
        },
        find: function(element, selector) {
          if (element.getElementsByTagName) {
            return element.getElementsByTagName(selector);
          } else {
            return [];
          }
        },
        clone: jqLiteClone,
        triggerHandler: function(element, event, extraParameters) {
          var dummyEvent,
              eventFnsCopy,
              handlerArgs;
          var eventName = event.type || event;
          var expandoStore = jqLiteExpandoStore(element);
          var events = expandoStore && expandoStore.events;
          var eventFns = events && events[eventName];
          if (eventFns) {
            dummyEvent = {
              preventDefault: function() {
                this.defaultPrevented = true;
              },
              isDefaultPrevented: function() {
                return this.defaultPrevented === true;
              },
              stopImmediatePropagation: function() {
                this.immediatePropagationStopped = true;
              },
              isImmediatePropagationStopped: function() {
                return this.immediatePropagationStopped === true;
              },
              stopPropagation: noop,
              type: eventName,
              target: element
            };
            if (event.type) {
              dummyEvent = extend(dummyEvent, event);
            }
            eventFnsCopy = shallowCopy(eventFns);
            handlerArgs = extraParameters ? [dummyEvent].concat(extraParameters) : [dummyEvent];
            forEach(eventFnsCopy, function(fn) {
              if (!dummyEvent.isImmediatePropagationStopped()) {
                fn.apply(element, handlerArgs);
              }
            });
          }
        }
      }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2, arg3) {
          var value;
          for (var i = 0,
              ii = this.length; i < ii; i++) {
            if (isUndefined(value)) {
              value = fn(this[i], arg1, arg2, arg3);
              if (isDefined(value)) {
                value = jqLite(value);
              }
            } else {
              jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
            }
          }
          return isDefined(value) ? value : this;
        };
        JQLite.prototype.bind = JQLite.prototype.on;
        JQLite.prototype.unbind = JQLite.prototype.off;
      });
      function $$jqLiteProvider() {
        this.$get = function $$jqLite() {
          return extend(JQLite, {
            hasClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteHasClass(node, classes);
            },
            addClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteAddClass(node, classes);
            },
            removeClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteRemoveClass(node, classes);
            }
          });
        };
      }
      function hashKey(obj, nextUidFn) {
        var key = obj && obj.$$hashKey;
        if (key) {
          if (typeof key === 'function') {
            key = obj.$$hashKey();
          }
          return key;
        }
        var objType = typeof obj;
        if (objType == 'function' || (objType == 'object' && obj !== null)) {
          key = obj.$$hashKey = objType + ':' + (nextUidFn || nextUid)();
        } else {
          key = objType + ':' + obj;
        }
        return key;
      }
      function HashMap(array, isolatedUid) {
        if (isolatedUid) {
          var uid = 0;
          this.nextUid = function() {
            return ++uid;
          };
        }
        forEach(array, this.put, this);
      }
      HashMap.prototype = {
        put: function(key, value) {
          this[hashKey(key, this.nextUid)] = value;
        },
        get: function(key) {
          return this[hashKey(key, this.nextUid)];
        },
        remove: function(key) {
          var value = this[key = hashKey(key, this.nextUid)];
          delete this[key];
          return value;
        }
      };
      var $$HashMapProvider = [function() {
        this.$get = [function() {
          return HashMap;
        }];
      }];
      var FN_ARGS = /^[^\(]*\(\s*([^\)]*)\)/m;
      var FN_ARG_SPLIT = /,/;
      var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
      var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
      var $injectorMinErr = minErr('$injector');
      function anonFn(fn) {
        var fnText = fn.toString().replace(STRIP_COMMENTS, ''),
            args = fnText.match(FN_ARGS);
        if (args) {
          return 'function(' + (args[1] || '').replace(/[\s\r\n]+/, ' ') + ')';
        }
        return 'fn';
      }
      function annotate(fn, strictDi, name) {
        var $inject,
            fnText,
            argDecl,
            last;
        if (typeof fn === 'function') {
          if (!($inject = fn.$inject)) {
            $inject = [];
            if (fn.length) {
              if (strictDi) {
                if (!isString(name) || !name) {
                  name = fn.name || anonFn(fn);
                }
                throw $injectorMinErr('strictdi', '{0} is not using explicit annotation and cannot be invoked in strict mode', name);
              }
              fnText = fn.toString().replace(STRIP_COMMENTS, '');
              argDecl = fnText.match(FN_ARGS);
              forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
                arg.replace(FN_ARG, function(all, underscore, name) {
                  $inject.push(name);
                });
              });
            }
            fn.$inject = $inject;
          }
        } else if (isArray(fn)) {
          last = fn.length - 1;
          assertArgFn(fn[last], 'fn');
          $inject = fn.slice(0, last);
        } else {
          assertArgFn(fn, 'fn', true);
        }
        return $inject;
      }
      function createInjector(modulesToLoad, strictDi) {
        strictDi = (strictDi === true);
        var INSTANTIATING = {},
            providerSuffix = 'Provider',
            path = [],
            loadedModules = new HashMap([], true),
            providerCache = {$provide: {
                provider: supportObject(provider),
                factory: supportObject(factory),
                service: supportObject(service),
                value: supportObject(value),
                constant: supportObject(constant),
                decorator: decorator
              }},
            providerInjector = (providerCache.$injector = createInternalInjector(providerCache, function(serviceName, caller) {
              if (angular.isString(caller)) {
                path.push(caller);
              }
              throw $injectorMinErr('unpr', "Unknown provider: {0}", path.join(' <- '));
            })),
            instanceCache = {},
            instanceInjector = (instanceCache.$injector = createInternalInjector(instanceCache, function(serviceName, caller) {
              var provider = providerInjector.get(serviceName + providerSuffix, caller);
              return instanceInjector.invoke(provider.$get, provider, undefined, serviceName);
            }));
        forEach(loadModules(modulesToLoad), function(fn) {
          if (fn)
            instanceInjector.invoke(fn);
        });
        return instanceInjector;
        function supportObject(delegate) {
          return function(key, value) {
            if (isObject(key)) {
              forEach(key, reverseParams(delegate));
            } else {
              return delegate(key, value);
            }
          };
        }
        function provider(name, provider_) {
          assertNotHasOwnProperty(name, 'service');
          if (isFunction(provider_) || isArray(provider_)) {
            provider_ = providerInjector.instantiate(provider_);
          }
          if (!provider_.$get) {
            throw $injectorMinErr('pget', "Provider '{0}' must define $get factory method.", name);
          }
          return providerCache[name + providerSuffix] = provider_;
        }
        function enforceReturnValue(name, factory) {
          return function enforcedReturnValue() {
            var result = instanceInjector.invoke(factory, this);
            if (isUndefined(result)) {
              throw $injectorMinErr('undef', "Provider '{0}' must return a value from $get factory method.", name);
            }
            return result;
          };
        }
        function factory(name, factoryFn, enforce) {
          return provider(name, {$get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn});
        }
        function service(name, constructor) {
          return factory(name, ['$injector', function($injector) {
            return $injector.instantiate(constructor);
          }]);
        }
        function value(name, val) {
          return factory(name, valueFn(val), false);
        }
        function constant(name, value) {
          assertNotHasOwnProperty(name, 'constant');
          providerCache[name] = value;
          instanceCache[name] = value;
        }
        function decorator(serviceName, decorFn) {
          var origProvider = providerInjector.get(serviceName + providerSuffix),
              orig$get = origProvider.$get;
          origProvider.$get = function() {
            var origInstance = instanceInjector.invoke(orig$get, origProvider);
            return instanceInjector.invoke(decorFn, null, {$delegate: origInstance});
          };
        }
        function loadModules(modulesToLoad) {
          assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), 'modulesToLoad', 'not an array');
          var runBlocks = [],
              moduleFn;
          forEach(modulesToLoad, function(module) {
            if (loadedModules.get(module))
              return;
            loadedModules.put(module, true);
            function runInvokeQueue(queue) {
              var i,
                  ii;
              for (i = 0, ii = queue.length; i < ii; i++) {
                var invokeArgs = queue[i],
                    provider = providerInjector.get(invokeArgs[0]);
                provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
              }
            }
            try {
              if (isString(module)) {
                moduleFn = angularModule(module);
                runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
                runInvokeQueue(moduleFn._invokeQueue);
                runInvokeQueue(moduleFn._configBlocks);
              } else if (isFunction(module)) {
                runBlocks.push(providerInjector.invoke(module));
              } else if (isArray(module)) {
                runBlocks.push(providerInjector.invoke(module));
              } else {
                assertArgFn(module, 'module');
              }
            } catch (e) {
              if (isArray(module)) {
                module = module[module.length - 1];
              }
              if (e.message && e.stack && e.stack.indexOf(e.message) == -1) {
                e = e.message + '\n' + e.stack;
              }
              throw $injectorMinErr('modulerr', "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e);
            }
          });
          return runBlocks;
        }
        function createInternalInjector(cache, factory) {
          function getService(serviceName, caller) {
            if (cache.hasOwnProperty(serviceName)) {
              if (cache[serviceName] === INSTANTIATING) {
                throw $injectorMinErr('cdep', 'Circular dependency found: {0}', serviceName + ' <- ' + path.join(' <- '));
              }
              return cache[serviceName];
            } else {
              try {
                path.unshift(serviceName);
                cache[serviceName] = INSTANTIATING;
                return cache[serviceName] = factory(serviceName, caller);
              } catch (err) {
                if (cache[serviceName] === INSTANTIATING) {
                  delete cache[serviceName];
                }
                throw err;
              } finally {
                path.shift();
              }
            }
          }
          function invoke(fn, self, locals, serviceName) {
            if (typeof locals === 'string') {
              serviceName = locals;
              locals = null;
            }
            var args = [],
                $inject = createInjector.$$annotate(fn, strictDi, serviceName),
                length,
                i,
                key;
            for (i = 0, length = $inject.length; i < length; i++) {
              key = $inject[i];
              if (typeof key !== 'string') {
                throw $injectorMinErr('itkn', 'Incorrect injection token! Expected service name as string, got {0}', key);
              }
              args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName));
            }
            if (isArray(fn)) {
              fn = fn[length];
            }
            return fn.apply(self, args);
          }
          function instantiate(Type, locals, serviceName) {
            var instance = Object.create((isArray(Type) ? Type[Type.length - 1] : Type).prototype || null);
            var returnedValue = invoke(Type, instance, locals, serviceName);
            return isObject(returnedValue) || isFunction(returnedValue) ? returnedValue : instance;
          }
          return {
            invoke: invoke,
            instantiate: instantiate,
            get: getService,
            annotate: createInjector.$$annotate,
            has: function(name) {
              return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
            }
          };
        }
      }
      createInjector.$$annotate = annotate;
      function $AnchorScrollProvider() {
        var autoScrollingEnabled = true;
        this.disableAutoScrolling = function() {
          autoScrollingEnabled = false;
        };
        this.$get = ['$window', '$location', '$rootScope', function($window, $location, $rootScope) {
          var document = $window.document;
          function getFirstAnchor(list) {
            var result = null;
            Array.prototype.some.call(list, function(element) {
              if (nodeName_(element) === 'a') {
                result = element;
                return true;
              }
            });
            return result;
          }
          function getYOffset() {
            var offset = scroll.yOffset;
            if (isFunction(offset)) {
              offset = offset();
            } else if (isElement(offset)) {
              var elem = offset[0];
              var style = $window.getComputedStyle(elem);
              if (style.position !== 'fixed') {
                offset = 0;
              } else {
                offset = elem.getBoundingClientRect().bottom;
              }
            } else if (!isNumber(offset)) {
              offset = 0;
            }
            return offset;
          }
          function scrollTo(elem) {
            if (elem) {
              elem.scrollIntoView();
              var offset = getYOffset();
              if (offset) {
                var elemTop = elem.getBoundingClientRect().top;
                $window.scrollBy(0, elemTop - offset);
              }
            } else {
              $window.scrollTo(0, 0);
            }
          }
          function scroll(hash) {
            hash = isString(hash) ? hash : $location.hash();
            var elm;
            if (!hash)
              scrollTo(null);
            else if ((elm = document.getElementById(hash)))
              scrollTo(elm);
            else if ((elm = getFirstAnchor(document.getElementsByName(hash))))
              scrollTo(elm);
            else if (hash === 'top')
              scrollTo(null);
          }
          if (autoScrollingEnabled) {
            $rootScope.$watch(function autoScrollWatch() {
              return $location.hash();
            }, function autoScrollWatchAction(newVal, oldVal) {
              if (newVal === oldVal && newVal === '')
                return;
              jqLiteDocumentLoaded(function() {
                $rootScope.$evalAsync(scroll);
              });
            });
          }
          return scroll;
        }];
      }
      var $animateMinErr = minErr('$animate');
      var ELEMENT_NODE = 1;
      var NG_ANIMATE_CLASSNAME = 'ng-animate';
      function mergeClasses(a, b) {
        if (!a && !b)
          return '';
        if (!a)
          return b;
        if (!b)
          return a;
        if (isArray(a))
          a = a.join(' ');
        if (isArray(b))
          b = b.join(' ');
        return a + ' ' + b;
      }
      function extractElementNode(element) {
        for (var i = 0; i < element.length; i++) {
          var elm = element[i];
          if (elm.nodeType === ELEMENT_NODE) {
            return elm;
          }
        }
      }
      function splitClasses(classes) {
        if (isString(classes)) {
          classes = classes.split(' ');
        }
        var obj = createMap();
        forEach(classes, function(klass) {
          if (klass.length) {
            obj[klass] = true;
          }
        });
        return obj;
      }
      function prepareAnimateOptions(options) {
        return isObject(options) ? options : {};
      }
      var $$CoreAnimateRunnerProvider = function() {
        this.$get = ['$q', '$$rAF', function($q, $$rAF) {
          function AnimateRunner() {}
          AnimateRunner.all = noop;
          AnimateRunner.chain = noop;
          AnimateRunner.prototype = {
            end: noop,
            cancel: noop,
            resume: noop,
            pause: noop,
            complete: noop,
            then: function(pass, fail) {
              return $q(function(resolve) {
                $$rAF(function() {
                  resolve();
                });
              }).then(pass, fail);
            }
          };
          return AnimateRunner;
        }];
      };
      var $$CoreAnimateQueueProvider = function() {
        var postDigestQueue = new HashMap();
        var postDigestElements = [];
        this.$get = ['$$AnimateRunner', '$rootScope', function($$AnimateRunner, $rootScope) {
          return {
            enabled: noop,
            on: noop,
            off: noop,
            pin: noop,
            push: function(element, event, options, domOperation) {
              domOperation && domOperation();
              options = options || {};
              options.from && element.css(options.from);
              options.to && element.css(options.to);
              if (options.addClass || options.removeClass) {
                addRemoveClassesPostDigest(element, options.addClass, options.removeClass);
              }
              return new $$AnimateRunner();
            }
          };
          function updateData(data, classes, value) {
            var changed = false;
            if (classes) {
              classes = isString(classes) ? classes.split(' ') : isArray(classes) ? classes : [];
              forEach(classes, function(className) {
                if (className) {
                  changed = true;
                  data[className] = value;
                }
              });
            }
            return changed;
          }
          function handleCSSClassChanges() {
            forEach(postDigestElements, function(element) {
              var data = postDigestQueue.get(element);
              if (data) {
                var existing = splitClasses(element.attr('class'));
                var toAdd = '';
                var toRemove = '';
                forEach(data, function(status, className) {
                  var hasClass = !!existing[className];
                  if (status !== hasClass) {
                    if (status) {
                      toAdd += (toAdd.length ? ' ' : '') + className;
                    } else {
                      toRemove += (toRemove.length ? ' ' : '') + className;
                    }
                  }
                });
                forEach(element, function(elm) {
                  toAdd && jqLiteAddClass(elm, toAdd);
                  toRemove && jqLiteRemoveClass(elm, toRemove);
                });
                postDigestQueue.remove(element);
              }
            });
            postDigestElements.length = 0;
          }
          function addRemoveClassesPostDigest(element, add, remove) {
            var data = postDigestQueue.get(element) || {};
            var classesAdded = updateData(data, add, true);
            var classesRemoved = updateData(data, remove, false);
            if (classesAdded || classesRemoved) {
              postDigestQueue.put(element, data);
              postDigestElements.push(element);
              if (postDigestElements.length === 1) {
                $rootScope.$$postDigest(handleCSSClassChanges);
              }
            }
          }
        }];
      };
      var $AnimateProvider = ['$provide', function($provide) {
        var provider = this;
        this.$$registeredAnimations = Object.create(null);
        this.register = function(name, factory) {
          if (name && name.charAt(0) !== '.') {
            throw $animateMinErr('notcsel', "Expecting class selector starting with '.' got '{0}'.", name);
          }
          var key = name + '-animation';
          provider.$$registeredAnimations[name.substr(1)] = key;
          $provide.factory(key, factory);
        };
        this.classNameFilter = function(expression) {
          if (arguments.length === 1) {
            this.$$classNameFilter = (expression instanceof RegExp) ? expression : null;
            if (this.$$classNameFilter) {
              var reservedRegex = new RegExp("(\\s+|\\/)" + NG_ANIMATE_CLASSNAME + "(\\s+|\\/)");
              if (reservedRegex.test(this.$$classNameFilter.toString())) {
                throw $animateMinErr('nongcls', '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', NG_ANIMATE_CLASSNAME);
              }
            }
          }
          return this.$$classNameFilter;
        };
        this.$get = ['$$animateQueue', function($$animateQueue) {
          function domInsert(element, parentElement, afterElement) {
            if (afterElement) {
              var afterNode = extractElementNode(afterElement);
              if (afterNode && !afterNode.parentNode && !afterNode.previousElementSibling) {
                afterElement = null;
              }
            }
            afterElement ? afterElement.after(element) : parentElement.prepend(element);
          }
          return {
            on: $$animateQueue.on,
            off: $$animateQueue.off,
            pin: $$animateQueue.pin,
            enabled: $$animateQueue.enabled,
            cancel: function(runner) {
              runner.end && runner.end();
            },
            enter: function(element, parent, after, options) {
              parent = parent && jqLite(parent);
              after = after && jqLite(after);
              parent = parent || after.parent();
              domInsert(element, parent, after);
              return $$animateQueue.push(element, 'enter', prepareAnimateOptions(options));
            },
            move: function(element, parent, after, options) {
              parent = parent && jqLite(parent);
              after = after && jqLite(after);
              parent = parent || after.parent();
              domInsert(element, parent, after);
              return $$animateQueue.push(element, 'move', prepareAnimateOptions(options));
            },
            leave: function(element, options) {
              return $$animateQueue.push(element, 'leave', prepareAnimateOptions(options), function() {
                element.remove();
              });
            },
            addClass: function(element, className, options) {
              options = prepareAnimateOptions(options);
              options.addClass = mergeClasses(options.addclass, className);
              return $$animateQueue.push(element, 'addClass', options);
            },
            removeClass: function(element, className, options) {
              options = prepareAnimateOptions(options);
              options.removeClass = mergeClasses(options.removeClass, className);
              return $$animateQueue.push(element, 'removeClass', options);
            },
            setClass: function(element, add, remove, options) {
              options = prepareAnimateOptions(options);
              options.addClass = mergeClasses(options.addClass, add);
              options.removeClass = mergeClasses(options.removeClass, remove);
              return $$animateQueue.push(element, 'setClass', options);
            },
            animate: function(element, from, to, className, options) {
              options = prepareAnimateOptions(options);
              options.from = options.from ? extend(options.from, from) : from;
              options.to = options.to ? extend(options.to, to) : to;
              className = className || 'ng-inline-animate';
              options.tempClasses = mergeClasses(options.tempClasses, className);
              return $$animateQueue.push(element, 'animate', options);
            }
          };
        }];
      }];
      var $CoreAnimateCssProvider = function() {
        this.$get = ['$$rAF', '$q', function($$rAF, $q) {
          var RAFPromise = function() {};
          RAFPromise.prototype = {
            done: function(cancel) {
              this.defer && this.defer[cancel === true ? 'reject' : 'resolve']();
            },
            end: function() {
              this.done();
            },
            cancel: function() {
              this.done(true);
            },
            getPromise: function() {
              if (!this.defer) {
                this.defer = $q.defer();
              }
              return this.defer.promise;
            },
            then: function(f1, f2) {
              return this.getPromise().then(f1, f2);
            },
            'catch': function(f1) {
              return this.getPromise()['catch'](f1);
            },
            'finally': function(f1) {
              return this.getPromise()['finally'](f1);
            }
          };
          return function(element, options) {
            if (options.cleanupStyles) {
              options.from = options.to = null;
            }
            if (options.from) {
              element.css(options.from);
              options.from = null;
            }
            var closed,
                runner = new RAFPromise();
            return {
              start: run,
              end: run
            };
            function run() {
              $$rAF(function() {
                close();
                if (!closed) {
                  runner.done();
                }
                closed = true;
              });
              return runner;
            }
            function close() {
              if (options.addClass) {
                element.addClass(options.addClass);
                options.addClass = null;
              }
              if (options.removeClass) {
                element.removeClass(options.removeClass);
                options.removeClass = null;
              }
              if (options.to) {
                element.css(options.to);
                options.to = null;
              }
            }
          };
        }];
      };
      function Browser(window, document, $log, $sniffer) {
        var self = this,
            rawDocument = document[0],
            location = window.location,
            history = window.history,
            setTimeout = window.setTimeout,
            clearTimeout = window.clearTimeout,
            pendingDeferIds = {};
        self.isMock = false;
        var outstandingRequestCount = 0;
        var outstandingRequestCallbacks = [];
        self.$$completeOutstandingRequest = completeOutstandingRequest;
        self.$$incOutstandingRequestCount = function() {
          outstandingRequestCount++;
        };
        function completeOutstandingRequest(fn) {
          try {
            fn.apply(null, sliceArgs(arguments, 1));
          } finally {
            outstandingRequestCount--;
            if (outstandingRequestCount === 0) {
              while (outstandingRequestCallbacks.length) {
                try {
                  outstandingRequestCallbacks.pop()();
                } catch (e) {
                  $log.error(e);
                }
              }
            }
          }
        }
        function getHash(url) {
          var index = url.indexOf('#');
          return index === -1 ? '' : url.substr(index);
        }
        self.notifyWhenNoOutstandingRequests = function(callback) {
          if (outstandingRequestCount === 0) {
            callback();
          } else {
            outstandingRequestCallbacks.push(callback);
          }
        };
        var cachedState,
            lastHistoryState,
            lastBrowserUrl = location.href,
            baseElement = document.find('base'),
            pendingLocation = null;
        cacheState();
        lastHistoryState = cachedState;
        self.url = function(url, replace, state) {
          if (isUndefined(state)) {
            state = null;
          }
          if (location !== window.location)
            location = window.location;
          if (history !== window.history)
            history = window.history;
          if (url) {
            var sameState = lastHistoryState === state;
            if (lastBrowserUrl === url && (!$sniffer.history || sameState)) {
              return self;
            }
            var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
            lastBrowserUrl = url;
            lastHistoryState = state;
            if ($sniffer.history && (!sameBase || !sameState)) {
              history[replace ? 'replaceState' : 'pushState'](state, '', url);
              cacheState();
              lastHistoryState = cachedState;
            } else {
              if (!sameBase || pendingLocation) {
                pendingLocation = url;
              }
              if (replace) {
                location.replace(url);
              } else if (!sameBase) {
                location.href = url;
              } else {
                location.hash = getHash(url);
              }
              if (location.href !== url) {
                pendingLocation = url;
              }
            }
            return self;
          } else {
            return pendingLocation || location.href.replace(/%27/g, "'");
          }
        };
        self.state = function() {
          return cachedState;
        };
        var urlChangeListeners = [],
            urlChangeInit = false;
        function cacheStateAndFireUrlChange() {
          pendingLocation = null;
          cacheState();
          fireUrlChange();
        }
        function getCurrentState() {
          try {
            return history.state;
          } catch (e) {}
        }
        var lastCachedState = null;
        function cacheState() {
          cachedState = getCurrentState();
          cachedState = isUndefined(cachedState) ? null : cachedState;
          if (equals(cachedState, lastCachedState)) {
            cachedState = lastCachedState;
          }
          lastCachedState = cachedState;
        }
        function fireUrlChange() {
          if (lastBrowserUrl === self.url() && lastHistoryState === cachedState) {
            return;
          }
          lastBrowserUrl = self.url();
          lastHistoryState = cachedState;
          forEach(urlChangeListeners, function(listener) {
            listener(self.url(), cachedState);
          });
        }
        self.onUrlChange = function(callback) {
          if (!urlChangeInit) {
            if ($sniffer.history)
              jqLite(window).on('popstate', cacheStateAndFireUrlChange);
            jqLite(window).on('hashchange', cacheStateAndFireUrlChange);
            urlChangeInit = true;
          }
          urlChangeListeners.push(callback);
          return callback;
        };
        self.$$applicationDestroyed = function() {
          jqLite(window).off('hashchange popstate', cacheStateAndFireUrlChange);
        };
        self.$$checkUrlChange = fireUrlChange;
        self.baseHref = function() {
          var href = baseElement.attr('href');
          return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, '') : '';
        };
        self.defer = function(fn, delay) {
          var timeoutId;
          outstandingRequestCount++;
          timeoutId = setTimeout(function() {
            delete pendingDeferIds[timeoutId];
            completeOutstandingRequest(fn);
          }, delay || 0);
          pendingDeferIds[timeoutId] = true;
          return timeoutId;
        };
        self.defer.cancel = function(deferId) {
          if (pendingDeferIds[deferId]) {
            delete pendingDeferIds[deferId];
            clearTimeout(deferId);
            completeOutstandingRequest(noop);
            return true;
          }
          return false;
        };
      }
      function $BrowserProvider() {
        this.$get = ['$window', '$log', '$sniffer', '$document', function($window, $log, $sniffer, $document) {
          return new Browser($window, $document, $log, $sniffer);
        }];
      }
      function $CacheFactoryProvider() {
        this.$get = function() {
          var caches = {};
          function cacheFactory(cacheId, options) {
            if (cacheId in caches) {
              throw minErr('$cacheFactory')('iid', "CacheId '{0}' is already taken!", cacheId);
            }
            var size = 0,
                stats = extend({}, options, {id: cacheId}),
                data = createMap(),
                capacity = (options && options.capacity) || Number.MAX_VALUE,
                lruHash = createMap(),
                freshEnd = null,
                staleEnd = null;
            return caches[cacheId] = {
              put: function(key, value) {
                if (isUndefined(value))
                  return;
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key] || (lruHash[key] = {key: key});
                  refresh(lruEntry);
                }
                if (!(key in data))
                  size++;
                data[key] = value;
                if (size > capacity) {
                  this.remove(staleEnd.key);
                }
                return value;
              },
              get: function(key) {
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key];
                  if (!lruEntry)
                    return;
                  refresh(lruEntry);
                }
                return data[key];
              },
              remove: function(key) {
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key];
                  if (!lruEntry)
                    return;
                  if (lruEntry == freshEnd)
                    freshEnd = lruEntry.p;
                  if (lruEntry == staleEnd)
                    staleEnd = lruEntry.n;
                  link(lruEntry.n, lruEntry.p);
                  delete lruHash[key];
                }
                if (!(key in data))
                  return;
                delete data[key];
                size--;
              },
              removeAll: function() {
                data = createMap();
                size = 0;
                lruHash = createMap();
                freshEnd = staleEnd = null;
              },
              destroy: function() {
                data = null;
                stats = null;
                lruHash = null;
                delete caches[cacheId];
              },
              info: function() {
                return extend({}, stats, {size: size});
              }
            };
            function refresh(entry) {
              if (entry != freshEnd) {
                if (!staleEnd) {
                  staleEnd = entry;
                } else if (staleEnd == entry) {
                  staleEnd = entry.n;
                }
                link(entry.n, entry.p);
                link(entry, freshEnd);
                freshEnd = entry;
                freshEnd.n = null;
              }
            }
            function link(nextEntry, prevEntry) {
              if (nextEntry != prevEntry) {
                if (nextEntry)
                  nextEntry.p = prevEntry;
                if (prevEntry)
                  prevEntry.n = nextEntry;
              }
            }
          }
          cacheFactory.info = function() {
            var info = {};
            forEach(caches, function(cache, cacheId) {
              info[cacheId] = cache.info();
            });
            return info;
          };
          cacheFactory.get = function(cacheId) {
            return caches[cacheId];
          };
          return cacheFactory;
        };
      }
      function $TemplateCacheProvider() {
        this.$get = ['$cacheFactory', function($cacheFactory) {
          return $cacheFactory('templates');
        }];
      }
      var $compileMinErr = minErr('$compile');
      $CompileProvider.$inject = ['$provide', '$$sanitizeUriProvider'];
      function $CompileProvider($provide, $$sanitizeUriProvider) {
        var hasDirectives = {},
            Suffix = 'Directive',
            COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/,
            CLASS_DIRECTIVE_REGEXP = /(([\w\-]+)(?:\:([^;]+))?;?)/,
            ALL_OR_NOTHING_ATTRS = makeMap('ngSrc,ngSrcset,src,srcset'),
            REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
        var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
        function parseIsolateBindings(scope, directiveName, isController) {
          var LOCAL_REGEXP = /^\s*([@&]|=(\*?))(\??)\s*(\w*)\s*$/;
          var bindings = {};
          forEach(scope, function(definition, scopeName) {
            var match = definition.match(LOCAL_REGEXP);
            if (!match) {
              throw $compileMinErr('iscp', "Invalid {3} for directive '{0}'." + " Definition: {... {1}: '{2}' ...}", directiveName, scopeName, definition, (isController ? "controller bindings definition" : "isolate scope definition"));
            }
            bindings[scopeName] = {
              mode: match[1][0],
              collection: match[2] === '*',
              optional: match[3] === '?',
              attrName: match[4] || scopeName
            };
          });
          return bindings;
        }
        function parseDirectiveBindings(directive, directiveName) {
          var bindings = {
            isolateScope: null,
            bindToController: null
          };
          if (isObject(directive.scope)) {
            if (directive.bindToController === true) {
              bindings.bindToController = parseIsolateBindings(directive.scope, directiveName, true);
              bindings.isolateScope = {};
            } else {
              bindings.isolateScope = parseIsolateBindings(directive.scope, directiveName, false);
            }
          }
          if (isObject(directive.bindToController)) {
            bindings.bindToController = parseIsolateBindings(directive.bindToController, directiveName, true);
          }
          if (isObject(bindings.bindToController)) {
            var controller = directive.controller;
            var controllerAs = directive.controllerAs;
            if (!controller) {
              throw $compileMinErr('noctrl', "Cannot bind to controller without directive '{0}'s controller.", directiveName);
            } else if (!identifierForController(controller, controllerAs)) {
              throw $compileMinErr('noident', "Cannot bind to controller without identifier for directive '{0}'.", directiveName);
            }
          }
          return bindings;
        }
        function assertValidDirectiveName(name) {
          var letter = name.charAt(0);
          if (!letter || letter !== lowercase(letter)) {
            throw $compileMinErr('baddir', "Directive name '{0}' is invalid. The first character must be a lowercase letter", name);
          }
          if (name !== name.trim()) {
            throw $compileMinErr('baddir', "Directive name '{0}' is invalid. The name should not contain leading or trailing whitespaces", name);
          }
        }
        this.directive = function registerDirective(name, directiveFactory) {
          assertNotHasOwnProperty(name, 'directive');
          if (isString(name)) {
            assertValidDirectiveName(name);
            assertArg(directiveFactory, 'directiveFactory');
            if (!hasDirectives.hasOwnProperty(name)) {
              hasDirectives[name] = [];
              $provide.factory(name + Suffix, ['$injector', '$exceptionHandler', function($injector, $exceptionHandler) {
                var directives = [];
                forEach(hasDirectives[name], function(directiveFactory, index) {
                  try {
                    var directive = $injector.invoke(directiveFactory);
                    if (isFunction(directive)) {
                      directive = {compile: valueFn(directive)};
                    } else if (!directive.compile && directive.link) {
                      directive.compile = valueFn(directive.link);
                    }
                    directive.priority = directive.priority || 0;
                    directive.index = index;
                    directive.name = directive.name || name;
                    directive.require = directive.require || (directive.controller && directive.name);
                    directive.restrict = directive.restrict || 'EA';
                    var bindings = directive.$$bindings = parseDirectiveBindings(directive, directive.name);
                    if (isObject(bindings.isolateScope)) {
                      directive.$$isolateBindings = bindings.isolateScope;
                    }
                    directive.$$moduleName = directiveFactory.$$moduleName;
                    directives.push(directive);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                });
                return directives;
              }]);
            }
            hasDirectives[name].push(directiveFactory);
          } else {
            forEach(name, reverseParams(registerDirective));
          }
          return this;
        };
        this.aHrefSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
            return this;
          } else {
            return $$sanitizeUriProvider.aHrefSanitizationWhitelist();
          }
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
            return this;
          } else {
            return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
          }
        };
        var debugInfoEnabled = true;
        this.debugInfoEnabled = function(enabled) {
          if (isDefined(enabled)) {
            debugInfoEnabled = enabled;
            return this;
          }
          return debugInfoEnabled;
        };
        this.$get = ['$injector', '$interpolate', '$exceptionHandler', '$templateRequest', '$parse', '$controller', '$rootScope', '$document', '$sce', '$animate', '$$sanitizeUri', function($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $document, $sce, $animate, $$sanitizeUri) {
          var Attributes = function(element, attributesToCopy) {
            if (attributesToCopy) {
              var keys = Object.keys(attributesToCopy);
              var i,
                  l,
                  key;
              for (i = 0, l = keys.length; i < l; i++) {
                key = keys[i];
                this[key] = attributesToCopy[key];
              }
            } else {
              this.$attr = {};
            }
            this.$$element = element;
          };
          Attributes.prototype = {
            $normalize: directiveNormalize,
            $addClass: function(classVal) {
              if (classVal && classVal.length > 0) {
                $animate.addClass(this.$$element, classVal);
              }
            },
            $removeClass: function(classVal) {
              if (classVal && classVal.length > 0) {
                $animate.removeClass(this.$$element, classVal);
              }
            },
            $updateClass: function(newClasses, oldClasses) {
              var toAdd = tokenDifference(newClasses, oldClasses);
              if (toAdd && toAdd.length) {
                $animate.addClass(this.$$element, toAdd);
              }
              var toRemove = tokenDifference(oldClasses, newClasses);
              if (toRemove && toRemove.length) {
                $animate.removeClass(this.$$element, toRemove);
              }
            },
            $set: function(key, value, writeAttr, attrName) {
              var node = this.$$element[0],
                  booleanKey = getBooleanAttrName(node, key),
                  aliasedKey = getAliasedAttrName(key),
                  observer = key,
                  nodeName;
              if (booleanKey) {
                this.$$element.prop(key, value);
                attrName = booleanKey;
              } else if (aliasedKey) {
                this[aliasedKey] = value;
                observer = aliasedKey;
              }
              this[key] = value;
              if (attrName) {
                this.$attr[key] = attrName;
              } else {
                attrName = this.$attr[key];
                if (!attrName) {
                  this.$attr[key] = attrName = snake_case(key, '-');
                }
              }
              nodeName = nodeName_(this.$$element);
              if ((nodeName === 'a' && key === 'href') || (nodeName === 'img' && key === 'src')) {
                this[key] = value = $$sanitizeUri(value, key === 'src');
              } else if (nodeName === 'img' && key === 'srcset') {
                var result = "";
                var trimmedSrcset = trim(value);
                var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
                var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;
                var rawUris = trimmedSrcset.split(pattern);
                var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
                for (var i = 0; i < nbrUrisWith2parts; i++) {
                  var innerIdx = i * 2;
                  result += $$sanitizeUri(trim(rawUris[innerIdx]), true);
                  result += (" " + trim(rawUris[innerIdx + 1]));
                }
                var lastTuple = trim(rawUris[i * 2]).split(/\s/);
                result += $$sanitizeUri(trim(lastTuple[0]), true);
                if (lastTuple.length === 2) {
                  result += (" " + trim(lastTuple[1]));
                }
                this[key] = value = result;
              }
              if (writeAttr !== false) {
                if (value === null || isUndefined(value)) {
                  this.$$element.removeAttr(attrName);
                } else {
                  this.$$element.attr(attrName, value);
                }
              }
              var $$observers = this.$$observers;
              $$observers && forEach($$observers[observer], function(fn) {
                try {
                  fn(value);
                } catch (e) {
                  $exceptionHandler(e);
                }
              });
            },
            $observe: function(key, fn) {
              var attrs = this,
                  $$observers = (attrs.$$observers || (attrs.$$observers = createMap())),
                  listeners = ($$observers[key] || ($$observers[key] = []));
              listeners.push(fn);
              $rootScope.$evalAsync(function() {
                if (!listeners.$$inter && attrs.hasOwnProperty(key) && !isUndefined(attrs[key])) {
                  fn(attrs[key]);
                }
              });
              return function() {
                arrayRemove(listeners, fn);
              };
            }
          };
          function safeAddClass($element, className) {
            try {
              $element.addClass(className);
            } catch (e) {}
          }
          var startSymbol = $interpolate.startSymbol(),
              endSymbol = $interpolate.endSymbol(),
              denormalizeTemplate = (startSymbol == '{{' || endSymbol == '}}') ? identity : function denormalizeTemplate(template) {
                return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
              },
              NG_ATTR_BINDING = /^ngAttr[A-Z]/;
          var MULTI_ELEMENT_DIR_RE = /^(.+)Start$/;
          compile.$$addBindingInfo = debugInfoEnabled ? function $$addBindingInfo($element, binding) {
            var bindings = $element.data('$binding') || [];
            if (isArray(binding)) {
              bindings = bindings.concat(binding);
            } else {
              bindings.push(binding);
            }
            $element.data('$binding', bindings);
          } : noop;
          compile.$$addBindingClass = debugInfoEnabled ? function $$addBindingClass($element) {
            safeAddClass($element, 'ng-binding');
          } : noop;
          compile.$$addScopeInfo = debugInfoEnabled ? function $$addScopeInfo($element, scope, isolated, noTemplate) {
            var dataName = isolated ? (noTemplate ? '$isolateScopeNoTemplate' : '$isolateScope') : '$scope';
            $element.data(dataName, scope);
          } : noop;
          compile.$$addScopeClass = debugInfoEnabled ? function $$addScopeClass($element, isolated) {
            safeAddClass($element, isolated ? 'ng-isolate-scope' : 'ng-scope');
          } : noop;
          return compile;
          function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
            if (!($compileNodes instanceof jqLite)) {
              $compileNodes = jqLite($compileNodes);
            }
            forEach($compileNodes, function(node, index) {
              if (node.nodeType == NODE_TYPE_TEXT && node.nodeValue.match(/\S+/)) {
                $compileNodes[index] = jqLite(node).wrap('<span></span>').parent()[0];
              }
            });
            var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
            compile.$$addScopeClass($compileNodes);
            var namespace = null;
            return function publicLinkFn(scope, cloneConnectFn, options) {
              assertArg(scope, 'scope');
              if (previousCompileContext && previousCompileContext.needsNewScope) {
                scope = scope.$parent.$new();
              }
              options = options || {};
              var parentBoundTranscludeFn = options.parentBoundTranscludeFn,
                  transcludeControllers = options.transcludeControllers,
                  futureParentElement = options.futureParentElement;
              if (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude) {
                parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
              }
              if (!namespace) {
                namespace = detectNamespaceForChildElements(futureParentElement);
              }
              var $linkNode;
              if (namespace !== 'html') {
                $linkNode = jqLite(wrapTemplate(namespace, jqLite('<div>').append($compileNodes).html()));
              } else if (cloneConnectFn) {
                $linkNode = JQLitePrototype.clone.call($compileNodes);
              } else {
                $linkNode = $compileNodes;
              }
              if (transcludeControllers) {
                for (var controllerName in transcludeControllers) {
                  $linkNode.data('$' + controllerName + 'Controller', transcludeControllers[controllerName].instance);
                }
              }
              compile.$$addScopeInfo($linkNode, scope);
              if (cloneConnectFn)
                cloneConnectFn($linkNode, scope);
              if (compositeLinkFn)
                compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
              return $linkNode;
            };
          }
          function detectNamespaceForChildElements(parentElement) {
            var node = parentElement && parentElement[0];
            if (!node) {
              return 'html';
            } else {
              return nodeName_(node) !== 'foreignobject' && node.toString().match(/SVG/) ? 'svg' : 'html';
            }
          }
          function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
            var linkFns = [],
                attrs,
                directives,
                nodeLinkFn,
                childNodes,
                childLinkFn,
                linkFnFound,
                nodeLinkFnFound;
            for (var i = 0; i < nodeList.length; i++) {
              attrs = new Attributes();
              directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined, ignoreDirective);
              nodeLinkFn = (directives.length) ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null;
              if (nodeLinkFn && nodeLinkFn.scope) {
                compile.$$addScopeClass(attrs.$$element);
              }
              childLinkFn = (nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length) ? null : compileNodes(childNodes, nodeLinkFn ? ((nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude) : transcludeFn);
              if (nodeLinkFn || childLinkFn) {
                linkFns.push(i, nodeLinkFn, childLinkFn);
                linkFnFound = true;
                nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
              }
              previousCompileContext = null;
            }
            return linkFnFound ? compositeLinkFn : null;
            function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
              var nodeLinkFn,
                  childLinkFn,
                  node,
                  childScope,
                  i,
                  ii,
                  idx,
                  childBoundTranscludeFn;
              var stableNodeList;
              if (nodeLinkFnFound) {
                var nodeListLength = nodeList.length;
                stableNodeList = new Array(nodeListLength);
                for (i = 0; i < linkFns.length; i += 3) {
                  idx = linkFns[i];
                  stableNodeList[idx] = nodeList[idx];
                }
              } else {
                stableNodeList = nodeList;
              }
              for (i = 0, ii = linkFns.length; i < ii; ) {
                node = stableNodeList[linkFns[i++]];
                nodeLinkFn = linkFns[i++];
                childLinkFn = linkFns[i++];
                if (nodeLinkFn) {
                  if (nodeLinkFn.scope) {
                    childScope = scope.$new();
                    compile.$$addScopeInfo(jqLite(node), childScope);
                  } else {
                    childScope = scope;
                  }
                  if (nodeLinkFn.transcludeOnThisElement) {
                    childBoundTranscludeFn = createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn);
                  } else if (!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn) {
                    childBoundTranscludeFn = parentBoundTranscludeFn;
                  } else if (!parentBoundTranscludeFn && transcludeFn) {
                    childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);
                  } else {
                    childBoundTranscludeFn = null;
                  }
                  nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn);
                } else if (childLinkFn) {
                  childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
                }
              }
            }
          }
          function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
            var boundTranscludeFn = function(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
              if (!transcludedScope) {
                transcludedScope = scope.$new(false, containingScope);
                transcludedScope.$$transcluded = true;
              }
              return transcludeFn(transcludedScope, cloneFn, {
                parentBoundTranscludeFn: previousBoundTranscludeFn,
                transcludeControllers: controllers,
                futureParentElement: futureParentElement
              });
            };
            return boundTranscludeFn;
          }
          function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
            var nodeType = node.nodeType,
                attrsMap = attrs.$attr,
                match,
                className;
            switch (nodeType) {
              case NODE_TYPE_ELEMENT:
                addDirective(directives, directiveNormalize(nodeName_(node)), 'E', maxPriority, ignoreDirective);
                for (var attr,
                    name,
                    nName,
                    ngAttrName,
                    value,
                    isNgAttr,
                    nAttrs = node.attributes,
                    j = 0,
                    jj = nAttrs && nAttrs.length; j < jj; j++) {
                  var attrStartName = false;
                  var attrEndName = false;
                  attr = nAttrs[j];
                  name = attr.name;
                  value = trim(attr.value);
                  ngAttrName = directiveNormalize(name);
                  if (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) {
                    name = name.replace(PREFIX_REGEXP, '').substr(8).replace(/_(.)/g, function(match, letter) {
                      return letter.toUpperCase();
                    });
                  }
                  var multiElementMatch = ngAttrName.match(MULTI_ELEMENT_DIR_RE);
                  if (multiElementMatch && directiveIsMultiElement(multiElementMatch[1])) {
                    attrStartName = name;
                    attrEndName = name.substr(0, name.length - 5) + 'end';
                    name = name.substr(0, name.length - 6);
                  }
                  nName = directiveNormalize(name.toLowerCase());
                  attrsMap[nName] = name;
                  if (isNgAttr || !attrs.hasOwnProperty(nName)) {
                    attrs[nName] = value;
                    if (getBooleanAttrName(node, nName)) {
                      attrs[nName] = true;
                    }
                  }
                  addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);
                  addDirective(directives, nName, 'A', maxPriority, ignoreDirective, attrStartName, attrEndName);
                }
                className = node.className;
                if (isObject(className)) {
                  className = className.animVal;
                }
                if (isString(className) && className !== '') {
                  while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                    nName = directiveNormalize(match[2]);
                    if (addDirective(directives, nName, 'C', maxPriority, ignoreDirective)) {
                      attrs[nName] = trim(match[3]);
                    }
                    className = className.substr(match.index + match[0].length);
                  }
                }
                break;
              case NODE_TYPE_TEXT:
                if (msie === 11) {
                  while (node.parentNode && node.nextSibling && node.nextSibling.nodeType === NODE_TYPE_TEXT) {
                    node.nodeValue = node.nodeValue + node.nextSibling.nodeValue;
                    node.parentNode.removeChild(node.nextSibling);
                  }
                }
                addTextInterpolateDirective(directives, node.nodeValue);
                break;
              case NODE_TYPE_COMMENT:
                try {
                  match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                  if (match) {
                    nName = directiveNormalize(match[1]);
                    if (addDirective(directives, nName, 'M', maxPriority, ignoreDirective)) {
                      attrs[nName] = trim(match[2]);
                    }
                  }
                } catch (e) {}
                break;
            }
            directives.sort(byPriority);
            return directives;
          }
          function groupScan(node, attrStart, attrEnd) {
            var nodes = [];
            var depth = 0;
            if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
              do {
                if (!node) {
                  throw $compileMinErr('uterdir', "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                }
                if (node.nodeType == NODE_TYPE_ELEMENT) {
                  if (node.hasAttribute(attrStart))
                    depth++;
                  if (node.hasAttribute(attrEnd))
                    depth--;
                }
                nodes.push(node);
                node = node.nextSibling;
              } while (depth > 0);
            } else {
              nodes.push(node);
            }
            return jqLite(nodes);
          }
          function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
            return function(scope, element, attrs, controllers, transcludeFn) {
              element = groupScan(element[0], attrStart, attrEnd);
              return linkFn(scope, element, attrs, controllers, transcludeFn);
            };
          }
          function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
            previousCompileContext = previousCompileContext || {};
            var terminalPriority = -Number.MAX_VALUE,
                newScopeDirective = previousCompileContext.newScopeDirective,
                controllerDirectives = previousCompileContext.controllerDirectives,
                newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective,
                templateDirective = previousCompileContext.templateDirective,
                nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective,
                hasTranscludeDirective = false,
                hasTemplate = false,
                hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective,
                $compileNode = templateAttrs.$$element = jqLite(compileNode),
                directive,
                directiveName,
                $template,
                replaceDirective = originalReplaceDirective,
                childTranscludeFn = transcludeFn,
                linkFn,
                directiveValue;
            for (var i = 0,
                ii = directives.length; i < ii; i++) {
              directive = directives[i];
              var attrStart = directive.$$start;
              var attrEnd = directive.$$end;
              if (attrStart) {
                $compileNode = groupScan(compileNode, attrStart, attrEnd);
              }
              $template = undefined;
              if (terminalPriority > directive.priority) {
                break;
              }
              if (directiveValue = directive.scope) {
                if (!directive.templateUrl) {
                  if (isObject(directiveValue)) {
                    assertNoDuplicate('new/isolated scope', newIsolateScopeDirective || newScopeDirective, directive, $compileNode);
                    newIsolateScopeDirective = directive;
                  } else {
                    assertNoDuplicate('new/isolated scope', newIsolateScopeDirective, directive, $compileNode);
                  }
                }
                newScopeDirective = newScopeDirective || directive;
              }
              directiveName = directive.name;
              if (!directive.templateUrl && directive.controller) {
                directiveValue = directive.controller;
                controllerDirectives = controllerDirectives || createMap();
                assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode);
                controllerDirectives[directiveName] = directive;
              }
              if (directiveValue = directive.transclude) {
                hasTranscludeDirective = true;
                if (!directive.$$tlb) {
                  assertNoDuplicate('transclusion', nonTlbTranscludeDirective, directive, $compileNode);
                  nonTlbTranscludeDirective = directive;
                }
                if (directiveValue == 'element') {
                  hasElementTranscludeDirective = true;
                  terminalPriority = directive.priority;
                  $template = $compileNode;
                  $compileNode = templateAttrs.$$element = jqLite(document.createComment(' ' + directiveName + ': ' + templateAttrs[directiveName] + ' '));
                  compileNode = $compileNode[0];
                  replaceWith(jqCollection, sliceArgs($template), compileNode);
                  childTranscludeFn = compile($template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {nonTlbTranscludeDirective: nonTlbTranscludeDirective});
                } else {
                  $template = jqLite(jqLiteClone(compileNode)).contents();
                  $compileNode.empty();
                  childTranscludeFn = compile($template, transcludeFn, undefined, undefined, {needsNewScope: directive.$$isolateScope || directive.$$newScope});
                }
              }
              if (directive.template) {
                hasTemplate = true;
                assertNoDuplicate('template', templateDirective, directive, $compileNode);
                templateDirective = directive;
                directiveValue = (isFunction(directive.template)) ? directive.template($compileNode, templateAttrs) : directive.template;
                directiveValue = denormalizeTemplate(directiveValue);
                if (directive.replace) {
                  replaceDirective = directive;
                  if (jqLiteIsTextNode(directiveValue)) {
                    $template = [];
                  } else {
                    $template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));
                  }
                  compileNode = $template[0];
                  if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                    throw $compileMinErr('tplrt', "Template for directive '{0}' must have exactly one root element. {1}", directiveName, '');
                  }
                  replaceWith(jqCollection, $compileNode, compileNode);
                  var newTemplateAttrs = {$attr: {}};
                  var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
                  var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                  if (newIsolateScopeDirective || newScopeDirective) {
                    markDirectiveScope(templateDirectives, newIsolateScopeDirective, newScopeDirective);
                  }
                  directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
                  mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                  ii = directives.length;
                } else {
                  $compileNode.html(directiveValue);
                }
              }
              if (directive.templateUrl) {
                hasTemplate = true;
                assertNoDuplicate('template', templateDirective, directive, $compileNode);
                templateDirective = directive;
                if (directive.replace) {
                  replaceDirective = directive;
                }
                nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                  controllerDirectives: controllerDirectives,
                  newScopeDirective: (newScopeDirective !== directive) && newScopeDirective,
                  newIsolateScopeDirective: newIsolateScopeDirective,
                  templateDirective: templateDirective,
                  nonTlbTranscludeDirective: nonTlbTranscludeDirective
                });
                ii = directives.length;
              } else if (directive.compile) {
                try {
                  linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                  if (isFunction(linkFn)) {
                    addLinkFns(null, linkFn, attrStart, attrEnd);
                  } else if (linkFn) {
                    addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);
                  }
                } catch (e) {
                  $exceptionHandler(e, startingTag($compileNode));
                }
              }
              if (directive.terminal) {
                nodeLinkFn.terminal = true;
                terminalPriority = Math.max(terminalPriority, directive.priority);
              }
            }
            nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === true;
            nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
            nodeLinkFn.templateOnThisElement = hasTemplate;
            nodeLinkFn.transclude = childTranscludeFn;
            previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;
            return nodeLinkFn;
            function addLinkFns(pre, post, attrStart, attrEnd) {
              if (pre) {
                if (attrStart)
                  pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
                pre.require = directive.require;
                pre.directiveName = directiveName;
                if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                  pre = cloneAndAnnotateFn(pre, {isolateScope: true});
                }
                preLinkFns.push(pre);
              }
              if (post) {
                if (attrStart)
                  post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
                post.require = directive.require;
                post.directiveName = directiveName;
                if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                  post = cloneAndAnnotateFn(post, {isolateScope: true});
                }
                postLinkFns.push(post);
              }
            }
            function getControllers(directiveName, require, $element, elementControllers) {
              var value;
              if (isString(require)) {
                var match = require.match(REQUIRE_PREFIX_REGEXP);
                var name = require.substring(match[0].length);
                var inheritType = match[1] || match[3];
                var optional = match[2] === '?';
                if (inheritType === '^^') {
                  $element = $element.parent();
                } else {
                  value = elementControllers && elementControllers[name];
                  value = value && value.instance;
                }
                if (!value) {
                  var dataName = '$' + name + 'Controller';
                  value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
                }
                if (!value && !optional) {
                  throw $compileMinErr('ctreq', "Controller '{0}', required by directive '{1}', can't be found!", name, directiveName);
                }
              } else if (isArray(require)) {
                value = [];
                for (var i = 0,
                    ii = require.length; i < ii; i++) {
                  value[i] = getControllers(directiveName, require[i], $element, elementControllers);
                }
              }
              return value || null;
            }
            function setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope) {
              var elementControllers = createMap();
              for (var controllerKey in controllerDirectives) {
                var directive = controllerDirectives[controllerKey];
                var locals = {
                  $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                  $element: $element,
                  $attrs: attrs,
                  $transclude: transcludeFn
                };
                var controller = directive.controller;
                if (controller == '@') {
                  controller = attrs[directive.name];
                }
                var controllerInstance = $controller(controller, locals, true, directive.controllerAs);
                elementControllers[directive.name] = controllerInstance;
                if (!hasElementTranscludeDirective) {
                  $element.data('$' + directive.name + 'Controller', controllerInstance.instance);
                }
              }
              return elementControllers;
            }
            function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
              var linkFn,
                  isolateScope,
                  controllerScope,
                  elementControllers,
                  transcludeFn,
                  $element,
                  attrs,
                  removeScopeBindingWatches,
                  removeControllerBindingWatches;
              if (compileNode === linkNode) {
                attrs = templateAttrs;
                $element = templateAttrs.$$element;
              } else {
                $element = jqLite(linkNode);
                attrs = new Attributes($element, templateAttrs);
              }
              controllerScope = scope;
              if (newIsolateScopeDirective) {
                isolateScope = scope.$new(true);
              } else if (newScopeDirective) {
                controllerScope = scope.$parent;
              }
              if (boundTranscludeFn) {
                transcludeFn = controllersBoundTransclude;
                transcludeFn.$$boundTransclude = boundTranscludeFn;
              }
              if (controllerDirectives) {
                elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope);
              }
              if (newIsolateScopeDirective) {
                compile.$$addScopeInfo($element, isolateScope, true, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective)));
                compile.$$addScopeClass($element, true);
                isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings;
                removeScopeBindingWatches = initializeDirectiveBindings(scope, attrs, isolateScope, isolateScope.$$isolateBindings, newIsolateScopeDirective);
                if (removeScopeBindingWatches) {
                  isolateScope.$on('$destroy', removeScopeBindingWatches);
                }
              }
              for (var name in elementControllers) {
                var controllerDirective = controllerDirectives[name];
                var controller = elementControllers[name];
                var bindings = controllerDirective.$$bindings.bindToController;
                if (controller.identifier && bindings) {
                  removeControllerBindingWatches = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                }
                var controllerResult = controller();
                if (controllerResult !== controller.instance) {
                  controller.instance = controllerResult;
                  $element.data('$' + controllerDirective.name + 'Controller', controllerResult);
                  removeControllerBindingWatches && removeControllerBindingWatches();
                  removeControllerBindingWatches = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                }
              }
              for (i = 0, ii = preLinkFns.length; i < ii; i++) {
                linkFn = preLinkFns[i];
                invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
              }
              var scopeToChild = scope;
              if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
                scopeToChild = isolateScope;
              }
              childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);
              for (i = postLinkFns.length - 1; i >= 0; i--) {
                linkFn = postLinkFns[i];
                invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
              }
              function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement) {
                var transcludeControllers;
                if (!isScope(scope)) {
                  futureParentElement = cloneAttachFn;
                  cloneAttachFn = scope;
                  scope = undefined;
                }
                if (hasElementTranscludeDirective) {
                  transcludeControllers = elementControllers;
                }
                if (!futureParentElement) {
                  futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element;
                }
                return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
              }
            }
          }
          function markDirectiveScope(directives, isolateScope, newScope) {
            for (var j = 0,
                jj = directives.length; j < jj; j++) {
              directives[j] = inherit(directives[j], {
                $$isolateScope: isolateScope,
                $$newScope: newScope
              });
            }
          }
          function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
            if (name === ignoreDirective)
              return null;
            var match = null;
            if (hasDirectives.hasOwnProperty(name)) {
              for (var directive,
                  directives = $injector.get(name + Suffix),
                  i = 0,
                  ii = directives.length; i < ii; i++) {
                try {
                  directive = directives[i];
                  if ((isUndefined(maxPriority) || maxPriority > directive.priority) && directive.restrict.indexOf(location) != -1) {
                    if (startAttrName) {
                      directive = inherit(directive, {
                        $$start: startAttrName,
                        $$end: endAttrName
                      });
                    }
                    tDirectives.push(directive);
                    match = directive;
                  }
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
            }
            return match;
          }
          function directiveIsMultiElement(name) {
            if (hasDirectives.hasOwnProperty(name)) {
              for (var directive,
                  directives = $injector.get(name + Suffix),
                  i = 0,
                  ii = directives.length; i < ii; i++) {
                directive = directives[i];
                if (directive.multiElement) {
                  return true;
                }
              }
            }
            return false;
          }
          function mergeTemplateAttributes(dst, src) {
            var srcAttr = src.$attr,
                dstAttr = dst.$attr,
                $element = dst.$$element;
            forEach(dst, function(value, key) {
              if (key.charAt(0) != '$') {
                if (src[key] && src[key] !== value) {
                  value += (key === 'style' ? ';' : ' ') + src[key];
                }
                dst.$set(key, value, true, srcAttr[key]);
              }
            });
            forEach(src, function(value, key) {
              if (key == 'class') {
                safeAddClass($element, value);
                dst['class'] = (dst['class'] ? dst['class'] + ' ' : '') + value;
              } else if (key == 'style') {
                $element.attr('style', $element.attr('style') + ';' + value);
                dst['style'] = (dst['style'] ? dst['style'] + ';' : '') + value;
              } else if (key.charAt(0) != '$' && !dst.hasOwnProperty(key)) {
                dst[key] = value;
                dstAttr[key] = srcAttr[key];
              }
            });
          }
          function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
            var linkQueue = [],
                afterTemplateNodeLinkFn,
                afterTemplateChildLinkFn,
                beforeTemplateCompileNode = $compileNode[0],
                origAsyncDirective = directives.shift(),
                derivedSyncDirective = inherit(origAsyncDirective, {
                  templateUrl: null,
                  transclude: null,
                  replace: null,
                  $$originalDirective: origAsyncDirective
                }),
                templateUrl = (isFunction(origAsyncDirective.templateUrl)) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl,
                templateNamespace = origAsyncDirective.templateNamespace;
            $compileNode.empty();
            $templateRequest(templateUrl).then(function(content) {
              var compileNode,
                  tempTemplateAttrs,
                  $template,
                  childBoundTranscludeFn;
              content = denormalizeTemplate(content);
              if (origAsyncDirective.replace) {
                if (jqLiteIsTextNode(content)) {
                  $template = [];
                } else {
                  $template = removeComments(wrapTemplate(templateNamespace, trim(content)));
                }
                compileNode = $template[0];
                if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                  throw $compileMinErr('tplrt', "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                }
                tempTemplateAttrs = {$attr: {}};
                replaceWith($rootElement, $compileNode, compileNode);
                var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                if (isObject(origAsyncDirective.scope)) {
                  markDirectiveScope(templateDirectives, true);
                }
                directives = templateDirectives.concat(directives);
                mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
              } else {
                compileNode = beforeTemplateCompileNode;
                $compileNode.html(content);
              }
              directives.unshift(derivedSyncDirective);
              afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext);
              forEach($rootElement, function(node, i) {
                if (node == compileNode) {
                  $rootElement[i] = $compileNode[0];
                }
              });
              afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
              while (linkQueue.length) {
                var scope = linkQueue.shift(),
                    beforeTemplateLinkNode = linkQueue.shift(),
                    linkRootElement = linkQueue.shift(),
                    boundTranscludeFn = linkQueue.shift(),
                    linkNode = $compileNode[0];
                if (scope.$$destroyed)
                  continue;
                if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                  var oldClasses = beforeTemplateLinkNode.className;
                  if (!(previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace)) {
                    linkNode = jqLiteClone(compileNode);
                  }
                  replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
                  safeAddClass(jqLite(linkNode), oldClasses);
                }
                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                  childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                } else {
                  childBoundTranscludeFn = boundTranscludeFn;
                }
                afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn);
              }
              linkQueue = null;
            });
            return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
              var childBoundTranscludeFn = boundTranscludeFn;
              if (scope.$$destroyed)
                return;
              if (linkQueue) {
                linkQueue.push(scope, node, rootElement, childBoundTranscludeFn);
              } else {
                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                  childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                }
                afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn);
              }
            };
          }
          function byPriority(a, b) {
            var diff = b.priority - a.priority;
            if (diff !== 0)
              return diff;
            if (a.name !== b.name)
              return (a.name < b.name) ? -1 : 1;
            return a.index - b.index;
          }
          function assertNoDuplicate(what, previousDirective, directive, element) {
            function wrapModuleNameIfDefined(moduleName) {
              return moduleName ? (' (module: ' + moduleName + ')') : '';
            }
            if (previousDirective) {
              throw $compileMinErr('multidir', 'Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}', previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName), directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element));
            }
          }
          function addTextInterpolateDirective(directives, text) {
            var interpolateFn = $interpolate(text, true);
            if (interpolateFn) {
              directives.push({
                priority: 0,
                compile: function textInterpolateCompileFn(templateNode) {
                  var templateNodeParent = templateNode.parent(),
                      hasCompileParent = !!templateNodeParent.length;
                  if (hasCompileParent)
                    compile.$$addBindingClass(templateNodeParent);
                  return function textInterpolateLinkFn(scope, node) {
                    var parent = node.parent();
                    if (!hasCompileParent)
                      compile.$$addBindingClass(parent);
                    compile.$$addBindingInfo(parent, interpolateFn.expressions);
                    scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                      node[0].nodeValue = value;
                    });
                  };
                }
              });
            }
          }
          function wrapTemplate(type, template) {
            type = lowercase(type || 'html');
            switch (type) {
              case 'svg':
              case 'math':
                var wrapper = document.createElement('div');
                wrapper.innerHTML = '<' + type + '>' + template + '</' + type + '>';
                return wrapper.childNodes[0].childNodes;
              default:
                return template;
            }
          }
          function getTrustedContext(node, attrNormalizedName) {
            if (attrNormalizedName == "srcdoc") {
              return $sce.HTML;
            }
            var tag = nodeName_(node);
            if (attrNormalizedName == "xlinkHref" || (tag == "form" && attrNormalizedName == "action") || (tag != "img" && (attrNormalizedName == "src" || attrNormalizedName == "ngSrc"))) {
              return $sce.RESOURCE_URL;
            }
          }
          function addAttrInterpolateDirective(node, directives, value, name, allOrNothing) {
            var trustedContext = getTrustedContext(node, name);
            allOrNothing = ALL_OR_NOTHING_ATTRS[name] || allOrNothing;
            var interpolateFn = $interpolate(value, true, trustedContext, allOrNothing);
            if (!interpolateFn)
              return;
            if (name === "multiple" && nodeName_(node) === "select") {
              throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
            }
            directives.push({
              priority: 100,
              compile: function() {
                return {pre: function attrInterpolatePreLinkFn(scope, element, attr) {
                    var $$observers = (attr.$$observers || (attr.$$observers = createMap()));
                    if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
                      throw $compileMinErr('nodomevents', "Interpolations for HTML DOM event attributes are disallowed.  Please use the " + "ng- versions (such as ng-click instead of onclick) instead.");
                    }
                    var newValue = attr[name];
                    if (newValue !== value) {
                      interpolateFn = newValue && $interpolate(newValue, true, trustedContext, allOrNothing);
                      value = newValue;
                    }
                    if (!interpolateFn)
                      return;
                    attr[name] = interpolateFn(scope);
                    ($$observers[name] || ($$observers[name] = [])).$$inter = true;
                    (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {
                      if (name === 'class' && newValue != oldValue) {
                        attr.$updateClass(newValue, oldValue);
                      } else {
                        attr.$set(name, newValue);
                      }
                    });
                  }};
              }
            });
          }
          function replaceWith($rootElement, elementsToRemove, newNode) {
            var firstElementToRemove = elementsToRemove[0],
                removeCount = elementsToRemove.length,
                parent = firstElementToRemove.parentNode,
                i,
                ii;
            if ($rootElement) {
              for (i = 0, ii = $rootElement.length; i < ii; i++) {
                if ($rootElement[i] == firstElementToRemove) {
                  $rootElement[i++] = newNode;
                  for (var j = i,
                      j2 = j + removeCount - 1,
                      jj = $rootElement.length; j < jj; j++, j2++) {
                    if (j2 < jj) {
                      $rootElement[j] = $rootElement[j2];
                    } else {
                      delete $rootElement[j];
                    }
                  }
                  $rootElement.length -= removeCount - 1;
                  if ($rootElement.context === firstElementToRemove) {
                    $rootElement.context = newNode;
                  }
                  break;
                }
              }
            }
            if (parent) {
              parent.replaceChild(newNode, firstElementToRemove);
            }
            var fragment = document.createDocumentFragment();
            fragment.appendChild(firstElementToRemove);
            if (jqLite.hasData(firstElementToRemove)) {
              jqLite.data(newNode, jqLite.data(firstElementToRemove));
              if (!jQuery) {
                delete jqLite.cache[firstElementToRemove[jqLite.expando]];
              } else {
                skipDestroyOnNextJQueryCleanData = true;
                jQuery.cleanData([firstElementToRemove]);
              }
            }
            for (var k = 1,
                kk = elementsToRemove.length; k < kk; k++) {
              var element = elementsToRemove[k];
              jqLite(element).remove();
              fragment.appendChild(element);
              delete elementsToRemove[k];
            }
            elementsToRemove[0] = newNode;
            elementsToRemove.length = 1;
          }
          function cloneAndAnnotateFn(fn, annotation) {
            return extend(function() {
              return fn.apply(null, arguments);
            }, fn, annotation);
          }
          function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
            try {
              linkFn(scope, $element, attrs, controllers, transcludeFn);
            } catch (e) {
              $exceptionHandler(e, startingTag($element));
            }
          }
          function initializeDirectiveBindings(scope, attrs, destination, bindings, directive) {
            var removeWatchCollection = [];
            forEach(bindings, function(definition, scopeName) {
              var attrName = definition.attrName,
                  optional = definition.optional,
                  mode = definition.mode,
                  lastValue,
                  parentGet,
                  parentSet,
                  compare;
              switch (mode) {
                case '@':
                  if (!optional && !hasOwnProperty.call(attrs, attrName)) {
                    destination[scopeName] = attrs[attrName] = void 0;
                  }
                  attrs.$observe(attrName, function(value) {
                    if (isString(value)) {
                      destination[scopeName] = value;
                    }
                  });
                  attrs.$$observers[attrName].$$scope = scope;
                  if (isString(attrs[attrName])) {
                    destination[scopeName] = $interpolate(attrs[attrName])(scope);
                  }
                  break;
                case '=':
                  if (!hasOwnProperty.call(attrs, attrName)) {
                    if (optional)
                      break;
                    attrs[attrName] = void 0;
                  }
                  if (optional && !attrs[attrName])
                    break;
                  parentGet = $parse(attrs[attrName]);
                  if (parentGet.literal) {
                    compare = equals;
                  } else {
                    compare = function(a, b) {
                      return a === b || (a !== a && b !== b);
                    };
                  }
                  parentSet = parentGet.assign || function() {
                    lastValue = destination[scopeName] = parentGet(scope);
                    throw $compileMinErr('nonassign', "Expression '{0}' used with directive '{1}' is non-assignable!", attrs[attrName], directive.name);
                  };
                  lastValue = destination[scopeName] = parentGet(scope);
                  var parentValueWatch = function parentValueWatch(parentValue) {
                    if (!compare(parentValue, destination[scopeName])) {
                      if (!compare(parentValue, lastValue)) {
                        destination[scopeName] = parentValue;
                      } else {
                        parentSet(scope, parentValue = destination[scopeName]);
                      }
                    }
                    return lastValue = parentValue;
                  };
                  parentValueWatch.$stateful = true;
                  var removeWatch;
                  if (definition.collection) {
                    removeWatch = scope.$watchCollection(attrs[attrName], parentValueWatch);
                  } else {
                    removeWatch = scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal);
                  }
                  removeWatchCollection.push(removeWatch);
                  break;
                case '&':
                  parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop;
                  if (parentGet === noop && optional)
                    break;
                  destination[scopeName] = function(locals) {
                    return parentGet(scope, locals);
                  };
                  break;
              }
            });
            return removeWatchCollection.length && function removeWatches() {
              for (var i = 0,
                  ii = removeWatchCollection.length; i < ii; ++i) {
                removeWatchCollection[i]();
              }
            };
          }
        }];
      }
      var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i;
      function directiveNormalize(name) {
        return camelCase(name.replace(PREFIX_REGEXP, ''));
      }
      function nodesetLinkingFn(scope, nodeList, rootElement, boundTranscludeFn) {}
      function directiveLinkingFn(nodesetLinkingFn, scope, node, rootElement, boundTranscludeFn) {}
      function tokenDifference(str1, str2) {
        var values = '',
            tokens1 = str1.split(/\s+/),
            tokens2 = str2.split(/\s+/);
        outer: for (var i = 0; i < tokens1.length; i++) {
          var token = tokens1[i];
          for (var j = 0; j < tokens2.length; j++) {
            if (token == tokens2[j])
              continue outer;
          }
          values += (values.length > 0 ? ' ' : '') + token;
        }
        return values;
      }
      function removeComments(jqNodes) {
        jqNodes = jqLite(jqNodes);
        var i = jqNodes.length;
        if (i <= 1) {
          return jqNodes;
        }
        while (i--) {
          var node = jqNodes[i];
          if (node.nodeType === NODE_TYPE_COMMENT) {
            splice.call(jqNodes, i, 1);
          }
        }
        return jqNodes;
      }
      var $controllerMinErr = minErr('$controller');
      var CNTRL_REG = /^(\S+)(\s+as\s+(\w+))?$/;
      function identifierForController(controller, ident) {
        if (ident && isString(ident))
          return ident;
        if (isString(controller)) {
          var match = CNTRL_REG.exec(controller);
          if (match)
            return match[3];
        }
      }
      function $ControllerProvider() {
        var controllers = {},
            globals = false;
        this.register = function(name, constructor) {
          assertNotHasOwnProperty(name, 'controller');
          if (isObject(name)) {
            extend(controllers, name);
          } else {
            controllers[name] = constructor;
          }
        };
        this.allowGlobals = function() {
          globals = true;
        };
        this.$get = ['$injector', '$window', function($injector, $window) {
          return function(expression, locals, later, ident) {
            var instance,
                match,
                constructor,
                identifier;
            later = later === true;
            if (ident && isString(ident)) {
              identifier = ident;
            }
            if (isString(expression)) {
              match = expression.match(CNTRL_REG);
              if (!match) {
                throw $controllerMinErr('ctrlfmt', "Badly formed controller string '{0}'. " + "Must match `__name__ as __id__` or `__name__`.", expression);
              }
              constructor = match[1], identifier = identifier || match[3];
              expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, true) || (globals ? getter($window, constructor, true) : undefined);
              assertArgFn(expression, constructor, true);
            }
            if (later) {
              var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
              instance = Object.create(controllerPrototype || null);
              if (identifier) {
                addIdentifier(locals, identifier, instance, constructor || expression.name);
              }
              var instantiate;
              return instantiate = extend(function() {
                var result = $injector.invoke(expression, instance, locals, constructor);
                if (result !== instance && (isObject(result) || isFunction(result))) {
                  instance = result;
                  if (identifier) {
                    addIdentifier(locals, identifier, instance, constructor || expression.name);
                  }
                }
                return instance;
              }, {
                instance: instance,
                identifier: identifier
              });
            }
            instance = $injector.instantiate(expression, locals, constructor);
            if (identifier) {
              addIdentifier(locals, identifier, instance, constructor || expression.name);
            }
            return instance;
          };
          function addIdentifier(locals, identifier, instance, name) {
            if (!(locals && isObject(locals.$scope))) {
              throw minErr('$controller')('noscp', "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", name, identifier);
            }
            locals.$scope[identifier] = instance;
          }
        }];
      }
      function $DocumentProvider() {
        this.$get = ['$window', function(window) {
          return jqLite(window.document);
        }];
      }
      function $ExceptionHandlerProvider() {
        this.$get = ['$log', function($log) {
          return function(exception, cause) {
            $log.error.apply($log, arguments);
          };
        }];
      }
      var $$ForceReflowProvider = function() {
        this.$get = ['$document', function($document) {
          return function(domNode) {
            if (domNode) {
              if (!domNode.nodeType && domNode instanceof jqLite) {
                domNode = domNode[0];
              }
            } else {
              domNode = $document[0].body;
            }
            return domNode.offsetWidth + 1;
          };
        }];
      };
      var APPLICATION_JSON = 'application/json';
      var CONTENT_TYPE_APPLICATION_JSON = {'Content-Type': APPLICATION_JSON + ';charset=utf-8'};
      var JSON_START = /^\[|^\{(?!\{)/;
      var JSON_ENDS = {
        '[': /]$/,
        '{': /}$/
      };
      var JSON_PROTECTION_PREFIX = /^\)\]\}',?\n/;
      var $httpMinErr = minErr('$http');
      var $httpMinErrLegacyFn = function(method) {
        return function() {
          throw $httpMinErr('legacy', 'The method `{0}` on the promise returned from `$http` has been disabled.', method);
        };
      };
      function serializeValue(v) {
        if (isObject(v)) {
          return isDate(v) ? v.toISOString() : toJson(v);
        }
        return v;
      }
      function $HttpParamSerializerProvider() {
        this.$get = function() {
          return function ngParamSerializer(params) {
            if (!params)
              return '';
            var parts = [];
            forEachSorted(params, function(value, key) {
              if (value === null || isUndefined(value))
                return;
              if (isArray(value)) {
                forEach(value, function(v, k) {
                  parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(v)));
                });
              } else {
                parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(value)));
              }
            });
            return parts.join('&');
          };
        };
      }
      function $HttpParamSerializerJQLikeProvider() {
        this.$get = function() {
          return function jQueryLikeParamSerializer(params) {
            if (!params)
              return '';
            var parts = [];
            serialize(params, '', true);
            return parts.join('&');
            function serialize(toSerialize, prefix, topLevel) {
              if (toSerialize === null || isUndefined(toSerialize))
                return;
              if (isArray(toSerialize)) {
                forEach(toSerialize, function(value, index) {
                  serialize(value, prefix + '[' + (isObject(value) ? index : '') + ']');
                });
              } else if (isObject(toSerialize) && !isDate(toSerialize)) {
                forEachSorted(toSerialize, function(value, key) {
                  serialize(value, prefix + (topLevel ? '' : '[') + key + (topLevel ? '' : ']'));
                });
              } else {
                parts.push(encodeUriQuery(prefix) + '=' + encodeUriQuery(serializeValue(toSerialize)));
              }
            }
          };
        };
      }
      function defaultHttpResponseTransform(data, headers) {
        if (isString(data)) {
          var tempData = data.replace(JSON_PROTECTION_PREFIX, '').trim();
          if (tempData) {
            var contentType = headers('Content-Type');
            if ((contentType && (contentType.indexOf(APPLICATION_JSON) === 0)) || isJsonLike(tempData)) {
              data = fromJson(tempData);
            }
          }
        }
        return data;
      }
      function isJsonLike(str) {
        var jsonStart = str.match(JSON_START);
        return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
      }
      function parseHeaders(headers) {
        var parsed = createMap(),
            i;
        function fillInParsed(key, val) {
          if (key) {
            parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
          }
        }
        if (isString(headers)) {
          forEach(headers.split('\n'), function(line) {
            i = line.indexOf(':');
            fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));
          });
        } else if (isObject(headers)) {
          forEach(headers, function(headerVal, headerKey) {
            fillInParsed(lowercase(headerKey), trim(headerVal));
          });
        }
        return parsed;
      }
      function headersGetter(headers) {
        var headersObj;
        return function(name) {
          if (!headersObj)
            headersObj = parseHeaders(headers);
          if (name) {
            var value = headersObj[lowercase(name)];
            if (value === void 0) {
              value = null;
            }
            return value;
          }
          return headersObj;
        };
      }
      function transformData(data, headers, status, fns) {
        if (isFunction(fns)) {
          return fns(data, headers, status);
        }
        forEach(fns, function(fn) {
          data = fn(data, headers, status);
        });
        return data;
      }
      function isSuccess(status) {
        return 200 <= status && status < 300;
      }
      function $HttpProvider() {
        var defaults = this.defaults = {
          transformResponse: [defaultHttpResponseTransform],
          transformRequest: [function(d) {
            return isObject(d) && !isFile(d) && !isBlob(d) && !isFormData(d) ? toJson(d) : d;
          }],
          headers: {
            common: {'Accept': 'application/json, text/plain, */*'},
            post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
            put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
            patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
          },
          xsrfCookieName: 'XSRF-TOKEN',
          xsrfHeaderName: 'X-XSRF-TOKEN',
          paramSerializer: '$httpParamSerializer'
        };
        var useApplyAsync = false;
        this.useApplyAsync = function(value) {
          if (isDefined(value)) {
            useApplyAsync = !!value;
            return this;
          }
          return useApplyAsync;
        };
        var useLegacyPromise = true;
        this.useLegacyPromiseExtensions = function(value) {
          if (isDefined(value)) {
            useLegacyPromise = !!value;
            return this;
          }
          return useLegacyPromise;
        };
        var interceptorFactories = this.interceptors = [];
        this.$get = ['$httpBackend', '$$cookieReader', '$cacheFactory', '$rootScope', '$q', '$injector', function($httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector) {
          var defaultCache = $cacheFactory('$http');
          defaults.paramSerializer = isString(defaults.paramSerializer) ? $injector.get(defaults.paramSerializer) : defaults.paramSerializer;
          var reversedInterceptors = [];
          forEach(interceptorFactories, function(interceptorFactory) {
            reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
          });
          function $http(requestConfig) {
            if (!angular.isObject(requestConfig)) {
              throw minErr('$http')('badreq', 'Http request configuration must be an object.  Received: {0}', requestConfig);
            }
            var config = extend({
              method: 'get',
              transformRequest: defaults.transformRequest,
              transformResponse: defaults.transformResponse,
              paramSerializer: defaults.paramSerializer
            }, requestConfig);
            config.headers = mergeHeaders(requestConfig);
            config.method = uppercase(config.method);
            config.paramSerializer = isString(config.paramSerializer) ? $injector.get(config.paramSerializer) : config.paramSerializer;
            var serverRequest = function(config) {
              var headers = config.headers;
              var reqData = transformData(config.data, headersGetter(headers), undefined, config.transformRequest);
              if (isUndefined(reqData)) {
                forEach(headers, function(value, header) {
                  if (lowercase(header) === 'content-type') {
                    delete headers[header];
                  }
                });
              }
              if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
                config.withCredentials = defaults.withCredentials;
              }
              return sendReq(config, reqData).then(transformResponse, transformResponse);
            };
            var chain = [serverRequest, undefined];
            var promise = $q.when(config);
            forEach(reversedInterceptors, function(interceptor) {
              if (interceptor.request || interceptor.requestError) {
                chain.unshift(interceptor.request, interceptor.requestError);
              }
              if (interceptor.response || interceptor.responseError) {
                chain.push(interceptor.response, interceptor.responseError);
              }
            });
            while (chain.length) {
              var thenFn = chain.shift();
              var rejectFn = chain.shift();
              promise = promise.then(thenFn, rejectFn);
            }
            if (useLegacyPromise) {
              promise.success = function(fn) {
                assertArgFn(fn, 'fn');
                promise.then(function(response) {
                  fn(response.data, response.status, response.headers, config);
                });
                return promise;
              };
              promise.error = function(fn) {
                assertArgFn(fn, 'fn');
                promise.then(null, function(response) {
                  fn(response.data, response.status, response.headers, config);
                });
                return promise;
              };
            } else {
              promise.success = $httpMinErrLegacyFn('success');
              promise.error = $httpMinErrLegacyFn('error');
            }
            return promise;
            function transformResponse(response) {
              var resp = extend({}, response);
              resp.data = transformData(response.data, response.headers, response.status, config.transformResponse);
              return (isSuccess(response.status)) ? resp : $q.reject(resp);
            }
            function executeHeaderFns(headers, config) {
              var headerContent,
                  processedHeaders = {};
              forEach(headers, function(headerFn, header) {
                if (isFunction(headerFn)) {
                  headerContent = headerFn(config);
                  if (headerContent != null) {
                    processedHeaders[header] = headerContent;
                  }
                } else {
                  processedHeaders[header] = headerFn;
                }
              });
              return processedHeaders;
            }
            function mergeHeaders(config) {
              var defHeaders = defaults.headers,
                  reqHeaders = extend({}, config.headers),
                  defHeaderName,
                  lowercaseDefHeaderName,
                  reqHeaderName;
              defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
              defaultHeadersIteration: for (defHeaderName in defHeaders) {
                lowercaseDefHeaderName = lowercase(defHeaderName);
                for (reqHeaderName in reqHeaders) {
                  if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
                    continue defaultHeadersIteration;
                  }
                }
                reqHeaders[defHeaderName] = defHeaders[defHeaderName];
              }
              return executeHeaderFns(reqHeaders, shallowCopy(config));
            }
          }
          $http.pendingRequests = [];
          createShortMethods('get', 'delete', 'head', 'jsonp');
          createShortMethodsWithData('post', 'put', 'patch');
          $http.defaults = defaults;
          return $http;
          function createShortMethods(names) {
            forEach(arguments, function(name) {
              $http[name] = function(url, config) {
                return $http(extend({}, config || {}, {
                  method: name,
                  url: url
                }));
              };
            });
          }
          function createShortMethodsWithData(name) {
            forEach(arguments, function(name) {
              $http[name] = function(url, data, config) {
                return $http(extend({}, config || {}, {
                  method: name,
                  url: url,
                  data: data
                }));
              };
            });
          }
          function sendReq(config, reqData) {
            var deferred = $q.defer(),
                promise = deferred.promise,
                cache,
                cachedResp,
                reqHeaders = config.headers,
                url = buildUrl(config.url, config.paramSerializer(config.params));
            $http.pendingRequests.push(config);
            promise.then(removePendingReq, removePendingReq);
            if ((config.cache || defaults.cache) && config.cache !== false && (config.method === 'GET' || config.method === 'JSONP')) {
              cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache;
            }
            if (cache) {
              cachedResp = cache.get(url);
              if (isDefined(cachedResp)) {
                if (isPromiseLike(cachedResp)) {
                  cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult);
                } else {
                  if (isArray(cachedResp)) {
                    resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]);
                  } else {
                    resolvePromise(cachedResp, 200, {}, 'OK');
                  }
                }
              } else {
                cache.put(url, promise);
              }
            }
            if (isUndefined(cachedResp)) {
              var xsrfValue = urlIsSameOrigin(config.url) ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined;
              if (xsrfValue) {
                reqHeaders[(config.xsrfHeaderName || defaults.xsrfHeaderName)] = xsrfValue;
              }
              $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType);
            }
            return promise;
            function done(status, response, headersString, statusText) {
              if (cache) {
                if (isSuccess(status)) {
                  cache.put(url, [status, response, parseHeaders(headersString), statusText]);
                } else {
                  cache.remove(url);
                }
              }
              function resolveHttpPromise() {
                resolvePromise(response, status, headersString, statusText);
              }
              if (useApplyAsync) {
                $rootScope.$applyAsync(resolveHttpPromise);
              } else {
                resolveHttpPromise();
                if (!$rootScope.$$phase)
                  $rootScope.$apply();
              }
            }
            function resolvePromise(response, status, headers, statusText) {
              status = status >= -1 ? status : 0;
              (isSuccess(status) ? deferred.resolve : deferred.reject)({
                data: response,
                status: status,
                headers: headersGetter(headers),
                config: config,
                statusText: statusText
              });
            }
            function resolvePromiseWithResult(result) {
              resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText);
            }
            function removePendingReq() {
              var idx = $http.pendingRequests.indexOf(config);
              if (idx !== -1)
                $http.pendingRequests.splice(idx, 1);
            }
          }
          function buildUrl(url, serializedParams) {
            if (serializedParams.length > 0) {
              url += ((url.indexOf('?') == -1) ? '?' : '&') + serializedParams;
            }
            return url;
          }
        }];
      }
      function $xhrFactoryProvider() {
        this.$get = function() {
          return function createXhr() {
            return new window.XMLHttpRequest();
          };
        };
      }
      function $HttpBackendProvider() {
        this.$get = ['$browser', '$window', '$document', '$xhrFactory', function($browser, $window, $document, $xhrFactory) {
          return createHttpBackend($browser, $xhrFactory, $browser.defer, $window.angular.callbacks, $document[0]);
        }];
      }
      function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
        return function(method, url, post, callback, headers, timeout, withCredentials, responseType) {
          $browser.$$incOutstandingRequestCount();
          url = url || $browser.url();
          if (lowercase(method) == 'jsonp') {
            var callbackId = '_' + (callbacks.counter++).toString(36);
            callbacks[callbackId] = function(data) {
              callbacks[callbackId].data = data;
              callbacks[callbackId].called = true;
            };
            var jsonpDone = jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId), callbackId, function(status, text) {
              completeRequest(callback, status, callbacks[callbackId].data, "", text);
              callbacks[callbackId] = noop;
            });
          } else {
            var xhr = createXhr(method, url);
            xhr.open(method, url, true);
            forEach(headers, function(value, key) {
              if (isDefined(value)) {
                xhr.setRequestHeader(key, value);
              }
            });
            xhr.onload = function requestLoaded() {
              var statusText = xhr.statusText || '';
              var response = ('response' in xhr) ? xhr.response : xhr.responseText;
              var status = xhr.status === 1223 ? 204 : xhr.status;
              if (status === 0) {
                status = response ? 200 : urlResolve(url).protocol == 'file' ? 404 : 0;
              }
              completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText);
            };
            var requestError = function() {
              completeRequest(callback, -1, null, null, '');
            };
            xhr.onerror = requestError;
            xhr.onabort = requestError;
            if (withCredentials) {
              xhr.withCredentials = true;
            }
            if (responseType) {
              try {
                xhr.responseType = responseType;
              } catch (e) {
                if (responseType !== 'json') {
                  throw e;
                }
              }
            }
            xhr.send(isUndefined(post) ? null : post);
          }
          if (timeout > 0) {
            var timeoutId = $browserDefer(timeoutRequest, timeout);
          } else if (isPromiseLike(timeout)) {
            timeout.then(timeoutRequest);
          }
          function timeoutRequest() {
            jsonpDone && jsonpDone();
            xhr && xhr.abort();
          }
          function completeRequest(callback, status, response, headersString, statusText) {
            if (isDefined(timeoutId)) {
              $browserDefer.cancel(timeoutId);
            }
            jsonpDone = xhr = null;
            callback(status, response, headersString, statusText);
            $browser.$$completeOutstandingRequest(noop);
          }
        };
        function jsonpReq(url, callbackId, done) {
          var script = rawDocument.createElement('script'),
              callback = null;
          script.type = "text/javascript";
          script.src = url;
          script.async = true;
          callback = function(event) {
            removeEventListenerFn(script, "load", callback);
            removeEventListenerFn(script, "error", callback);
            rawDocument.body.removeChild(script);
            script = null;
            var status = -1;
            var text = "unknown";
            if (event) {
              if (event.type === "load" && !callbacks[callbackId].called) {
                event = {type: "error"};
              }
              text = event.type;
              status = event.type === "error" ? 404 : 200;
            }
            if (done) {
              done(status, text);
            }
          };
          addEventListenerFn(script, "load", callback);
          addEventListenerFn(script, "error", callback);
          rawDocument.body.appendChild(script);
          return callback;
        }
      }
      var $interpolateMinErr = angular.$interpolateMinErr = minErr('$interpolate');
      $interpolateMinErr.throwNoconcat = function(text) {
        throw $interpolateMinErr('noconcat', "Error while interpolating: {0}\nStrict Contextual Escaping disallows " + "interpolations that concatenate multiple expressions when a trusted value is " + "required.  See http://docs.angularjs.org/api/ng.$sce", text);
      };
      $interpolateMinErr.interr = function(text, err) {
        return $interpolateMinErr('interr', "Can't interpolate: {0}\n{1}", text, err.toString());
      };
      function $InterpolateProvider() {
        var startSymbol = '{{';
        var endSymbol = '}}';
        this.startSymbol = function(value) {
          if (value) {
            startSymbol = value;
            return this;
          } else {
            return startSymbol;
          }
        };
        this.endSymbol = function(value) {
          if (value) {
            endSymbol = value;
            return this;
          } else {
            return endSymbol;
          }
        };
        this.$get = ['$parse', '$exceptionHandler', '$sce', function($parse, $exceptionHandler, $sce) {
          var startSymbolLength = startSymbol.length,
              endSymbolLength = endSymbol.length,
              escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), 'g'),
              escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), 'g');
          function escape(ch) {
            return '\\\\\\' + ch;
          }
          function unescapeText(text) {
            return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol);
          }
          function stringify(value) {
            if (value == null) {
              return '';
            }
            switch (typeof value) {
              case 'string':
                break;
              case 'number':
                value = '' + value;
                break;
              default:
                value = toJson(value);
            }
            return value;
          }
          function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
            allOrNothing = !!allOrNothing;
            var startIndex,
                endIndex,
                index = 0,
                expressions = [],
                parseFns = [],
                textLength = text.length,
                exp,
                concat = [],
                expressionPositions = [];
            while (index < textLength) {
              if (((startIndex = text.indexOf(startSymbol, index)) != -1) && ((endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1)) {
                if (index !== startIndex) {
                  concat.push(unescapeText(text.substring(index, startIndex)));
                }
                exp = text.substring(startIndex + startSymbolLength, endIndex);
                expressions.push(exp);
                parseFns.push($parse(exp, parseStringifyInterceptor));
                index = endIndex + endSymbolLength;
                expressionPositions.push(concat.length);
                concat.push('');
              } else {
                if (index !== textLength) {
                  concat.push(unescapeText(text.substring(index)));
                }
                break;
              }
            }
            if (trustedContext && concat.length > 1) {
              $interpolateMinErr.throwNoconcat(text);
            }
            if (!mustHaveExpression || expressions.length) {
              var compute = function(values) {
                for (var i = 0,
                    ii = expressions.length; i < ii; i++) {
                  if (allOrNothing && isUndefined(values[i]))
                    return;
                  concat[expressionPositions[i]] = values[i];
                }
                return concat.join('');
              };
              var getValue = function(value) {
                return trustedContext ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value);
              };
              return extend(function interpolationFn(context) {
                var i = 0;
                var ii = expressions.length;
                var values = new Array(ii);
                try {
                  for (; i < ii; i++) {
                    values[i] = parseFns[i](context);
                  }
                  return compute(values);
                } catch (err) {
                  $exceptionHandler($interpolateMinErr.interr(text, err));
                }
              }, {
                exp: text,
                expressions: expressions,
                $$watchDelegate: function(scope, listener) {
                  var lastValue;
                  return scope.$watchGroup(parseFns, function interpolateFnWatcher(values, oldValues) {
                    var currValue = compute(values);
                    if (isFunction(listener)) {
                      listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope);
                    }
                    lastValue = currValue;
                  });
                }
              });
            }
            function parseStringifyInterceptor(value) {
              try {
                value = getValue(value);
                return allOrNothing && !isDefined(value) ? value : stringify(value);
              } catch (err) {
                $exceptionHandler($interpolateMinErr.interr(text, err));
              }
            }
          }
          $interpolate.startSymbol = function() {
            return startSymbol;
          };
          $interpolate.endSymbol = function() {
            return endSymbol;
          };
          return $interpolate;
        }];
      }
      function $IntervalProvider() {
        this.$get = ['$rootScope', '$window', '$q', '$$q', function($rootScope, $window, $q, $$q) {
          var intervals = {};
          function interval(fn, delay, count, invokeApply) {
            var hasParams = arguments.length > 4,
                args = hasParams ? sliceArgs(arguments, 4) : [],
                setInterval = $window.setInterval,
                clearInterval = $window.clearInterval,
                iteration = 0,
                skipApply = (isDefined(invokeApply) && !invokeApply),
                deferred = (skipApply ? $$q : $q).defer(),
                promise = deferred.promise;
            count = isDefined(count) ? count : 0;
            promise.then(null, null, (!hasParams) ? fn : function() {
              fn.apply(null, args);
            });
            promise.$$intervalId = setInterval(function tick() {
              deferred.notify(iteration++);
              if (count > 0 && iteration >= count) {
                deferred.resolve(iteration);
                clearInterval(promise.$$intervalId);
                delete intervals[promise.$$intervalId];
              }
              if (!skipApply)
                $rootScope.$apply();
            }, delay);
            intervals[promise.$$intervalId] = deferred;
            return promise;
          }
          interval.cancel = function(promise) {
            if (promise && promise.$$intervalId in intervals) {
              intervals[promise.$$intervalId].reject('canceled');
              $window.clearInterval(promise.$$intervalId);
              delete intervals[promise.$$intervalId];
              return true;
            }
            return false;
          };
          return interval;
        }];
      }
      var PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/,
          DEFAULT_PORTS = {
            'http': 80,
            'https': 443,
            'ftp': 21
          };
      var $locationMinErr = minErr('$location');
      function encodePath(path) {
        var segments = path.split('/'),
            i = segments.length;
        while (i--) {
          segments[i] = encodeUriSegment(segments[i]);
        }
        return segments.join('/');
      }
      function parseAbsoluteUrl(absoluteUrl, locationObj) {
        var parsedUrl = urlResolve(absoluteUrl);
        locationObj.$$protocol = parsedUrl.protocol;
        locationObj.$$host = parsedUrl.hostname;
        locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
      }
      function parseAppUrl(relativeUrl, locationObj) {
        var prefixed = (relativeUrl.charAt(0) !== '/');
        if (prefixed) {
          relativeUrl = '/' + relativeUrl;
        }
        var match = urlResolve(relativeUrl);
        locationObj.$$path = decodeURIComponent(prefixed && match.pathname.charAt(0) === '/' ? match.pathname.substring(1) : match.pathname);
        locationObj.$$search = parseKeyValue(match.search);
        locationObj.$$hash = decodeURIComponent(match.hash);
        if (locationObj.$$path && locationObj.$$path.charAt(0) != '/') {
          locationObj.$$path = '/' + locationObj.$$path;
        }
      }
      function beginsWith(begin, whole) {
        if (whole.indexOf(begin) === 0) {
          return whole.substr(begin.length);
        }
      }
      function stripHash(url) {
        var index = url.indexOf('#');
        return index == -1 ? url : url.substr(0, index);
      }
      function trimEmptyHash(url) {
        return url.replace(/(#.+)|#$/, '$1');
      }
      function stripFile(url) {
        return url.substr(0, stripHash(url).lastIndexOf('/') + 1);
      }
      function serverBase(url) {
        return url.substring(0, url.indexOf('/', url.indexOf('//') + 2));
      }
      function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
        this.$$html5 = true;
        basePrefix = basePrefix || '';
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
          var pathUrl = beginsWith(appBaseNoFile, url);
          if (!isString(pathUrl)) {
            throw $locationMinErr('ipthprfx', 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
          }
          parseAppUrl(pathUrl, this);
          if (!this.$$path) {
            this.$$path = '/';
          }
          this.$$compose();
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
        };
        this.$$parseLinkUrl = function(url, relHref) {
          if (relHref && relHref[0] === '#') {
            this.hash(relHref.slice(1));
            return true;
          }
          var appUrl,
              prevAppUrl;
          var rewrittenUrl;
          if (isDefined(appUrl = beginsWith(appBase, url))) {
            prevAppUrl = appUrl;
            if (isDefined(appUrl = beginsWith(basePrefix, appUrl))) {
              rewrittenUrl = appBaseNoFile + (beginsWith('/', appUrl) || appUrl);
            } else {
              rewrittenUrl = appBase + prevAppUrl;
            }
          } else if (isDefined(appUrl = beginsWith(appBaseNoFile, url))) {
            rewrittenUrl = appBaseNoFile + appUrl;
          } else if (appBaseNoFile == url + '/') {
            rewrittenUrl = appBaseNoFile;
          }
          if (rewrittenUrl) {
            this.$$parse(rewrittenUrl);
          }
          return !!rewrittenUrl;
        };
      }
      function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
          var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);
          var withoutHashUrl;
          if (!isUndefined(withoutBaseUrl) && withoutBaseUrl.charAt(0) === '#') {
            withoutHashUrl = beginsWith(hashPrefix, withoutBaseUrl);
            if (isUndefined(withoutHashUrl)) {
              withoutHashUrl = withoutBaseUrl;
            }
          } else {
            if (this.$$html5) {
              withoutHashUrl = withoutBaseUrl;
            } else {
              withoutHashUrl = '';
              if (isUndefined(withoutBaseUrl)) {
                appBase = url;
                this.replace();
              }
            }
          }
          parseAppUrl(withoutHashUrl, this);
          this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);
          this.$$compose();
          function removeWindowsDriveName(path, url, base) {
            var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
            var firstPathSegmentMatch;
            if (url.indexOf(base) === 0) {
              url = url.replace(base, '');
            }
            if (windowsFilePathExp.exec(url)) {
              return path;
            }
            firstPathSegmentMatch = windowsFilePathExp.exec(path);
            return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
          }
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : '');
        };
        this.$$parseLinkUrl = function(url, relHref) {
          if (stripHash(appBase) == stripHash(url)) {
            this.$$parse(url);
            return true;
          }
          return false;
        };
      }
      function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
        this.$$html5 = true;
        LocationHashbangUrl.apply(this, arguments);
        this.$$parseLinkUrl = function(url, relHref) {
          if (relHref && relHref[0] === '#') {
            this.hash(relHref.slice(1));
            return true;
          }
          var rewrittenUrl;
          var appUrl;
          if (appBase == stripHash(url)) {
            rewrittenUrl = url;
          } else if ((appUrl = beginsWith(appBaseNoFile, url))) {
            rewrittenUrl = appBase + hashPrefix + appUrl;
          } else if (appBaseNoFile === url + '/') {
            rewrittenUrl = appBaseNoFile;
          }
          if (rewrittenUrl) {
            this.$$parse(rewrittenUrl);
          }
          return !!rewrittenUrl;
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBase + hashPrefix + this.$$url;
        };
      }
      var locationPrototype = {
        $$html5: false,
        $$replace: false,
        absUrl: locationGetter('$$absUrl'),
        url: function(url) {
          if (isUndefined(url)) {
            return this.$$url;
          }
          var match = PATH_MATCH.exec(url);
          if (match[1] || url === '')
            this.path(decodeURIComponent(match[1]));
          if (match[2] || match[1] || url === '')
            this.search(match[3] || '');
          this.hash(match[5] || '');
          return this;
        },
        protocol: locationGetter('$$protocol'),
        host: locationGetter('$$host'),
        port: locationGetter('$$port'),
        path: locationGetterSetter('$$path', function(path) {
          path = path !== null ? path.toString() : '';
          return path.charAt(0) == '/' ? path : '/' + path;
        }),
        search: function(search, paramValue) {
          switch (arguments.length) {
            case 0:
              return this.$$search;
            case 1:
              if (isString(search) || isNumber(search)) {
                search = search.toString();
                this.$$search = parseKeyValue(search);
              } else if (isObject(search)) {
                search = copy(search, {});
                forEach(search, function(value, key) {
                  if (value == null)
                    delete search[key];
                });
                this.$$search = search;
              } else {
                throw $locationMinErr('isrcharg', 'The first argument of the `$location#search()` call must be a string or an object.');
              }
              break;
            default:
              if (isUndefined(paramValue) || paramValue === null) {
                delete this.$$search[search];
              } else {
                this.$$search[search] = paramValue;
              }
          }
          this.$$compose();
          return this;
        },
        hash: locationGetterSetter('$$hash', function(hash) {
          return hash !== null ? hash.toString() : '';
        }),
        replace: function() {
          this.$$replace = true;
          return this;
        }
      };
      forEach([LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url], function(Location) {
        Location.prototype = Object.create(locationPrototype);
        Location.prototype.state = function(state) {
          if (!arguments.length) {
            return this.$$state;
          }
          if (Location !== LocationHtml5Url || !this.$$html5) {
            throw $locationMinErr('nostate', 'History API state support is available only ' + 'in HTML5 mode and only in browsers supporting HTML5 History API');
          }
          this.$$state = isUndefined(state) ? null : state;
          return this;
        };
      });
      function locationGetter(property) {
        return function() {
          return this[property];
        };
      }
      function locationGetterSetter(property, preprocess) {
        return function(value) {
          if (isUndefined(value)) {
            return this[property];
          }
          this[property] = preprocess(value);
          this.$$compose();
          return this;
        };
      }
      function $LocationProvider() {
        var hashPrefix = '',
            html5Mode = {
              enabled: false,
              requireBase: true,
              rewriteLinks: true
            };
        this.hashPrefix = function(prefix) {
          if (isDefined(prefix)) {
            hashPrefix = prefix;
            return this;
          } else {
            return hashPrefix;
          }
        };
        this.html5Mode = function(mode) {
          if (isBoolean(mode)) {
            html5Mode.enabled = mode;
            return this;
          } else if (isObject(mode)) {
            if (isBoolean(mode.enabled)) {
              html5Mode.enabled = mode.enabled;
            }
            if (isBoolean(mode.requireBase)) {
              html5Mode.requireBase = mode.requireBase;
            }
            if (isBoolean(mode.rewriteLinks)) {
              html5Mode.rewriteLinks = mode.rewriteLinks;
            }
            return this;
          } else {
            return html5Mode;
          }
        };
        this.$get = ['$rootScope', '$browser', '$sniffer', '$rootElement', '$window', function($rootScope, $browser, $sniffer, $rootElement, $window) {
          var $location,
              LocationMode,
              baseHref = $browser.baseHref(),
              initialUrl = $browser.url(),
              appBase;
          if (html5Mode.enabled) {
            if (!baseHref && html5Mode.requireBase) {
              throw $locationMinErr('nobase', "$location in HTML5 mode requires a <base> tag to be present!");
            }
            appBase = serverBase(initialUrl) + (baseHref || '/');
            LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
          } else {
            appBase = stripHash(initialUrl);
            LocationMode = LocationHashbangUrl;
          }
          var appBaseNoFile = stripFile(appBase);
          $location = new LocationMode(appBase, appBaseNoFile, '#' + hashPrefix);
          $location.$$parseLinkUrl(initialUrl, initialUrl);
          $location.$$state = $browser.state();
          var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
          function setBrowserUrlWithFallback(url, replace, state) {
            var oldUrl = $location.url();
            var oldState = $location.$$state;
            try {
              $browser.url(url, replace, state);
              $location.$$state = $browser.state();
            } catch (e) {
              $location.url(oldUrl);
              $location.$$state = oldState;
              throw e;
            }
          }
          $rootElement.on('click', function(event) {
            if (!html5Mode.rewriteLinks || event.ctrlKey || event.metaKey || event.shiftKey || event.which == 2 || event.button == 2)
              return;
            var elm = jqLite(event.target);
            while (nodeName_(elm[0]) !== 'a') {
              if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0])
                return;
            }
            var absHref = elm.prop('href');
            var relHref = elm.attr('href') || elm.attr('xlink:href');
            if (isObject(absHref) && absHref.toString() === '[object SVGAnimatedString]') {
              absHref = urlResolve(absHref.animVal).href;
            }
            if (IGNORE_URI_REGEXP.test(absHref))
              return;
            if (absHref && !elm.attr('target') && !event.isDefaultPrevented()) {
              if ($location.$$parseLinkUrl(absHref, relHref)) {
                event.preventDefault();
                if ($location.absUrl() != $browser.url()) {
                  $rootScope.$apply();
                  $window.angular['ff-684208-preventDefault'] = true;
                }
              }
            }
          });
          if (trimEmptyHash($location.absUrl()) != trimEmptyHash(initialUrl)) {
            $browser.url($location.absUrl(), true);
          }
          var initializing = true;
          $browser.onUrlChange(function(newUrl, newState) {
            if (isUndefined(beginsWith(appBaseNoFile, newUrl))) {
              $window.location.href = newUrl;
              return;
            }
            $rootScope.$evalAsync(function() {
              var oldUrl = $location.absUrl();
              var oldState = $location.$$state;
              var defaultPrevented;
              newUrl = trimEmptyHash(newUrl);
              $location.$$parse(newUrl);
              $location.$$state = newState;
              defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, newState, oldState).defaultPrevented;
              if ($location.absUrl() !== newUrl)
                return;
              if (defaultPrevented) {
                $location.$$parse(oldUrl);
                $location.$$state = oldState;
                setBrowserUrlWithFallback(oldUrl, false, oldState);
              } else {
                initializing = false;
                afterLocationChange(oldUrl, oldState);
              }
            });
            if (!$rootScope.$$phase)
              $rootScope.$digest();
          });
          $rootScope.$watch(function $locationWatch() {
            var oldUrl = trimEmptyHash($browser.url());
            var newUrl = trimEmptyHash($location.absUrl());
            var oldState = $browser.state();
            var currentReplace = $location.$$replace;
            var urlOrStateChanged = oldUrl !== newUrl || ($location.$$html5 && $sniffer.history && oldState !== $location.$$state);
            if (initializing || urlOrStateChanged) {
              initializing = false;
              $rootScope.$evalAsync(function() {
                var newUrl = $location.absUrl();
                var defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                if ($location.absUrl() !== newUrl)
                  return;
                if (defaultPrevented) {
                  $location.$$parse(oldUrl);
                  $location.$$state = oldState;
                } else {
                  if (urlOrStateChanged) {
                    setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state);
                  }
                  afterLocationChange(oldUrl, oldState);
                }
              });
            }
            $location.$$replace = false;
          });
          return $location;
          function afterLocationChange(oldUrl, oldState) {
            $rootScope.$broadcast('$locationChangeSuccess', $location.absUrl(), oldUrl, $location.$$state, oldState);
          }
        }];
      }
      function $LogProvider() {
        var debug = true,
            self = this;
        this.debugEnabled = function(flag) {
          if (isDefined(flag)) {
            debug = flag;
            return this;
          } else {
            return debug;
          }
        };
        this.$get = ['$window', function($window) {
          return {
            log: consoleLog('log'),
            info: consoleLog('info'),
            warn: consoleLog('warn'),
            error: consoleLog('error'),
            debug: (function() {
              var fn = consoleLog('debug');
              return function() {
                if (debug) {
                  fn.apply(self, arguments);
                }
              };
            }())
          };
          function formatError(arg) {
            if (arg instanceof Error) {
              if (arg.stack) {
                arg = (arg.message && arg.stack.indexOf(arg.message) === -1) ? 'Error: ' + arg.message + '\n' + arg.stack : arg.stack;
              } else if (arg.sourceURL) {
                arg = arg.message + '\n' + arg.sourceURL + ':' + arg.line;
              }
            }
            return arg;
          }
          function consoleLog(type) {
            var console = $window.console || {},
                logFn = console[type] || console.log || noop,
                hasApply = false;
            try {
              hasApply = !!logFn.apply;
            } catch (e) {}
            if (hasApply) {
              return function() {
                var args = [];
                forEach(arguments, function(arg) {
                  args.push(formatError(arg));
                });
                return logFn.apply(console, args);
              };
            }
            return function(arg1, arg2) {
              logFn(arg1, arg2 == null ? '' : arg2);
            };
          }
        }];
      }
      var $parseMinErr = minErr('$parse');
      function ensureSafeMemberName(name, fullExpression) {
        if (name === "__defineGetter__" || name === "__defineSetter__" || name === "__lookupGetter__" || name === "__lookupSetter__" || name === "__proto__") {
          throw $parseMinErr('isecfld', 'Attempting to access a disallowed field in Angular expressions! ' + 'Expression: {0}', fullExpression);
        }
        return name;
      }
      function getStringValue(name, fullExpression) {
        name = name + '';
        if (!isString(name)) {
          throw $parseMinErr('iseccst', 'Cannot convert object to primitive value! ' + 'Expression: {0}', fullExpression);
        }
        return name;
      }
      function ensureSafeObject(obj, fullExpression) {
        if (obj) {
          if (obj.constructor === obj) {
            throw $parseMinErr('isecfn', 'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj.window === obj) {
            throw $parseMinErr('isecwindow', 'Referencing the Window in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj.children && (obj.nodeName || (obj.prop && obj.attr && obj.find))) {
            throw $parseMinErr('isecdom', 'Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj === Object) {
            throw $parseMinErr('isecobj', 'Referencing Object in Angular expressions is disallowed! Expression: {0}', fullExpression);
          }
        }
        return obj;
      }
      var CALL = Function.prototype.call;
      var APPLY = Function.prototype.apply;
      var BIND = Function.prototype.bind;
      function ensureSafeFunction(obj, fullExpression) {
        if (obj) {
          if (obj.constructor === obj) {
            throw $parseMinErr('isecfn', 'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj === CALL || obj === APPLY || obj === BIND) {
            throw $parseMinErr('isecff', 'Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}', fullExpression);
          }
        }
      }
      function ensureSafeAssignContext(obj, fullExpression) {
        if (obj) {
          if (obj === (0).constructor || obj === (false).constructor || obj === ''.constructor || obj === {}.constructor || obj === [].constructor || obj === Function.constructor) {
            throw $parseMinErr('isecaf', 'Assigning to a constructor is disallowed! Expression: {0}', fullExpression);
          }
        }
      }
      var OPERATORS = createMap();
      forEach('+ - * / % === !== == != < > <= >= && || ! = |'.split(' '), function(operator) {
        OPERATORS[operator] = true;
      });
      var ESCAPE = {
        "n": "\n",
        "f": "\f",
        "r": "\r",
        "t": "\t",
        "v": "\v",
        "'": "'",
        '"': '"'
      };
      var Lexer = function(options) {
        this.options = options;
      };
      Lexer.prototype = {
        constructor: Lexer,
        lex: function(text) {
          this.text = text;
          this.index = 0;
          this.tokens = [];
          while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            if (ch === '"' || ch === "'") {
              this.readString(ch);
            } else if (this.isNumber(ch) || ch === '.' && this.isNumber(this.peek())) {
              this.readNumber();
            } else if (this.isIdent(ch)) {
              this.readIdent();
            } else if (this.is(ch, '(){}[].,;:?')) {
              this.tokens.push({
                index: this.index,
                text: ch
              });
              this.index++;
            } else if (this.isWhitespace(ch)) {
              this.index++;
            } else {
              var ch2 = ch + this.peek();
              var ch3 = ch2 + this.peek(2);
              var op1 = OPERATORS[ch];
              var op2 = OPERATORS[ch2];
              var op3 = OPERATORS[ch3];
              if (op1 || op2 || op3) {
                var token = op3 ? ch3 : (op2 ? ch2 : ch);
                this.tokens.push({
                  index: this.index,
                  text: token,
                  operator: true
                });
                this.index += token.length;
              } else {
                this.throwError('Unexpected next character ', this.index, this.index + 1);
              }
            }
          }
          return this.tokens;
        },
        is: function(ch, chars) {
          return chars.indexOf(ch) !== -1;
        },
        peek: function(i) {
          var num = i || 1;
          return (this.index + num < this.text.length) ? this.text.charAt(this.index + num) : false;
        },
        isNumber: function(ch) {
          return ('0' <= ch && ch <= '9') && typeof ch === "string";
        },
        isWhitespace: function(ch) {
          return (ch === ' ' || ch === '\r' || ch === '\t' || ch === '\n' || ch === '\v' || ch === '\u00A0');
        },
        isIdent: function(ch) {
          return ('a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || '_' === ch || ch === '$');
        },
        isExpOperator: function(ch) {
          return (ch === '-' || ch === '+' || this.isNumber(ch));
        },
        throwError: function(error, start, end) {
          end = end || this.index;
          var colStr = (isDefined(start) ? 's ' + start + '-' + this.index + ' [' + this.text.substring(start, end) + ']' : ' ' + end);
          throw $parseMinErr('lexerr', 'Lexer Error: {0} at column{1} in expression [{2}].', error, colStr, this.text);
        },
        readNumber: function() {
          var number = '';
          var start = this.index;
          while (this.index < this.text.length) {
            var ch = lowercase(this.text.charAt(this.index));
            if (ch == '.' || this.isNumber(ch)) {
              number += ch;
            } else {
              var peekCh = this.peek();
              if (ch == 'e' && this.isExpOperator(peekCh)) {
                number += ch;
              } else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && number.charAt(number.length - 1) == 'e') {
                number += ch;
              } else if (this.isExpOperator(ch) && (!peekCh || !this.isNumber(peekCh)) && number.charAt(number.length - 1) == 'e') {
                this.throwError('Invalid exponent');
              } else {
                break;
              }
            }
            this.index++;
          }
          this.tokens.push({
            index: start,
            text: number,
            constant: true,
            value: Number(number)
          });
        },
        readIdent: function() {
          var start = this.index;
          while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            if (!(this.isIdent(ch) || this.isNumber(ch))) {
              break;
            }
            this.index++;
          }
          this.tokens.push({
            index: start,
            text: this.text.slice(start, this.index),
            identifier: true
          });
        },
        readString: function(quote) {
          var start = this.index;
          this.index++;
          var string = '';
          var rawString = quote;
          var escape = false;
          while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            rawString += ch;
            if (escape) {
              if (ch === 'u') {
                var hex = this.text.substring(this.index + 1, this.index + 5);
                if (!hex.match(/[\da-f]{4}/i)) {
                  this.throwError('Invalid unicode escape [\\u' + hex + ']');
                }
                this.index += 4;
                string += String.fromCharCode(parseInt(hex, 16));
              } else {
                var rep = ESCAPE[ch];
                string = string + (rep || ch);
              }
              escape = false;
            } else if (ch === '\\') {
              escape = true;
            } else if (ch === quote) {
              this.index++;
              this.tokens.push({
                index: start,
                text: rawString,
                constant: true,
                value: string
              });
              return;
            } else {
              string += ch;
            }
            this.index++;
          }
          this.throwError('Unterminated quote', start);
        }
      };
      var AST = function(lexer, options) {
        this.lexer = lexer;
        this.options = options;
      };
      AST.Program = 'Program';
      AST.ExpressionStatement = 'ExpressionStatement';
      AST.AssignmentExpression = 'AssignmentExpression';
      AST.ConditionalExpression = 'ConditionalExpression';
      AST.LogicalExpression = 'LogicalExpression';
      AST.BinaryExpression = 'BinaryExpression';
      AST.UnaryExpression = 'UnaryExpression';
      AST.CallExpression = 'CallExpression';
      AST.MemberExpression = 'MemberExpression';
      AST.Identifier = 'Identifier';
      AST.Literal = 'Literal';
      AST.ArrayExpression = 'ArrayExpression';
      AST.Property = 'Property';
      AST.ObjectExpression = 'ObjectExpression';
      AST.ThisExpression = 'ThisExpression';
      AST.NGValueParameter = 'NGValueParameter';
      AST.prototype = {
        ast: function(text) {
          this.text = text;
          this.tokens = this.lexer.lex(text);
          var value = this.program();
          if (this.tokens.length !== 0) {
            this.throwError('is an unexpected token', this.tokens[0]);
          }
          return value;
        },
        program: function() {
          var body = [];
          while (true) {
            if (this.tokens.length > 0 && !this.peek('}', ')', ';', ']'))
              body.push(this.expressionStatement());
            if (!this.expect(';')) {
              return {
                type: AST.Program,
                body: body
              };
            }
          }
        },
        expressionStatement: function() {
          return {
            type: AST.ExpressionStatement,
            expression: this.filterChain()
          };
        },
        filterChain: function() {
          var left = this.expression();
          var token;
          while ((token = this.expect('|'))) {
            left = this.filter(left);
          }
          return left;
        },
        expression: function() {
          return this.assignment();
        },
        assignment: function() {
          var result = this.ternary();
          if (this.expect('=')) {
            result = {
              type: AST.AssignmentExpression,
              left: result,
              right: this.assignment(),
              operator: '='
            };
          }
          return result;
        },
        ternary: function() {
          var test = this.logicalOR();
          var alternate;
          var consequent;
          if (this.expect('?')) {
            alternate = this.expression();
            if (this.consume(':')) {
              consequent = this.expression();
              return {
                type: AST.ConditionalExpression,
                test: test,
                alternate: alternate,
                consequent: consequent
              };
            }
          }
          return test;
        },
        logicalOR: function() {
          var left = this.logicalAND();
          while (this.expect('||')) {
            left = {
              type: AST.LogicalExpression,
              operator: '||',
              left: left,
              right: this.logicalAND()
            };
          }
          return left;
        },
        logicalAND: function() {
          var left = this.equality();
          while (this.expect('&&')) {
            left = {
              type: AST.LogicalExpression,
              operator: '&&',
              left: left,
              right: this.equality()
            };
          }
          return left;
        },
        equality: function() {
          var left = this.relational();
          var token;
          while ((token = this.expect('==', '!=', '===', '!=='))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.relational()
            };
          }
          return left;
        },
        relational: function() {
          var left = this.additive();
          var token;
          while ((token = this.expect('<', '>', '<=', '>='))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.additive()
            };
          }
          return left;
        },
        additive: function() {
          var left = this.multiplicative();
          var token;
          while ((token = this.expect('+', '-'))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.multiplicative()
            };
          }
          return left;
        },
        multiplicative: function() {
          var left = this.unary();
          var token;
          while ((token = this.expect('*', '/', '%'))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.unary()
            };
          }
          return left;
        },
        unary: function() {
          var token;
          if ((token = this.expect('+', '-', '!'))) {
            return {
              type: AST.UnaryExpression,
              operator: token.text,
              prefix: true,
              argument: this.unary()
            };
          } else {
            return this.primary();
          }
        },
        primary: function() {
          var primary;
          if (this.expect('(')) {
            primary = this.filterChain();
            this.consume(')');
          } else if (this.expect('[')) {
            primary = this.arrayDeclaration();
          } else if (this.expect('{')) {
            primary = this.object();
          } else if (this.constants.hasOwnProperty(this.peek().text)) {
            primary = copy(this.constants[this.consume().text]);
          } else if (this.peek().identifier) {
            primary = this.identifier();
          } else if (this.peek().constant) {
            primary = this.constant();
          } else {
            this.throwError('not a primary expression', this.peek());
          }
          var next;
          while ((next = this.expect('(', '[', '.'))) {
            if (next.text === '(') {
              primary = {
                type: AST.CallExpression,
                callee: primary,
                arguments: this.parseArguments()
              };
              this.consume(')');
            } else if (next.text === '[') {
              primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.expression(),
                computed: true
              };
              this.consume(']');
            } else if (next.text === '.') {
              primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.identifier(),
                computed: false
              };
            } else {
              this.throwError('IMPOSSIBLE');
            }
          }
          return primary;
        },
        filter: function(baseExpression) {
          var args = [baseExpression];
          var result = {
            type: AST.CallExpression,
            callee: this.identifier(),
            arguments: args,
            filter: true
          };
          while (this.expect(':')) {
            args.push(this.expression());
          }
          return result;
        },
        parseArguments: function() {
          var args = [];
          if (this.peekToken().text !== ')') {
            do {
              args.push(this.expression());
            } while (this.expect(','));
          }
          return args;
        },
        identifier: function() {
          var token = this.consume();
          if (!token.identifier) {
            this.throwError('is not a valid identifier', token);
          }
          return {
            type: AST.Identifier,
            name: token.text
          };
        },
        constant: function() {
          return {
            type: AST.Literal,
            value: this.consume().value
          };
        },
        arrayDeclaration: function() {
          var elements = [];
          if (this.peekToken().text !== ']') {
            do {
              if (this.peek(']')) {
                break;
              }
              elements.push(this.expression());
            } while (this.expect(','));
          }
          this.consume(']');
          return {
            type: AST.ArrayExpression,
            elements: elements
          };
        },
        object: function() {
          var properties = [],
              property;
          if (this.peekToken().text !== '}') {
            do {
              if (this.peek('}')) {
                break;
              }
              property = {
                type: AST.Property,
                kind: 'init'
              };
              if (this.peek().constant) {
                property.key = this.constant();
              } else if (this.peek().identifier) {
                property.key = this.identifier();
              } else {
                this.throwError("invalid key", this.peek());
              }
              this.consume(':');
              property.value = this.expression();
              properties.push(property);
            } while (this.expect(','));
          }
          this.consume('}');
          return {
            type: AST.ObjectExpression,
            properties: properties
          };
        },
        throwError: function(msg, token) {
          throw $parseMinErr('syntax', 'Syntax Error: Token \'{0}\' {1} at column {2} of the expression [{3}] starting at [{4}].', token.text, msg, (token.index + 1), this.text, this.text.substring(token.index));
        },
        consume: function(e1) {
          if (this.tokens.length === 0) {
            throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
          }
          var token = this.expect(e1);
          if (!token) {
            this.throwError('is unexpected, expecting [' + e1 + ']', this.peek());
          }
          return token;
        },
        peekToken: function() {
          if (this.tokens.length === 0) {
            throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
          }
          return this.tokens[0];
        },
        peek: function(e1, e2, e3, e4) {
          return this.peekAhead(0, e1, e2, e3, e4);
        },
        peekAhead: function(i, e1, e2, e3, e4) {
          if (this.tokens.length > i) {
            var token = this.tokens[i];
            var t = token.text;
            if (t === e1 || t === e2 || t === e3 || t === e4 || (!e1 && !e2 && !e3 && !e4)) {
              return token;
            }
          }
          return false;
        },
        expect: function(e1, e2, e3, e4) {
          var token = this.peek(e1, e2, e3, e4);
          if (token) {
            this.tokens.shift();
            return token;
          }
          return false;
        },
        constants: {
          'true': {
            type: AST.Literal,
            value: true
          },
          'false': {
            type: AST.Literal,
            value: false
          },
          'null': {
            type: AST.Literal,
            value: null
          },
          'undefined': {
            type: AST.Literal,
            value: undefined
          },
          'this': {type: AST.ThisExpression}
        }
      };
      function ifDefined(v, d) {
        return typeof v !== 'undefined' ? v : d;
      }
      function plusFn(l, r) {
        if (typeof l === 'undefined')
          return r;
        if (typeof r === 'undefined')
          return l;
        return l + r;
      }
      function isStateless($filter, filterName) {
        var fn = $filter(filterName);
        return !fn.$stateful;
      }
      function findConstantAndWatchExpressions(ast, $filter) {
        var allConstants;
        var argsToWatch;
        switch (ast.type) {
          case AST.Program:
            allConstants = true;
            forEach(ast.body, function(expr) {
              findConstantAndWatchExpressions(expr.expression, $filter);
              allConstants = allConstants && expr.expression.constant;
            });
            ast.constant = allConstants;
            break;
          case AST.Literal:
            ast.constant = true;
            ast.toWatch = [];
            break;
          case AST.UnaryExpression:
            findConstantAndWatchExpressions(ast.argument, $filter);
            ast.constant = ast.argument.constant;
            ast.toWatch = ast.argument.toWatch;
            break;
          case AST.BinaryExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
            break;
          case AST.LogicalExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = ast.constant ? [] : [ast];
            break;
          case AST.ConditionalExpression:
            findConstantAndWatchExpressions(ast.test, $filter);
            findConstantAndWatchExpressions(ast.alternate, $filter);
            findConstantAndWatchExpressions(ast.consequent, $filter);
            ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant;
            ast.toWatch = ast.constant ? [] : [ast];
            break;
          case AST.Identifier:
            ast.constant = false;
            ast.toWatch = [ast];
            break;
          case AST.MemberExpression:
            findConstantAndWatchExpressions(ast.object, $filter);
            if (ast.computed) {
              findConstantAndWatchExpressions(ast.property, $filter);
            }
            ast.constant = ast.object.constant && (!ast.computed || ast.property.constant);
            ast.toWatch = [ast];
            break;
          case AST.CallExpression:
            allConstants = ast.filter ? isStateless($filter, ast.callee.name) : false;
            argsToWatch = [];
            forEach(ast.arguments, function(expr) {
              findConstantAndWatchExpressions(expr, $filter);
              allConstants = allConstants && expr.constant;
              if (!expr.constant) {
                argsToWatch.push.apply(argsToWatch, expr.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = ast.filter && isStateless($filter, ast.callee.name) ? argsToWatch : [ast];
            break;
          case AST.AssignmentExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = [ast];
            break;
          case AST.ArrayExpression:
            allConstants = true;
            argsToWatch = [];
            forEach(ast.elements, function(expr) {
              findConstantAndWatchExpressions(expr, $filter);
              allConstants = allConstants && expr.constant;
              if (!expr.constant) {
                argsToWatch.push.apply(argsToWatch, expr.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = argsToWatch;
            break;
          case AST.ObjectExpression:
            allConstants = true;
            argsToWatch = [];
            forEach(ast.properties, function(property) {
              findConstantAndWatchExpressions(property.value, $filter);
              allConstants = allConstants && property.value.constant;
              if (!property.value.constant) {
                argsToWatch.push.apply(argsToWatch, property.value.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = argsToWatch;
            break;
          case AST.ThisExpression:
            ast.constant = false;
            ast.toWatch = [];
            break;
        }
      }
      function getInputs(body) {
        if (body.length != 1)
          return;
        var lastExpression = body[0].expression;
        var candidate = lastExpression.toWatch;
        if (candidate.length !== 1)
          return candidate;
        return candidate[0] !== lastExpression ? candidate : undefined;
      }
      function isAssignable(ast) {
        return ast.type === AST.Identifier || ast.type === AST.MemberExpression;
      }
      function assignableAST(ast) {
        if (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {
          return {
            type: AST.AssignmentExpression,
            left: ast.body[0].expression,
            right: {type: AST.NGValueParameter},
            operator: '='
          };
        }
      }
      function isLiteral(ast) {
        return ast.body.length === 0 || ast.body.length === 1 && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression);
      }
      function isConstant(ast) {
        return ast.constant;
      }
      function ASTCompiler(astBuilder, $filter) {
        this.astBuilder = astBuilder;
        this.$filter = $filter;
      }
      ASTCompiler.prototype = {
        compile: function(expression, expensiveChecks) {
          var self = this;
          var ast = this.astBuilder.ast(expression);
          this.state = {
            nextId: 0,
            filters: {},
            expensiveChecks: expensiveChecks,
            fn: {
              vars: [],
              body: [],
              own: {}
            },
            assign: {
              vars: [],
              body: [],
              own: {}
            },
            inputs: []
          };
          findConstantAndWatchExpressions(ast, self.$filter);
          var extra = '';
          var assignable;
          this.stage = 'assign';
          if ((assignable = assignableAST(ast))) {
            this.state.computing = 'assign';
            var result = this.nextId();
            this.recurse(assignable, result);
            this.return_(result);
            extra = 'fn.assign=' + this.generateFunction('assign', 's,v,l');
          }
          var toWatch = getInputs(ast.body);
          self.stage = 'inputs';
          forEach(toWatch, function(watch, key) {
            var fnKey = 'fn' + key;
            self.state[fnKey] = {
              vars: [],
              body: [],
              own: {}
            };
            self.state.computing = fnKey;
            var intoId = self.nextId();
            self.recurse(watch, intoId);
            self.return_(intoId);
            self.state.inputs.push(fnKey);
            watch.watchId = key;
          });
          this.state.computing = 'fn';
          this.stage = 'main';
          this.recurse(ast);
          var fnString = '"' + this.USE + ' ' + this.STRICT + '";\n' + this.filterPrefix() + 'var fn=' + this.generateFunction('fn', 's,l,a,i') + extra + this.watchFns() + 'return fn;';
          var fn = (new Function('$filter', 'ensureSafeMemberName', 'ensureSafeObject', 'ensureSafeFunction', 'getStringValue', 'ensureSafeAssignContext', 'ifDefined', 'plus', 'text', fnString))(this.$filter, ensureSafeMemberName, ensureSafeObject, ensureSafeFunction, getStringValue, ensureSafeAssignContext, ifDefined, plusFn, expression);
          this.state = this.stage = undefined;
          fn.literal = isLiteral(ast);
          fn.constant = isConstant(ast);
          return fn;
        },
        USE: 'use',
        STRICT: 'strict',
        watchFns: function() {
          var result = [];
          var fns = this.state.inputs;
          var self = this;
          forEach(fns, function(name) {
            result.push('var ' + name + '=' + self.generateFunction(name, 's'));
          });
          if (fns.length) {
            result.push('fn.inputs=[' + fns.join(',') + '];');
          }
          return result.join('');
        },
        generateFunction: function(name, params) {
          return 'function(' + params + '){' + this.varsPrefix(name) + this.body(name) + '};';
        },
        filterPrefix: function() {
          var parts = [];
          var self = this;
          forEach(this.state.filters, function(id, filter) {
            parts.push(id + '=$filter(' + self.escape(filter) + ')');
          });
          if (parts.length)
            return 'var ' + parts.join(',') + ';';
          return '';
        },
        varsPrefix: function(section) {
          return this.state[section].vars.length ? 'var ' + this.state[section].vars.join(',') + ';' : '';
        },
        body: function(section) {
          return this.state[section].body.join('');
        },
        recurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
          var left,
              right,
              self = this,
              args,
              expression;
          recursionFn = recursionFn || noop;
          if (!skipWatchIdCheck && isDefined(ast.watchId)) {
            intoId = intoId || this.nextId();
            this.if_('i', this.lazyAssign(intoId, this.computedMember('i', ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, true));
            return;
          }
          switch (ast.type) {
            case AST.Program:
              forEach(ast.body, function(expression, pos) {
                self.recurse(expression.expression, undefined, undefined, function(expr) {
                  right = expr;
                });
                if (pos !== ast.body.length - 1) {
                  self.current().body.push(right, ';');
                } else {
                  self.return_(right);
                }
              });
              break;
            case AST.Literal:
              expression = this.escape(ast.value);
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.UnaryExpression:
              this.recurse(ast.argument, undefined, undefined, function(expr) {
                right = expr;
              });
              expression = ast.operator + '(' + this.ifDefined(right, 0) + ')';
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.BinaryExpression:
              this.recurse(ast.left, undefined, undefined, function(expr) {
                left = expr;
              });
              this.recurse(ast.right, undefined, undefined, function(expr) {
                right = expr;
              });
              if (ast.operator === '+') {
                expression = this.plus(left, right);
              } else if (ast.operator === '-') {
                expression = this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);
              } else {
                expression = '(' + left + ')' + ast.operator + '(' + right + ')';
              }
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.LogicalExpression:
              intoId = intoId || this.nextId();
              self.recurse(ast.left, intoId);
              self.if_(ast.operator === '&&' ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId));
              recursionFn(intoId);
              break;
            case AST.ConditionalExpression:
              intoId = intoId || this.nextId();
              self.recurse(ast.test, intoId);
              self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId));
              recursionFn(intoId);
              break;
            case AST.Identifier:
              intoId = intoId || this.nextId();
              if (nameId) {
                nameId.context = self.stage === 'inputs' ? 's' : this.assign(this.nextId(), this.getHasOwnProperty('l', ast.name) + '?l:s');
                nameId.computed = false;
                nameId.name = ast.name;
              }
              ensureSafeMemberName(ast.name);
              self.if_(self.stage === 'inputs' || self.not(self.getHasOwnProperty('l', ast.name)), function() {
                self.if_(self.stage === 'inputs' || 's', function() {
                  if (create && create !== 1) {
                    self.if_(self.not(self.nonComputedMember('s', ast.name)), self.lazyAssign(self.nonComputedMember('s', ast.name), '{}'));
                  }
                  self.assign(intoId, self.nonComputedMember('s', ast.name));
                });
              }, intoId && self.lazyAssign(intoId, self.nonComputedMember('l', ast.name)));
              if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.name)) {
                self.addEnsureSafeObject(intoId);
              }
              recursionFn(intoId);
              break;
            case AST.MemberExpression:
              left = nameId && (nameId.context = this.nextId()) || this.nextId();
              intoId = intoId || this.nextId();
              self.recurse(ast.object, left, undefined, function() {
                self.if_(self.notNull(left), function() {
                  if (ast.computed) {
                    right = self.nextId();
                    self.recurse(ast.property, right);
                    self.getStringValue(right);
                    self.addEnsureSafeMemberName(right);
                    if (create && create !== 1) {
                      self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), '{}'));
                    }
                    expression = self.ensureSafeObject(self.computedMember(left, right));
                    self.assign(intoId, expression);
                    if (nameId) {
                      nameId.computed = true;
                      nameId.name = right;
                    }
                  } else {
                    ensureSafeMemberName(ast.property.name);
                    if (create && create !== 1) {
                      self.if_(self.not(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), '{}'));
                    }
                    expression = self.nonComputedMember(left, ast.property.name);
                    if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.property.name)) {
                      expression = self.ensureSafeObject(expression);
                    }
                    self.assign(intoId, expression);
                    if (nameId) {
                      nameId.computed = false;
                      nameId.name = ast.property.name;
                    }
                  }
                }, function() {
                  self.assign(intoId, 'undefined');
                });
                recursionFn(intoId);
              }, !!create);
              break;
            case AST.CallExpression:
              intoId = intoId || this.nextId();
              if (ast.filter) {
                right = self.filter(ast.callee.name);
                args = [];
                forEach(ast.arguments, function(expr) {
                  var argument = self.nextId();
                  self.recurse(expr, argument);
                  args.push(argument);
                });
                expression = right + '(' + args.join(',') + ')';
                self.assign(intoId, expression);
                recursionFn(intoId);
              } else {
                right = self.nextId();
                left = {};
                args = [];
                self.recurse(ast.callee, right, left, function() {
                  self.if_(self.notNull(right), function() {
                    self.addEnsureSafeFunction(right);
                    forEach(ast.arguments, function(expr) {
                      self.recurse(expr, self.nextId(), undefined, function(argument) {
                        args.push(self.ensureSafeObject(argument));
                      });
                    });
                    if (left.name) {
                      if (!self.state.expensiveChecks) {
                        self.addEnsureSafeObject(left.context);
                      }
                      expression = self.member(left.context, left.name, left.computed) + '(' + args.join(',') + ')';
                    } else {
                      expression = right + '(' + args.join(',') + ')';
                    }
                    expression = self.ensureSafeObject(expression);
                    self.assign(intoId, expression);
                  }, function() {
                    self.assign(intoId, 'undefined');
                  });
                  recursionFn(intoId);
                });
              }
              break;
            case AST.AssignmentExpression:
              right = this.nextId();
              left = {};
              if (!isAssignable(ast.left)) {
                throw $parseMinErr('lval', 'Trying to assing a value to a non l-value');
              }
              this.recurse(ast.left, undefined, left, function() {
                self.if_(self.notNull(left.context), function() {
                  self.recurse(ast.right, right);
                  self.addEnsureSafeObject(self.member(left.context, left.name, left.computed));
                  self.addEnsureSafeAssignContext(left.context);
                  expression = self.member(left.context, left.name, left.computed) + ast.operator + right;
                  self.assign(intoId, expression);
                  recursionFn(intoId || expression);
                });
              }, 1);
              break;
            case AST.ArrayExpression:
              args = [];
              forEach(ast.elements, function(expr) {
                self.recurse(expr, self.nextId(), undefined, function(argument) {
                  args.push(argument);
                });
              });
              expression = '[' + args.join(',') + ']';
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.ObjectExpression:
              args = [];
              forEach(ast.properties, function(property) {
                self.recurse(property.value, self.nextId(), undefined, function(expr) {
                  args.push(self.escape(property.key.type === AST.Identifier ? property.key.name : ('' + property.key.value)) + ':' + expr);
                });
              });
              expression = '{' + args.join(',') + '}';
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.ThisExpression:
              this.assign(intoId, 's');
              recursionFn('s');
              break;
            case AST.NGValueParameter:
              this.assign(intoId, 'v');
              recursionFn('v');
              break;
          }
        },
        getHasOwnProperty: function(element, property) {
          var key = element + '.' + property;
          var own = this.current().own;
          if (!own.hasOwnProperty(key)) {
            own[key] = this.nextId(false, element + '&&(' + this.escape(property) + ' in ' + element + ')');
          }
          return own[key];
        },
        assign: function(id, value) {
          if (!id)
            return;
          this.current().body.push(id, '=', value, ';');
          return id;
        },
        filter: function(filterName) {
          if (!this.state.filters.hasOwnProperty(filterName)) {
            this.state.filters[filterName] = this.nextId(true);
          }
          return this.state.filters[filterName];
        },
        ifDefined: function(id, defaultValue) {
          return 'ifDefined(' + id + ',' + this.escape(defaultValue) + ')';
        },
        plus: function(left, right) {
          return 'plus(' + left + ',' + right + ')';
        },
        return_: function(id) {
          this.current().body.push('return ', id, ';');
        },
        if_: function(test, alternate, consequent) {
          if (test === true) {
            alternate();
          } else {
            var body = this.current().body;
            body.push('if(', test, '){');
            alternate();
            body.push('}');
            if (consequent) {
              body.push('else{');
              consequent();
              body.push('}');
            }
          }
        },
        not: function(expression) {
          return '!(' + expression + ')';
        },
        notNull: function(expression) {
          return expression + '!=null';
        },
        nonComputedMember: function(left, right) {
          return left + '.' + right;
        },
        computedMember: function(left, right) {
          return left + '[' + right + ']';
        },
        member: function(left, right, computed) {
          if (computed)
            return this.computedMember(left, right);
          return this.nonComputedMember(left, right);
        },
        addEnsureSafeObject: function(item) {
          this.current().body.push(this.ensureSafeObject(item), ';');
        },
        addEnsureSafeMemberName: function(item) {
          this.current().body.push(this.ensureSafeMemberName(item), ';');
        },
        addEnsureSafeFunction: function(item) {
          this.current().body.push(this.ensureSafeFunction(item), ';');
        },
        addEnsureSafeAssignContext: function(item) {
          this.current().body.push(this.ensureSafeAssignContext(item), ';');
        },
        ensureSafeObject: function(item) {
          return 'ensureSafeObject(' + item + ',text)';
        },
        ensureSafeMemberName: function(item) {
          return 'ensureSafeMemberName(' + item + ',text)';
        },
        ensureSafeFunction: function(item) {
          return 'ensureSafeFunction(' + item + ',text)';
        },
        getStringValue: function(item) {
          this.assign(item, 'getStringValue(' + item + ',text)');
        },
        ensureSafeAssignContext: function(item) {
          return 'ensureSafeAssignContext(' + item + ',text)';
        },
        lazyRecurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
          var self = this;
          return function() {
            self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
          };
        },
        lazyAssign: function(id, value) {
          var self = this;
          return function() {
            self.assign(id, value);
          };
        },
        stringEscapeRegex: /[^ a-zA-Z0-9]/g,
        stringEscapeFn: function(c) {
          return '\\u' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4);
        },
        escape: function(value) {
          if (isString(value))
            return "'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'";
          if (isNumber(value))
            return value.toString();
          if (value === true)
            return 'true';
          if (value === false)
            return 'false';
          if (value === null)
            return 'null';
          if (typeof value === 'undefined')
            return 'undefined';
          throw $parseMinErr('esc', 'IMPOSSIBLE');
        },
        nextId: function(skip, init) {
          var id = 'v' + (this.state.nextId++);
          if (!skip) {
            this.current().vars.push(id + (init ? '=' + init : ''));
          }
          return id;
        },
        current: function() {
          return this.state[this.state.computing];
        }
      };
      function ASTInterpreter(astBuilder, $filter) {
        this.astBuilder = astBuilder;
        this.$filter = $filter;
      }
      ASTInterpreter.prototype = {
        compile: function(expression, expensiveChecks) {
          var self = this;
          var ast = this.astBuilder.ast(expression);
          this.expression = expression;
          this.expensiveChecks = expensiveChecks;
          findConstantAndWatchExpressions(ast, self.$filter);
          var assignable;
          var assign;
          if ((assignable = assignableAST(ast))) {
            assign = this.recurse(assignable);
          }
          var toWatch = getInputs(ast.body);
          var inputs;
          if (toWatch) {
            inputs = [];
            forEach(toWatch, function(watch, key) {
              var input = self.recurse(watch);
              watch.input = input;
              inputs.push(input);
              watch.watchId = key;
            });
          }
          var expressions = [];
          forEach(ast.body, function(expression) {
            expressions.push(self.recurse(expression.expression));
          });
          var fn = ast.body.length === 0 ? function() {} : ast.body.length === 1 ? expressions[0] : function(scope, locals) {
            var lastValue;
            forEach(expressions, function(exp) {
              lastValue = exp(scope, locals);
            });
            return lastValue;
          };
          if (assign) {
            fn.assign = function(scope, value, locals) {
              return assign(scope, locals, value);
            };
          }
          if (inputs) {
            fn.inputs = inputs;
          }
          fn.literal = isLiteral(ast);
          fn.constant = isConstant(ast);
          return fn;
        },
        recurse: function(ast, context, create) {
          var left,
              right,
              self = this,
              args,
              expression;
          if (ast.input) {
            return this.inputs(ast.input, ast.watchId);
          }
          switch (ast.type) {
            case AST.Literal:
              return this.value(ast.value, context);
            case AST.UnaryExpression:
              right = this.recurse(ast.argument);
              return this['unary' + ast.operator](right, context);
            case AST.BinaryExpression:
              left = this.recurse(ast.left);
              right = this.recurse(ast.right);
              return this['binary' + ast.operator](left, right, context);
            case AST.LogicalExpression:
              left = this.recurse(ast.left);
              right = this.recurse(ast.right);
              return this['binary' + ast.operator](left, right, context);
            case AST.ConditionalExpression:
              return this['ternary?:'](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context);
            case AST.Identifier:
              ensureSafeMemberName(ast.name, self.expression);
              return self.identifier(ast.name, self.expensiveChecks || isPossiblyDangerousMemberName(ast.name), context, create, self.expression);
            case AST.MemberExpression:
              left = this.recurse(ast.object, false, !!create);
              if (!ast.computed) {
                ensureSafeMemberName(ast.property.name, self.expression);
                right = ast.property.name;
              }
              if (ast.computed)
                right = this.recurse(ast.property);
              return ast.computed ? this.computedMember(left, right, context, create, self.expression) : this.nonComputedMember(left, right, self.expensiveChecks, context, create, self.expression);
            case AST.CallExpression:
              args = [];
              forEach(ast.arguments, function(expr) {
                args.push(self.recurse(expr));
              });
              if (ast.filter)
                right = this.$filter(ast.callee.name);
              if (!ast.filter)
                right = this.recurse(ast.callee, true);
              return ast.filter ? function(scope, locals, assign, inputs) {
                var values = [];
                for (var i = 0; i < args.length; ++i) {
                  values.push(args[i](scope, locals, assign, inputs));
                }
                var value = right.apply(undefined, values, inputs);
                return context ? {
                  context: undefined,
                  name: undefined,
                  value: value
                } : value;
              } : function(scope, locals, assign, inputs) {
                var rhs = right(scope, locals, assign, inputs);
                var value;
                if (rhs.value != null) {
                  ensureSafeObject(rhs.context, self.expression);
                  ensureSafeFunction(rhs.value, self.expression);
                  var values = [];
                  for (var i = 0; i < args.length; ++i) {
                    values.push(ensureSafeObject(args[i](scope, locals, assign, inputs), self.expression));
                  }
                  value = ensureSafeObject(rhs.value.apply(rhs.context, values), self.expression);
                }
                return context ? {value: value} : value;
              };
            case AST.AssignmentExpression:
              left = this.recurse(ast.left, true, 1);
              right = this.recurse(ast.right);
              return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs);
                var rhs = right(scope, locals, assign, inputs);
                ensureSafeObject(lhs.value, self.expression);
                ensureSafeAssignContext(lhs.context);
                lhs.context[lhs.name] = rhs;
                return context ? {value: rhs} : rhs;
              };
            case AST.ArrayExpression:
              args = [];
              forEach(ast.elements, function(expr) {
                args.push(self.recurse(expr));
              });
              return function(scope, locals, assign, inputs) {
                var value = [];
                for (var i = 0; i < args.length; ++i) {
                  value.push(args[i](scope, locals, assign, inputs));
                }
                return context ? {value: value} : value;
              };
            case AST.ObjectExpression:
              args = [];
              forEach(ast.properties, function(property) {
                args.push({
                  key: property.key.type === AST.Identifier ? property.key.name : ('' + property.key.value),
                  value: self.recurse(property.value)
                });
              });
              return function(scope, locals, assign, inputs) {
                var value = {};
                for (var i = 0; i < args.length; ++i) {
                  value[args[i].key] = args[i].value(scope, locals, assign, inputs);
                }
                return context ? {value: value} : value;
              };
            case AST.ThisExpression:
              return function(scope) {
                return context ? {value: scope} : scope;
              };
            case AST.NGValueParameter:
              return function(scope, locals, assign, inputs) {
                return context ? {value: assign} : assign;
              };
          }
        },
        'unary+': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = argument(scope, locals, assign, inputs);
            if (isDefined(arg)) {
              arg = +arg;
            } else {
              arg = 0;
            }
            return context ? {value: arg} : arg;
          };
        },
        'unary-': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = argument(scope, locals, assign, inputs);
            if (isDefined(arg)) {
              arg = -arg;
            } else {
              arg = 0;
            }
            return context ? {value: arg} : arg;
          };
        },
        'unary!': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = !argument(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary+': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs = right(scope, locals, assign, inputs);
            var arg = plusFn(lhs, rhs);
            return context ? {value: arg} : arg;
          };
        },
        'binary-': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs = right(scope, locals, assign, inputs);
            var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
            return context ? {value: arg} : arg;
          };
        },
        'binary*': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary/': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary%': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary===': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary!==': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary==': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary!=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary<': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary>': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary<=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary>=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary&&': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary||': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'ternary?:': function(test, alternate, consequent, context) {
          return function(scope, locals, assign, inputs) {
            var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        value: function(value, context) {
          return function() {
            return context ? {
              context: undefined,
              name: undefined,
              value: value
            } : value;
          };
        },
        identifier: function(name, expensiveChecks, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var base = locals && (name in locals) ? locals : scope;
            if (create && create !== 1 && base && !(base[name])) {
              base[name] = {};
            }
            var value = base ? base[name] : undefined;
            if (expensiveChecks) {
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: base,
                name: name,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        computedMember: function(left, right, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs;
            var value;
            if (lhs != null) {
              rhs = right(scope, locals, assign, inputs);
              rhs = getStringValue(rhs);
              ensureSafeMemberName(rhs, expression);
              if (create && create !== 1 && lhs && !(lhs[rhs])) {
                lhs[rhs] = {};
              }
              value = lhs[rhs];
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: lhs,
                name: rhs,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        nonComputedMember: function(left, right, expensiveChecks, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            if (create && create !== 1 && lhs && !(lhs[right])) {
              lhs[right] = {};
            }
            var value = lhs != null ? lhs[right] : undefined;
            if (expensiveChecks || isPossiblyDangerousMemberName(right)) {
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: lhs,
                name: right,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        inputs: function(input, watchId) {
          return function(scope, value, locals, inputs) {
            if (inputs)
              return inputs[watchId];
            return input(scope, value, locals);
          };
        }
      };
      var Parser = function(lexer, $filter, options) {
        this.lexer = lexer;
        this.$filter = $filter;
        this.options = options;
        this.ast = new AST(this.lexer);
        this.astCompiler = options.csp ? new ASTInterpreter(this.ast, $filter) : new ASTCompiler(this.ast, $filter);
      };
      Parser.prototype = {
        constructor: Parser,
        parse: function(text) {
          return this.astCompiler.compile(text, this.options.expensiveChecks);
        }
      };
      var getterFnCacheDefault = createMap();
      var getterFnCacheExpensive = createMap();
      function isPossiblyDangerousMemberName(name) {
        return name == 'constructor';
      }
      var objectValueOf = Object.prototype.valueOf;
      function getValueOf(value) {
        return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
      }
      function $ParseProvider() {
        var cacheDefault = createMap();
        var cacheExpensive = createMap();
        this.$get = ['$filter', function($filter) {
          var noUnsafeEval = csp().noUnsafeEval;
          var $parseOptions = {
            csp: noUnsafeEval,
            expensiveChecks: false
          },
              $parseOptionsExpensive = {
                csp: noUnsafeEval,
                expensiveChecks: true
              };
          return function $parse(exp, interceptorFn, expensiveChecks) {
            var parsedExpression,
                oneTime,
                cacheKey;
            switch (typeof exp) {
              case 'string':
                exp = exp.trim();
                cacheKey = exp;
                var cache = (expensiveChecks ? cacheExpensive : cacheDefault);
                parsedExpression = cache[cacheKey];
                if (!parsedExpression) {
                  if (exp.charAt(0) === ':' && exp.charAt(1) === ':') {
                    oneTime = true;
                    exp = exp.substring(2);
                  }
                  var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions;
                  var lexer = new Lexer(parseOptions);
                  var parser = new Parser(lexer, $filter, parseOptions);
                  parsedExpression = parser.parse(exp);
                  if (parsedExpression.constant) {
                    parsedExpression.$$watchDelegate = constantWatchDelegate;
                  } else if (oneTime) {
                    parsedExpression.$$watchDelegate = parsedExpression.literal ? oneTimeLiteralWatchDelegate : oneTimeWatchDelegate;
                  } else if (parsedExpression.inputs) {
                    parsedExpression.$$watchDelegate = inputsWatchDelegate;
                  }
                  cache[cacheKey] = parsedExpression;
                }
                return addInterceptor(parsedExpression, interceptorFn);
              case 'function':
                return addInterceptor(exp, interceptorFn);
              default:
                return noop;
            }
          };
          function expressionInputDirtyCheck(newValue, oldValueOfValue) {
            if (newValue == null || oldValueOfValue == null) {
              return newValue === oldValueOfValue;
            }
            if (typeof newValue === 'object') {
              newValue = getValueOf(newValue);
              if (typeof newValue === 'object') {
                return false;
              }
            }
            return newValue === oldValueOfValue || (newValue !== newValue && oldValueOfValue !== oldValueOfValue);
          }
          function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
            var inputExpressions = parsedExpression.inputs;
            var lastResult;
            if (inputExpressions.length === 1) {
              var oldInputValueOf = expressionInputDirtyCheck;
              inputExpressions = inputExpressions[0];
              return scope.$watch(function expressionInputWatch(scope) {
                var newInputValue = inputExpressions(scope);
                if (!expressionInputDirtyCheck(newInputValue, oldInputValueOf)) {
                  lastResult = parsedExpression(scope, undefined, undefined, [newInputValue]);
                  oldInputValueOf = newInputValue && getValueOf(newInputValue);
                }
                return lastResult;
              }, listener, objectEquality, prettyPrintExpression);
            }
            var oldInputValueOfValues = [];
            var oldInputValues = [];
            for (var i = 0,
                ii = inputExpressions.length; i < ii; i++) {
              oldInputValueOfValues[i] = expressionInputDirtyCheck;
              oldInputValues[i] = null;
            }
            return scope.$watch(function expressionInputsWatch(scope) {
              var changed = false;
              for (var i = 0,
                  ii = inputExpressions.length; i < ii; i++) {
                var newInputValue = inputExpressions[i](scope);
                if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) {
                  oldInputValues[i] = newInputValue;
                  oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue);
                }
              }
              if (changed) {
                lastResult = parsedExpression(scope, undefined, undefined, oldInputValues);
              }
              return lastResult;
            }, listener, objectEquality, prettyPrintExpression);
          }
          function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch,
                lastValue;
            return unwatch = scope.$watch(function oneTimeWatch(scope) {
              return parsedExpression(scope);
            }, function oneTimeListener(value, old, scope) {
              lastValue = value;
              if (isFunction(listener)) {
                listener.apply(this, arguments);
              }
              if (isDefined(value)) {
                scope.$$postDigest(function() {
                  if (isDefined(lastValue)) {
                    unwatch();
                  }
                });
              }
            }, objectEquality);
          }
          function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch,
                lastValue;
            return unwatch = scope.$watch(function oneTimeWatch(scope) {
              return parsedExpression(scope);
            }, function oneTimeListener(value, old, scope) {
              lastValue = value;
              if (isFunction(listener)) {
                listener.call(this, value, old, scope);
              }
              if (isAllDefined(value)) {
                scope.$$postDigest(function() {
                  if (isAllDefined(lastValue))
                    unwatch();
                });
              }
            }, objectEquality);
            function isAllDefined(value) {
              var allDefined = true;
              forEach(value, function(val) {
                if (!isDefined(val))
                  allDefined = false;
              });
              return allDefined;
            }
          }
          function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch;
            return unwatch = scope.$watch(function constantWatch(scope) {
              return parsedExpression(scope);
            }, function constantListener(value, old, scope) {
              if (isFunction(listener)) {
                listener.apply(this, arguments);
              }
              unwatch();
            }, objectEquality);
          }
          function addInterceptor(parsedExpression, interceptorFn) {
            if (!interceptorFn)
              return parsedExpression;
            var watchDelegate = parsedExpression.$$watchDelegate;
            var useInputs = false;
            var regularWatch = watchDelegate !== oneTimeLiteralWatchDelegate && watchDelegate !== oneTimeWatchDelegate;
            var fn = regularWatch ? function regularInterceptedExpression(scope, locals, assign, inputs) {
              var value = useInputs && inputs ? inputs[0] : parsedExpression(scope, locals, assign, inputs);
              return interceptorFn(value, scope, locals);
            } : function oneTimeInterceptedExpression(scope, locals, assign, inputs) {
              var value = parsedExpression(scope, locals, assign, inputs);
              var result = interceptorFn(value, scope, locals);
              return isDefined(value) ? result : value;
            };
            if (parsedExpression.$$watchDelegate && parsedExpression.$$watchDelegate !== inputsWatchDelegate) {
              fn.$$watchDelegate = parsedExpression.$$watchDelegate;
            } else if (!interceptorFn.$stateful) {
              fn.$$watchDelegate = inputsWatchDelegate;
              useInputs = !parsedExpression.inputs;
              fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [parsedExpression];
            }
            return fn;
          }
        }];
      }
      function $QProvider() {
        this.$get = ['$rootScope', '$exceptionHandler', function($rootScope, $exceptionHandler) {
          return qFactory(function(callback) {
            $rootScope.$evalAsync(callback);
          }, $exceptionHandler);
        }];
      }
      function $$QProvider() {
        this.$get = ['$browser', '$exceptionHandler', function($browser, $exceptionHandler) {
          return qFactory(function(callback) {
            $browser.defer(callback);
          }, $exceptionHandler);
        }];
      }
      function qFactory(nextTick, exceptionHandler) {
        var $qMinErr = minErr('$q', TypeError);
        function callOnce(self, resolveFn, rejectFn) {
          var called = false;
          function wrap(fn) {
            return function(value) {
              if (called)
                return;
              called = true;
              fn.call(self, value);
            };
          }
          return [wrap(resolveFn), wrap(rejectFn)];
        }
        var defer = function() {
          return new Deferred();
        };
        function Promise() {
          this.$$state = {status: 0};
        }
        extend(Promise.prototype, {
          then: function(onFulfilled, onRejected, progressBack) {
            if (isUndefined(onFulfilled) && isUndefined(onRejected) && isUndefined(progressBack)) {
              return this;
            }
            var result = new Deferred();
            this.$$state.pending = this.$$state.pending || [];
            this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]);
            if (this.$$state.status > 0)
              scheduleProcessQueue(this.$$state);
            return result.promise;
          },
          "catch": function(callback) {
            return this.then(null, callback);
          },
          "finally": function(callback, progressBack) {
            return this.then(function(value) {
              return handleCallback(value, true, callback);
            }, function(error) {
              return handleCallback(error, false, callback);
            }, progressBack);
          }
        });
        function simpleBind(context, fn) {
          return function(value) {
            fn.call(context, value);
          };
        }
        function processQueue(state) {
          var fn,
              deferred,
              pending;
          pending = state.pending;
          state.processScheduled = false;
          state.pending = undefined;
          for (var i = 0,
              ii = pending.length; i < ii; ++i) {
            deferred = pending[i][0];
            fn = pending[i][state.status];
            try {
              if (isFunction(fn)) {
                deferred.resolve(fn(state.value));
              } else if (state.status === 1) {
                deferred.resolve(state.value);
              } else {
                deferred.reject(state.value);
              }
            } catch (e) {
              deferred.reject(e);
              exceptionHandler(e);
            }
          }
        }
        function scheduleProcessQueue(state) {
          if (state.processScheduled || !state.pending)
            return;
          state.processScheduled = true;
          nextTick(function() {
            processQueue(state);
          });
        }
        function Deferred() {
          this.promise = new Promise();
          this.resolve = simpleBind(this, this.resolve);
          this.reject = simpleBind(this, this.reject);
          this.notify = simpleBind(this, this.notify);
        }
        extend(Deferred.prototype, {
          resolve: function(val) {
            if (this.promise.$$state.status)
              return;
            if (val === this.promise) {
              this.$$reject($qMinErr('qcycle', "Expected promise to be resolved with value other than itself '{0}'", val));
            } else {
              this.$$resolve(val);
            }
          },
          $$resolve: function(val) {
            var then,
                fns;
            fns = callOnce(this, this.$$resolve, this.$$reject);
            try {
              if ((isObject(val) || isFunction(val)))
                then = val && val.then;
              if (isFunction(then)) {
                this.promise.$$state.status = -1;
                then.call(val, fns[0], fns[1], this.notify);
              } else {
                this.promise.$$state.value = val;
                this.promise.$$state.status = 1;
                scheduleProcessQueue(this.promise.$$state);
              }
            } catch (e) {
              fns[1](e);
              exceptionHandler(e);
            }
          },
          reject: function(reason) {
            if (this.promise.$$state.status)
              return;
            this.$$reject(reason);
          },
          $$reject: function(reason) {
            this.promise.$$state.value = reason;
            this.promise.$$state.status = 2;
            scheduleProcessQueue(this.promise.$$state);
          },
          notify: function(progress) {
            var callbacks = this.promise.$$state.pending;
            if ((this.promise.$$state.status <= 0) && callbacks && callbacks.length) {
              nextTick(function() {
                var callback,
                    result;
                for (var i = 0,
                    ii = callbacks.length; i < ii; i++) {
                  result = callbacks[i][0];
                  callback = callbacks[i][3];
                  try {
                    result.notify(isFunction(callback) ? callback(progress) : progress);
                  } catch (e) {
                    exceptionHandler(e);
                  }
                }
              });
            }
          }
        });
        var reject = function(reason) {
          var result = new Deferred();
          result.reject(reason);
          return result.promise;
        };
        var makePromise = function makePromise(value, resolved) {
          var result = new Deferred();
          if (resolved) {
            result.resolve(value);
          } else {
            result.reject(value);
          }
          return result.promise;
        };
        var handleCallback = function handleCallback(value, isResolved, callback) {
          var callbackOutput = null;
          try {
            if (isFunction(callback))
              callbackOutput = callback();
          } catch (e) {
            return makePromise(e, false);
          }
          if (isPromiseLike(callbackOutput)) {
            return callbackOutput.then(function() {
              return makePromise(value, isResolved);
            }, function(error) {
              return makePromise(error, false);
            });
          } else {
            return makePromise(value, isResolved);
          }
        };
        var when = function(value, callback, errback, progressBack) {
          var result = new Deferred();
          result.resolve(value);
          return result.promise.then(callback, errback, progressBack);
        };
        var resolve = when;
        function all(promises) {
          var deferred = new Deferred(),
              counter = 0,
              results = isArray(promises) ? [] : {};
          forEach(promises, function(promise, key) {
            counter++;
            when(promise).then(function(value) {
              if (results.hasOwnProperty(key))
                return;
              results[key] = value;
              if (!(--counter))
                deferred.resolve(results);
            }, function(reason) {
              if (results.hasOwnProperty(key))
                return;
              deferred.reject(reason);
            });
          });
          if (counter === 0) {
            deferred.resolve(results);
          }
          return deferred.promise;
        }
        var $Q = function Q(resolver) {
          if (!isFunction(resolver)) {
            throw $qMinErr('norslvr', "Expected resolverFn, got '{0}'", resolver);
          }
          if (!(this instanceof Q)) {
            return new Q(resolver);
          }
          var deferred = new Deferred();
          function resolveFn(value) {
            deferred.resolve(value);
          }
          function rejectFn(reason) {
            deferred.reject(reason);
          }
          resolver(resolveFn, rejectFn);
          return deferred.promise;
        };
        $Q.defer = defer;
        $Q.reject = reject;
        $Q.when = when;
        $Q.resolve = resolve;
        $Q.all = all;
        return $Q;
      }
      function $$RAFProvider() {
        this.$get = ['$window', '$timeout', function($window, $timeout) {
          var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame;
          var cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame;
          var rafSupported = !!requestAnimationFrame;
          var raf = rafSupported ? function(fn) {
            var id = requestAnimationFrame(fn);
            return function() {
              cancelAnimationFrame(id);
            };
          } : function(fn) {
            var timer = $timeout(fn, 16.66, false);
            return function() {
              $timeout.cancel(timer);
            };
          };
          raf.supported = rafSupported;
          return raf;
        }];
      }
      function $RootScopeProvider() {
        var TTL = 10;
        var $rootScopeMinErr = minErr('$rootScope');
        var lastDirtyWatch = null;
        var applyAsyncId = null;
        this.digestTtl = function(value) {
          if (arguments.length) {
            TTL = value;
          }
          return TTL;
        };
        function createChildScopeClass(parent) {
          function ChildScope() {
            this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null;
            this.$$listeners = {};
            this.$$listenerCount = {};
            this.$$watchersCount = 0;
            this.$id = nextUid();
            this.$$ChildScope = null;
          }
          ChildScope.prototype = parent;
          return ChildScope;
        }
        this.$get = ['$injector', '$exceptionHandler', '$parse', '$browser', function($injector, $exceptionHandler, $parse, $browser) {
          function destroyChildScope($event) {
            $event.currentScope.$$destroyed = true;
          }
          function cleanUpScope($scope) {
            if (msie === 9) {
              $scope.$$childHead && cleanUpScope($scope.$$childHead);
              $scope.$$nextSibling && cleanUpScope($scope.$$nextSibling);
            }
            $scope.$parent = $scope.$$nextSibling = $scope.$$prevSibling = $scope.$$childHead = $scope.$$childTail = $scope.$root = $scope.$$watchers = null;
          }
          function Scope() {
            this.$id = nextUid();
            this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
            this.$root = this;
            this.$$destroyed = false;
            this.$$listeners = {};
            this.$$listenerCount = {};
            this.$$watchersCount = 0;
            this.$$isolateBindings = null;
          }
          Scope.prototype = {
            constructor: Scope,
            $new: function(isolate, parent) {
              var child;
              parent = parent || this;
              if (isolate) {
                child = new Scope();
                child.$root = this.$root;
              } else {
                if (!this.$$ChildScope) {
                  this.$$ChildScope = createChildScopeClass(this);
                }
                child = new this.$$ChildScope();
              }
              child.$parent = parent;
              child.$$prevSibling = parent.$$childTail;
              if (parent.$$childHead) {
                parent.$$childTail.$$nextSibling = child;
                parent.$$childTail = child;
              } else {
                parent.$$childHead = parent.$$childTail = child;
              }
              if (isolate || parent != this)
                child.$on('$destroy', destroyChildScope);
              return child;
            },
            $watch: function(watchExp, listener, objectEquality, prettyPrintExpression) {
              var get = $parse(watchExp);
              if (get.$$watchDelegate) {
                return get.$$watchDelegate(this, listener, objectEquality, get, watchExp);
              }
              var scope = this,
                  array = scope.$$watchers,
                  watcher = {
                    fn: listener,
                    last: initWatchVal,
                    get: get,
                    exp: prettyPrintExpression || watchExp,
                    eq: !!objectEquality
                  };
              lastDirtyWatch = null;
              if (!isFunction(listener)) {
                watcher.fn = noop;
              }
              if (!array) {
                array = scope.$$watchers = [];
              }
              array.unshift(watcher);
              incrementWatchersCount(this, 1);
              return function deregisterWatch() {
                if (arrayRemove(array, watcher) >= 0) {
                  incrementWatchersCount(scope, -1);
                }
                lastDirtyWatch = null;
              };
            },
            $watchGroup: function(watchExpressions, listener) {
              var oldValues = new Array(watchExpressions.length);
              var newValues = new Array(watchExpressions.length);
              var deregisterFns = [];
              var self = this;
              var changeReactionScheduled = false;
              var firstRun = true;
              if (!watchExpressions.length) {
                var shouldCall = true;
                self.$evalAsync(function() {
                  if (shouldCall)
                    listener(newValues, newValues, self);
                });
                return function deregisterWatchGroup() {
                  shouldCall = false;
                };
              }
              if (watchExpressions.length === 1) {
                return this.$watch(watchExpressions[0], function watchGroupAction(value, oldValue, scope) {
                  newValues[0] = value;
                  oldValues[0] = oldValue;
                  listener(newValues, (value === oldValue) ? newValues : oldValues, scope);
                });
              }
              forEach(watchExpressions, function(expr, i) {
                var unwatchFn = self.$watch(expr, function watchGroupSubAction(value, oldValue) {
                  newValues[i] = value;
                  oldValues[i] = oldValue;
                  if (!changeReactionScheduled) {
                    changeReactionScheduled = true;
                    self.$evalAsync(watchGroupAction);
                  }
                });
                deregisterFns.push(unwatchFn);
              });
              function watchGroupAction() {
                changeReactionScheduled = false;
                if (firstRun) {
                  firstRun = false;
                  listener(newValues, newValues, self);
                } else {
                  listener(newValues, oldValues, self);
                }
              }
              return function deregisterWatchGroup() {
                while (deregisterFns.length) {
                  deregisterFns.shift()();
                }
              };
            },
            $watchCollection: function(obj, listener) {
              $watchCollectionInterceptor.$stateful = true;
              var self = this;
              var newValue;
              var oldValue;
              var veryOldValue;
              var trackVeryOldValue = (listener.length > 1);
              var changeDetected = 0;
              var changeDetector = $parse(obj, $watchCollectionInterceptor);
              var internalArray = [];
              var internalObject = {};
              var initRun = true;
              var oldLength = 0;
              function $watchCollectionInterceptor(_value) {
                newValue = _value;
                var newLength,
                    key,
                    bothNaN,
                    newItem,
                    oldItem;
                if (isUndefined(newValue))
                  return;
                if (!isObject(newValue)) {
                  if (oldValue !== newValue) {
                    oldValue = newValue;
                    changeDetected++;
                  }
                } else if (isArrayLike(newValue)) {
                  if (oldValue !== internalArray) {
                    oldValue = internalArray;
                    oldLength = oldValue.length = 0;
                    changeDetected++;
                  }
                  newLength = newValue.length;
                  if (oldLength !== newLength) {
                    changeDetected++;
                    oldValue.length = oldLength = newLength;
                  }
                  for (var i = 0; i < newLength; i++) {
                    oldItem = oldValue[i];
                    newItem = newValue[i];
                    bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
                    if (!bothNaN && (oldItem !== newItem)) {
                      changeDetected++;
                      oldValue[i] = newItem;
                    }
                  }
                } else {
                  if (oldValue !== internalObject) {
                    oldValue = internalObject = {};
                    oldLength = 0;
                    changeDetected++;
                  }
                  newLength = 0;
                  for (key in newValue) {
                    if (hasOwnProperty.call(newValue, key)) {
                      newLength++;
                      newItem = newValue[key];
                      oldItem = oldValue[key];
                      if (key in oldValue) {
                        bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
                        if (!bothNaN && (oldItem !== newItem)) {
                          changeDetected++;
                          oldValue[key] = newItem;
                        }
                      } else {
                        oldLength++;
                        oldValue[key] = newItem;
                        changeDetected++;
                      }
                    }
                  }
                  if (oldLength > newLength) {
                    changeDetected++;
                    for (key in oldValue) {
                      if (!hasOwnProperty.call(newValue, key)) {
                        oldLength--;
                        delete oldValue[key];
                      }
                    }
                  }
                }
                return changeDetected;
              }
              function $watchCollectionAction() {
                if (initRun) {
                  initRun = false;
                  listener(newValue, newValue, self);
                } else {
                  listener(newValue, veryOldValue, self);
                }
                if (trackVeryOldValue) {
                  if (!isObject(newValue)) {
                    veryOldValue = newValue;
                  } else if (isArrayLike(newValue)) {
                    veryOldValue = new Array(newValue.length);
                    for (var i = 0; i < newValue.length; i++) {
                      veryOldValue[i] = newValue[i];
                    }
                  } else {
                    veryOldValue = {};
                    for (var key in newValue) {
                      if (hasOwnProperty.call(newValue, key)) {
                        veryOldValue[key] = newValue[key];
                      }
                    }
                  }
                }
              }
              return this.$watch(changeDetector, $watchCollectionAction);
            },
            $digest: function() {
              var watch,
                  value,
                  last,
                  watchers,
                  length,
                  dirty,
                  ttl = TTL,
                  next,
                  current,
                  target = this,
                  watchLog = [],
                  logIdx,
                  logMsg,
                  asyncTask;
              beginPhase('$digest');
              $browser.$$checkUrlChange();
              if (this === $rootScope && applyAsyncId !== null) {
                $browser.defer.cancel(applyAsyncId);
                flushApplyAsync();
              }
              lastDirtyWatch = null;
              do {
                dirty = false;
                current = target;
                while (asyncQueue.length) {
                  try {
                    asyncTask = asyncQueue.shift();
                    asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                  lastDirtyWatch = null;
                }
                traverseScopesLoop: do {
                  if ((watchers = current.$$watchers)) {
                    length = watchers.length;
                    while (length--) {
                      try {
                        watch = watchers[length];
                        if (watch) {
                          if ((value = watch.get(current)) !== (last = watch.last) && !(watch.eq ? equals(value, last) : (typeof value === 'number' && typeof last === 'number' && isNaN(value) && isNaN(last)))) {
                            dirty = true;
                            lastDirtyWatch = watch;
                            watch.last = watch.eq ? copy(value, null) : value;
                            watch.fn(value, ((last === initWatchVal) ? value : last), current);
                            if (ttl < 5) {
                              logIdx = 4 - ttl;
                              if (!watchLog[logIdx])
                                watchLog[logIdx] = [];
                              watchLog[logIdx].push({
                                msg: isFunction(watch.exp) ? 'fn: ' + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                newVal: value,
                                oldVal: last
                              });
                            }
                          } else if (watch === lastDirtyWatch) {
                            dirty = false;
                            break traverseScopesLoop;
                          }
                        }
                      } catch (e) {
                        $exceptionHandler(e);
                      }
                    }
                  }
                  if (!(next = ((current.$$watchersCount && current.$$childHead) || (current !== target && current.$$nextSibling)))) {
                    while (current !== target && !(next = current.$$nextSibling)) {
                      current = current.$parent;
                    }
                  }
                } while ((current = next));
                if ((dirty || asyncQueue.length) && !(ttl--)) {
                  clearPhase();
                  throw $rootScopeMinErr('infdig', '{0} $digest() iterations reached. Aborting!\n' + 'Watchers fired in the last 5 iterations: {1}', TTL, watchLog);
                }
              } while (dirty || asyncQueue.length);
              clearPhase();
              while (postDigestQueue.length) {
                try {
                  postDigestQueue.shift()();
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
            },
            $destroy: function() {
              if (this.$$destroyed)
                return;
              var parent = this.$parent;
              this.$broadcast('$destroy');
              this.$$destroyed = true;
              if (this === $rootScope) {
                $browser.$$applicationDestroyed();
              }
              incrementWatchersCount(this, -this.$$watchersCount);
              for (var eventName in this.$$listenerCount) {
                decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
              }
              if (parent && parent.$$childHead == this)
                parent.$$childHead = this.$$nextSibling;
              if (parent && parent.$$childTail == this)
                parent.$$childTail = this.$$prevSibling;
              if (this.$$prevSibling)
                this.$$prevSibling.$$nextSibling = this.$$nextSibling;
              if (this.$$nextSibling)
                this.$$nextSibling.$$prevSibling = this.$$prevSibling;
              this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;
              this.$on = this.$watch = this.$watchGroup = function() {
                return noop;
              };
              this.$$listeners = {};
              this.$$nextSibling = null;
              cleanUpScope(this);
            },
            $eval: function(expr, locals) {
              return $parse(expr)(this, locals);
            },
            $evalAsync: function(expr, locals) {
              if (!$rootScope.$$phase && !asyncQueue.length) {
                $browser.defer(function() {
                  if (asyncQueue.length) {
                    $rootScope.$digest();
                  }
                });
              }
              asyncQueue.push({
                scope: this,
                expression: expr,
                locals: locals
              });
            },
            $$postDigest: function(fn) {
              postDigestQueue.push(fn);
            },
            $apply: function(expr) {
              try {
                beginPhase('$apply');
                try {
                  return this.$eval(expr);
                } finally {
                  clearPhase();
                }
              } catch (e) {
                $exceptionHandler(e);
              } finally {
                try {
                  $rootScope.$digest();
                } catch (e) {
                  $exceptionHandler(e);
                  throw e;
                }
              }
            },
            $applyAsync: function(expr) {
              var scope = this;
              expr && applyAsyncQueue.push($applyAsyncExpression);
              scheduleApplyAsync();
              function $applyAsyncExpression() {
                scope.$eval(expr);
              }
            },
            $on: function(name, listener) {
              var namedListeners = this.$$listeners[name];
              if (!namedListeners) {
                this.$$listeners[name] = namedListeners = [];
              }
              namedListeners.push(listener);
              var current = this;
              do {
                if (!current.$$listenerCount[name]) {
                  current.$$listenerCount[name] = 0;
                }
                current.$$listenerCount[name]++;
              } while ((current = current.$parent));
              var self = this;
              return function() {
                var indexOfListener = namedListeners.indexOf(listener);
                if (indexOfListener !== -1) {
                  namedListeners[indexOfListener] = null;
                  decrementListenerCount(self, 1, name);
                }
              };
            },
            $emit: function(name, args) {
              var empty = [],
                  namedListeners,
                  scope = this,
                  stopPropagation = false,
                  event = {
                    name: name,
                    targetScope: scope,
                    stopPropagation: function() {
                      stopPropagation = true;
                    },
                    preventDefault: function() {
                      event.defaultPrevented = true;
                    },
                    defaultPrevented: false
                  },
                  listenerArgs = concat([event], arguments, 1),
                  i,
                  length;
              do {
                namedListeners = scope.$$listeners[name] || empty;
                event.currentScope = scope;
                for (i = 0, length = namedListeners.length; i < length; i++) {
                  if (!namedListeners[i]) {
                    namedListeners.splice(i, 1);
                    i--;
                    length--;
                    continue;
                  }
                  try {
                    namedListeners[i].apply(null, listenerArgs);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (stopPropagation) {
                  event.currentScope = null;
                  return event;
                }
                scope = scope.$parent;
              } while (scope);
              event.currentScope = null;
              return event;
            },
            $broadcast: function(name, args) {
              var target = this,
                  current = target,
                  next = target,
                  event = {
                    name: name,
                    targetScope: target,
                    preventDefault: function() {
                      event.defaultPrevented = true;
                    },
                    defaultPrevented: false
                  };
              if (!target.$$listenerCount[name])
                return event;
              var listenerArgs = concat([event], arguments, 1),
                  listeners,
                  i,
                  length;
              while ((current = next)) {
                event.currentScope = current;
                listeners = current.$$listeners[name] || [];
                for (i = 0, length = listeners.length; i < length; i++) {
                  if (!listeners[i]) {
                    listeners.splice(i, 1);
                    i--;
                    length--;
                    continue;
                  }
                  try {
                    listeners[i].apply(null, listenerArgs);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (!(next = ((current.$$listenerCount[name] && current.$$childHead) || (current !== target && current.$$nextSibling)))) {
                  while (current !== target && !(next = current.$$nextSibling)) {
                    current = current.$parent;
                  }
                }
              }
              event.currentScope = null;
              return event;
            }
          };
          var $rootScope = new Scope();
          var asyncQueue = $rootScope.$$asyncQueue = [];
          var postDigestQueue = $rootScope.$$postDigestQueue = [];
          var applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];
          return $rootScope;
          function beginPhase(phase) {
            if ($rootScope.$$phase) {
              throw $rootScopeMinErr('inprog', '{0} already in progress', $rootScope.$$phase);
            }
            $rootScope.$$phase = phase;
          }
          function clearPhase() {
            $rootScope.$$phase = null;
          }
          function incrementWatchersCount(current, count) {
            do {
              current.$$watchersCount += count;
            } while ((current = current.$parent));
          }
          function decrementListenerCount(current, count, name) {
            do {
              current.$$listenerCount[name] -= count;
              if (current.$$listenerCount[name] === 0) {
                delete current.$$listenerCount[name];
              }
            } while ((current = current.$parent));
          }
          function initWatchVal() {}
          function flushApplyAsync() {
            while (applyAsyncQueue.length) {
              try {
                applyAsyncQueue.shift()();
              } catch (e) {
                $exceptionHandler(e);
              }
            }
            applyAsyncId = null;
          }
          function scheduleApplyAsync() {
            if (applyAsyncId === null) {
              applyAsyncId = $browser.defer(function() {
                $rootScope.$apply(flushApplyAsync);
              });
            }
          }
        }];
      }
      function $$SanitizeUriProvider() {
        var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/,
            imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
        this.aHrefSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            aHrefSanitizationWhitelist = regexp;
            return this;
          }
          return aHrefSanitizationWhitelist;
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            imgSrcSanitizationWhitelist = regexp;
            return this;
          }
          return imgSrcSanitizationWhitelist;
        };
        this.$get = function() {
          return function sanitizeUri(uri, isImage) {
            var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
            var normalizedVal;
            normalizedVal = urlResolve(uri).href;
            if (normalizedVal !== '' && !normalizedVal.match(regex)) {
              return 'unsafe:' + normalizedVal;
            }
            return uri;
          };
        };
      }
      var $sceMinErr = minErr('$sce');
      var SCE_CONTEXTS = {
        HTML: 'html',
        CSS: 'css',
        URL: 'url',
        RESOURCE_URL: 'resourceUrl',
        JS: 'js'
      };
      function adjustMatcher(matcher) {
        if (matcher === 'self') {
          return matcher;
        } else if (isString(matcher)) {
          if (matcher.indexOf('***') > -1) {
            throw $sceMinErr('iwcard', 'Illegal sequence *** in string matcher.  String: {0}', matcher);
          }
          matcher = escapeForRegexp(matcher).replace('\\*\\*', '.*').replace('\\*', '[^:/.?&;]*');
          return new RegExp('^' + matcher + '$');
        } else if (isRegExp(matcher)) {
          return new RegExp('^' + matcher.source + '$');
        } else {
          throw $sceMinErr('imatcher', 'Matchers may only be "self", string patterns or RegExp objects');
        }
      }
      function adjustMatchers(matchers) {
        var adjustedMatchers = [];
        if (isDefined(matchers)) {
          forEach(matchers, function(matcher) {
            adjustedMatchers.push(adjustMatcher(matcher));
          });
        }
        return adjustedMatchers;
      }
      function $SceDelegateProvider() {
        this.SCE_CONTEXTS = SCE_CONTEXTS;
        var resourceUrlWhitelist = ['self'],
            resourceUrlBlacklist = [];
        this.resourceUrlWhitelist = function(value) {
          if (arguments.length) {
            resourceUrlWhitelist = adjustMatchers(value);
          }
          return resourceUrlWhitelist;
        };
        this.resourceUrlBlacklist = function(value) {
          if (arguments.length) {
            resourceUrlBlacklist = adjustMatchers(value);
          }
          return resourceUrlBlacklist;
        };
        this.$get = ['$injector', function($injector) {
          var htmlSanitizer = function htmlSanitizer(html) {
            throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
          };
          if ($injector.has('$sanitize')) {
            htmlSanitizer = $injector.get('$sanitize');
          }
          function matchUrl(matcher, parsedUrl) {
            if (matcher === 'self') {
              return urlIsSameOrigin(parsedUrl);
            } else {
              return !!matcher.exec(parsedUrl.href);
            }
          }
          function isResourceUrlAllowedByPolicy(url) {
            var parsedUrl = urlResolve(url.toString());
            var i,
                n,
                allowed = false;
            for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
              if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                allowed = true;
                break;
              }
            }
            if (allowed) {
              for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
                if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                  allowed = false;
                  break;
                }
              }
            }
            return allowed;
          }
          function generateHolderType(Base) {
            var holderType = function TrustedValueHolderType(trustedValue) {
              this.$$unwrapTrustedValue = function() {
                return trustedValue;
              };
            };
            if (Base) {
              holderType.prototype = new Base();
            }
            holderType.prototype.valueOf = function sceValueOf() {
              return this.$$unwrapTrustedValue();
            };
            holderType.prototype.toString = function sceToString() {
              return this.$$unwrapTrustedValue().toString();
            };
            return holderType;
          }
          var trustedValueHolderBase = generateHolderType(),
              byType = {};
          byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);
          function trustAs(type, trustedValue) {
            var Constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
            if (!Constructor) {
              throw $sceMinErr('icontext', 'Attempted to trust a value in invalid context. Context: {0}; Value: {1}', type, trustedValue);
            }
            if (trustedValue === null || isUndefined(trustedValue) || trustedValue === '') {
              return trustedValue;
            }
            if (typeof trustedValue !== 'string') {
              throw $sceMinErr('itype', 'Attempted to trust a non-string value in a content requiring a string: Context: {0}', type);
            }
            return new Constructor(trustedValue);
          }
          function valueOf(maybeTrusted) {
            if (maybeTrusted instanceof trustedValueHolderBase) {
              return maybeTrusted.$$unwrapTrustedValue();
            } else {
              return maybeTrusted;
            }
          }
          function getTrusted(type, maybeTrusted) {
            if (maybeTrusted === null || isUndefined(maybeTrusted) || maybeTrusted === '') {
              return maybeTrusted;
            }
            var constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
            if (constructor && maybeTrusted instanceof constructor) {
              return maybeTrusted.$$unwrapTrustedValue();
            }
            if (type === SCE_CONTEXTS.RESOURCE_URL) {
              if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
                return maybeTrusted;
              } else {
                throw $sceMinErr('insecurl', 'Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}', maybeTrusted.toString());
              }
            } else if (type === SCE_CONTEXTS.HTML) {
              return htmlSanitizer(maybeTrusted);
            }
            throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
          }
          return {
            trustAs: trustAs,
            getTrusted: getTrusted,
            valueOf: valueOf
          };
        }];
      }
      function $SceProvider() {
        var enabled = true;
        this.enabled = function(value) {
          if (arguments.length) {
            enabled = !!value;
          }
          return enabled;
        };
        this.$get = ['$parse', '$sceDelegate', function($parse, $sceDelegate) {
          if (enabled && msie < 8) {
            throw $sceMinErr('iequirks', 'Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks ' + 'mode.  You can fix this by adding the text <!doctype html> to the top of your HTML ' + 'document.  See http://docs.angularjs.org/api/ng.$sce for more information.');
          }
          var sce = shallowCopy(SCE_CONTEXTS);
          sce.isEnabled = function() {
            return enabled;
          };
          sce.trustAs = $sceDelegate.trustAs;
          sce.getTrusted = $sceDelegate.getTrusted;
          sce.valueOf = $sceDelegate.valueOf;
          if (!enabled) {
            sce.trustAs = sce.getTrusted = function(type, value) {
              return value;
            };
            sce.valueOf = identity;
          }
          sce.parseAs = function sceParseAs(type, expr) {
            var parsed = $parse(expr);
            if (parsed.literal && parsed.constant) {
              return parsed;
            } else {
              return $parse(expr, function(value) {
                return sce.getTrusted(type, value);
              });
            }
          };
          var parse = sce.parseAs,
              getTrusted = sce.getTrusted,
              trustAs = sce.trustAs;
          forEach(SCE_CONTEXTS, function(enumValue, name) {
            var lName = lowercase(name);
            sce[camelCase("parse_as_" + lName)] = function(expr) {
              return parse(enumValue, expr);
            };
            sce[camelCase("get_trusted_" + lName)] = function(value) {
              return getTrusted(enumValue, value);
            };
            sce[camelCase("trust_as_" + lName)] = function(value) {
              return trustAs(enumValue, value);
            };
          });
          return sce;
        }];
      }
      function $SnifferProvider() {
        this.$get = ['$window', '$document', function($window, $document) {
          var eventSupport = {},
              android = toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]),
              boxee = /Boxee/i.test(($window.navigator || {}).userAgent),
              document = $document[0] || {},
              vendorPrefix,
              vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/,
              bodyStyle = document.body && document.body.style,
              transitions = false,
              animations = false,
              match;
          if (bodyStyle) {
            for (var prop in bodyStyle) {
              if (match = vendorRegex.exec(prop)) {
                vendorPrefix = match[0];
                vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
                break;
              }
            }
            if (!vendorPrefix) {
              vendorPrefix = ('WebkitOpacity' in bodyStyle) && 'webkit';
            }
            transitions = !!(('transition' in bodyStyle) || (vendorPrefix + 'Transition' in bodyStyle));
            animations = !!(('animation' in bodyStyle) || (vendorPrefix + 'Animation' in bodyStyle));
            if (android && (!transitions || !animations)) {
              transitions = isString(bodyStyle.webkitTransition);
              animations = isString(bodyStyle.webkitAnimation);
            }
          }
          return {
            history: !!($window.history && $window.history.pushState && !(android < 4) && !boxee),
            hasEvent: function(event) {
              if (event === 'input' && msie <= 11)
                return false;
              if (isUndefined(eventSupport[event])) {
                var divElm = document.createElement('div');
                eventSupport[event] = 'on' + event in divElm;
              }
              return eventSupport[event];
            },
            csp: csp(),
            vendorPrefix: vendorPrefix,
            transitions: transitions,
            animations: animations,
            android: android
          };
        }];
      }
      var $compileMinErr = minErr('$compile');
      function $TemplateRequestProvider() {
        this.$get = ['$templateCache', '$http', '$q', '$sce', function($templateCache, $http, $q, $sce) {
          function handleRequestFn(tpl, ignoreRequestError) {
            handleRequestFn.totalPendingRequests++;
            if (!isString(tpl) || !$templateCache.get(tpl)) {
              tpl = $sce.getTrustedResourceUrl(tpl);
            }
            var transformResponse = $http.defaults && $http.defaults.transformResponse;
            if (isArray(transformResponse)) {
              transformResponse = transformResponse.filter(function(transformer) {
                return transformer !== defaultHttpResponseTransform;
              });
            } else if (transformResponse === defaultHttpResponseTransform) {
              transformResponse = null;
            }
            var httpOptions = {
              cache: $templateCache,
              transformResponse: transformResponse
            };
            return $http.get(tpl, httpOptions)['finally'](function() {
              handleRequestFn.totalPendingRequests--;
            }).then(function(response) {
              $templateCache.put(tpl, response.data);
              return response.data;
            }, handleError);
            function handleError(resp) {
              if (!ignoreRequestError) {
                throw $compileMinErr('tpload', 'Failed to load template: {0} (HTTP status: {1} {2})', tpl, resp.status, resp.statusText);
              }
              return $q.reject(resp);
            }
          }
          handleRequestFn.totalPendingRequests = 0;
          return handleRequestFn;
        }];
      }
      function $$TestabilityProvider() {
        this.$get = ['$rootScope', '$browser', '$location', function($rootScope, $browser, $location) {
          var testability = {};
          testability.findBindings = function(element, expression, opt_exactMatch) {
            var bindings = element.getElementsByClassName('ng-binding');
            var matches = [];
            forEach(bindings, function(binding) {
              var dataBinding = angular.element(binding).data('$binding');
              if (dataBinding) {
                forEach(dataBinding, function(bindingName) {
                  if (opt_exactMatch) {
                    var matcher = new RegExp('(^|\\s)' + escapeForRegexp(expression) + '(\\s|\\||$)');
                    if (matcher.test(bindingName)) {
                      matches.push(binding);
                    }
                  } else {
                    if (bindingName.indexOf(expression) != -1) {
                      matches.push(binding);
                    }
                  }
                });
              }
            });
            return matches;
          };
          testability.findModels = function(element, expression, opt_exactMatch) {
            var prefixes = ['ng-', 'data-ng-', 'ng\\:'];
            for (var p = 0; p < prefixes.length; ++p) {
              var attributeEquals = opt_exactMatch ? '=' : '*=';
              var selector = '[' + prefixes[p] + 'model' + attributeEquals + '"' + expression + '"]';
              var elements = element.querySelectorAll(selector);
              if (elements.length) {
                return elements;
              }
            }
          };
          testability.getLocation = function() {
            return $location.url();
          };
          testability.setLocation = function(url) {
            if (url !== $location.url()) {
              $location.url(url);
              $rootScope.$digest();
            }
          };
          testability.whenStable = function(callback) {
            $browser.notifyWhenNoOutstandingRequests(callback);
          };
          return testability;
        }];
      }
      function $TimeoutProvider() {
        this.$get = ['$rootScope', '$browser', '$q', '$$q', '$exceptionHandler', function($rootScope, $browser, $q, $$q, $exceptionHandler) {
          var deferreds = {};
          function timeout(fn, delay, invokeApply) {
            if (!isFunction(fn)) {
              invokeApply = delay;
              delay = fn;
              fn = noop;
            }
            var args = sliceArgs(arguments, 3),
                skipApply = (isDefined(invokeApply) && !invokeApply),
                deferred = (skipApply ? $$q : $q).defer(),
                promise = deferred.promise,
                timeoutId;
            timeoutId = $browser.defer(function() {
              try {
                deferred.resolve(fn.apply(null, args));
              } catch (e) {
                deferred.reject(e);
                $exceptionHandler(e);
              } finally {
                delete deferreds[promise.$$timeoutId];
              }
              if (!skipApply)
                $rootScope.$apply();
            }, delay);
            promise.$$timeoutId = timeoutId;
            deferreds[timeoutId] = deferred;
            return promise;
          }
          timeout.cancel = function(promise) {
            if (promise && promise.$$timeoutId in deferreds) {
              deferreds[promise.$$timeoutId].reject('canceled');
              delete deferreds[promise.$$timeoutId];
              return $browser.defer.cancel(promise.$$timeoutId);
            }
            return false;
          };
          return timeout;
        }];
      }
      var urlParsingNode = document.createElement("a");
      var originUrl = urlResolve(window.location.href);
      function urlResolve(url) {
        var href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute('href', href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
        };
      }
      function urlIsSameOrigin(requestUrl) {
        var parsed = (isString(requestUrl)) ? urlResolve(requestUrl) : requestUrl;
        return (parsed.protocol === originUrl.protocol && parsed.host === originUrl.host);
      }
      function $WindowProvider() {
        this.$get = valueFn(window);
      }
      function $$CookieReader($document) {
        var rawDocument = $document[0] || {};
        var lastCookies = {};
        var lastCookieString = '';
        function safeDecodeURIComponent(str) {
          try {
            return decodeURIComponent(str);
          } catch (e) {
            return str;
          }
        }
        return function() {
          var cookieArray,
              cookie,
              i,
              index,
              name;
          var currentCookieString = rawDocument.cookie || '';
          if (currentCookieString !== lastCookieString) {
            lastCookieString = currentCookieString;
            cookieArray = lastCookieString.split('; ');
            lastCookies = {};
            for (i = 0; i < cookieArray.length; i++) {
              cookie = cookieArray[i];
              index = cookie.indexOf('=');
              if (index > 0) {
                name = safeDecodeURIComponent(cookie.substring(0, index));
                if (isUndefined(lastCookies[name])) {
                  lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));
                }
              }
            }
          }
          return lastCookies;
        };
      }
      $$CookieReader.$inject = ['$document'];
      function $$CookieReaderProvider() {
        this.$get = $$CookieReader;
      }
      $FilterProvider.$inject = ['$provide'];
      function $FilterProvider($provide) {
        var suffix = 'Filter';
        function register(name, factory) {
          if (isObject(name)) {
            var filters = {};
            forEach(name, function(filter, key) {
              filters[key] = register(key, filter);
            });
            return filters;
          } else {
            return $provide.factory(name + suffix, factory);
          }
        }
        this.register = register;
        this.$get = ['$injector', function($injector) {
          return function(name) {
            return $injector.get(name + suffix);
          };
        }];
        register('currency', currencyFilter);
        register('date', dateFilter);
        register('filter', filterFilter);
        register('json', jsonFilter);
        register('limitTo', limitToFilter);
        register('lowercase', lowercaseFilter);
        register('number', numberFilter);
        register('orderBy', orderByFilter);
        register('uppercase', uppercaseFilter);
      }
      function filterFilter() {
        return function(array, expression, comparator) {
          if (!isArrayLike(array)) {
            if (array == null) {
              return array;
            } else {
              throw minErr('filter')('notarray', 'Expected array but received: {0}', array);
            }
          }
          var expressionType = getTypeForFilter(expression);
          var predicateFn;
          var matchAgainstAnyProp;
          switch (expressionType) {
            case 'function':
              predicateFn = expression;
              break;
            case 'boolean':
            case 'null':
            case 'number':
            case 'string':
              matchAgainstAnyProp = true;
            case 'object':
              predicateFn = createPredicateFn(expression, comparator, matchAgainstAnyProp);
              break;
            default:
              return array;
          }
          return Array.prototype.filter.call(array, predicateFn);
        };
      }
      function createPredicateFn(expression, comparator, matchAgainstAnyProp) {
        var shouldMatchPrimitives = isObject(expression) && ('$' in expression);
        var predicateFn;
        if (comparator === true) {
          comparator = equals;
        } else if (!isFunction(comparator)) {
          comparator = function(actual, expected) {
            if (isUndefined(actual)) {
              return false;
            }
            if ((actual === null) || (expected === null)) {
              return actual === expected;
            }
            if (isObject(expected) || (isObject(actual) && !hasCustomToString(actual))) {
              return false;
            }
            actual = lowercase('' + actual);
            expected = lowercase('' + expected);
            return actual.indexOf(expected) !== -1;
          };
        }
        predicateFn = function(item) {
          if (shouldMatchPrimitives && !isObject(item)) {
            return deepCompare(item, expression.$, comparator, false);
          }
          return deepCompare(item, expression, comparator, matchAgainstAnyProp);
        };
        return predicateFn;
      }
      function deepCompare(actual, expected, comparator, matchAgainstAnyProp, dontMatchWholeObject) {
        var actualType = getTypeForFilter(actual);
        var expectedType = getTypeForFilter(expected);
        if ((expectedType === 'string') && (expected.charAt(0) === '!')) {
          return !deepCompare(actual, expected.substring(1), comparator, matchAgainstAnyProp);
        } else if (isArray(actual)) {
          return actual.some(function(item) {
            return deepCompare(item, expected, comparator, matchAgainstAnyProp);
          });
        }
        switch (actualType) {
          case 'object':
            var key;
            if (matchAgainstAnyProp) {
              for (key in actual) {
                if ((key.charAt(0) !== '$') && deepCompare(actual[key], expected, comparator, true)) {
                  return true;
                }
              }
              return dontMatchWholeObject ? false : deepCompare(actual, expected, comparator, false);
            } else if (expectedType === 'object') {
              for (key in expected) {
                var expectedVal = expected[key];
                if (isFunction(expectedVal) || isUndefined(expectedVal)) {
                  continue;
                }
                var matchAnyProperty = key === '$';
                var actualVal = matchAnyProperty ? actual : actual[key];
                if (!deepCompare(actualVal, expectedVal, comparator, matchAnyProperty, matchAnyProperty)) {
                  return false;
                }
              }
              return true;
            } else {
              return comparator(actual, expected);
            }
            break;
          case 'function':
            return false;
          default:
            return comparator(actual, expected);
        }
      }
      function getTypeForFilter(val) {
        return (val === null) ? 'null' : typeof val;
      }
      currencyFilter.$inject = ['$locale'];
      function currencyFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(amount, currencySymbol, fractionSize) {
          if (isUndefined(currencySymbol)) {
            currencySymbol = formats.CURRENCY_SYM;
          }
          if (isUndefined(fractionSize)) {
            fractionSize = formats.PATTERNS[1].maxFrac;
          }
          return (amount == null) ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(/\u00A4/g, currencySymbol);
        };
      }
      numberFilter.$inject = ['$locale'];
      function numberFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(number, fractionSize) {
          return (number == null) ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
        };
      }
      var DECIMAL_SEP = '.';
      function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
        if (isObject(number))
          return '';
        var isNegative = number < 0;
        number = Math.abs(number);
        var isInfinity = number === Infinity;
        if (!isInfinity && !isFinite(number))
          return '';
        var numStr = number + '',
            formatedText = '',
            hasExponent = false,
            parts = [];
        if (isInfinity)
          formatedText = '\u221e';
        if (!isInfinity && numStr.indexOf('e') !== -1) {
          var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);
          if (match && match[2] == '-' && match[3] > fractionSize + 1) {
            number = 0;
          } else {
            formatedText = numStr;
            hasExponent = true;
          }
        }
        if (!isInfinity && !hasExponent) {
          var fractionLen = (numStr.split(DECIMAL_SEP)[1] || '').length;
          if (isUndefined(fractionSize)) {
            fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac);
          }
          number = +(Math.round(+(number.toString() + 'e' + fractionSize)).toString() + 'e' + -fractionSize);
          var fraction = ('' + number).split(DECIMAL_SEP);
          var whole = fraction[0];
          fraction = fraction[1] || '';
          var i,
              pos = 0,
              lgroup = pattern.lgSize,
              group = pattern.gSize;
          if (whole.length >= (lgroup + group)) {
            pos = whole.length - lgroup;
            for (i = 0; i < pos; i++) {
              if ((pos - i) % group === 0 && i !== 0) {
                formatedText += groupSep;
              }
              formatedText += whole.charAt(i);
            }
          }
          for (i = pos; i < whole.length; i++) {
            if ((whole.length - i) % lgroup === 0 && i !== 0) {
              formatedText += groupSep;
            }
            formatedText += whole.charAt(i);
          }
          while (fraction.length < fractionSize) {
            fraction += '0';
          }
          if (fractionSize && fractionSize !== "0")
            formatedText += decimalSep + fraction.substr(0, fractionSize);
        } else {
          if (fractionSize > 0 && number < 1) {
            formatedText = number.toFixed(fractionSize);
            number = parseFloat(formatedText);
            formatedText = formatedText.replace(DECIMAL_SEP, decimalSep);
          }
        }
        if (number === 0) {
          isNegative = false;
        }
        parts.push(isNegative ? pattern.negPre : pattern.posPre, formatedText, isNegative ? pattern.negSuf : pattern.posSuf);
        return parts.join('');
      }
      function padNumber(num, digits, trim) {
        var neg = '';
        if (num < 0) {
          neg = '-';
          num = -num;
        }
        num = '' + num;
        while (num.length < digits)
          num = '0' + num;
        if (trim) {
          num = num.substr(num.length - digits);
        }
        return neg + num;
      }
      function dateGetter(name, size, offset, trim) {
        offset = offset || 0;
        return function(date) {
          var value = date['get' + name]();
          if (offset > 0 || value > -offset) {
            value += offset;
          }
          if (value === 0 && offset == -12)
            value = 12;
          return padNumber(value, size, trim);
        };
      }
      function dateStrGetter(name, shortForm) {
        return function(date, formats) {
          var value = date['get' + name]();
          var get = uppercase(shortForm ? ('SHORT' + name) : name);
          return formats[get][value];
        };
      }
      function timeZoneGetter(date, formats, offset) {
        var zone = -1 * offset;
        var paddedZone = (zone >= 0) ? "+" : "";
        paddedZone += padNumber(Math[zone > 0 ? 'floor' : 'ceil'](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
        return paddedZone;
      }
      function getFirstThursdayOfYear(year) {
        var dayOfWeekOnFirst = (new Date(year, 0, 1)).getDay();
        return new Date(year, 0, ((dayOfWeekOnFirst <= 4) ? 5 : 12) - dayOfWeekOnFirst);
      }
      function getThursdayThisWeek(datetime) {
        return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()));
      }
      function weekGetter(size) {
        return function(date) {
          var firstThurs = getFirstThursdayOfYear(date.getFullYear()),
              thisThurs = getThursdayThisWeek(date);
          var diff = +thisThurs - +firstThurs,
              result = 1 + Math.round(diff / 6.048e8);
          return padNumber(result, size);
        };
      }
      function ampmGetter(date, formats) {
        return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
      }
      function eraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
      }
      function longEraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
      }
      var DATE_FORMATS = {
        yyyy: dateGetter('FullYear', 4),
        yy: dateGetter('FullYear', 2, 0, true),
        y: dateGetter('FullYear', 1),
        MMMM: dateStrGetter('Month'),
        MMM: dateStrGetter('Month', true),
        MM: dateGetter('Month', 2, 1),
        M: dateGetter('Month', 1, 1),
        dd: dateGetter('Date', 2),
        d: dateGetter('Date', 1),
        HH: dateGetter('Hours', 2),
        H: dateGetter('Hours', 1),
        hh: dateGetter('Hours', 2, -12),
        h: dateGetter('Hours', 1, -12),
        mm: dateGetter('Minutes', 2),
        m: dateGetter('Minutes', 1),
        ss: dateGetter('Seconds', 2),
        s: dateGetter('Seconds', 1),
        sss: dateGetter('Milliseconds', 3),
        EEEE: dateStrGetter('Day'),
        EEE: dateStrGetter('Day', true),
        a: ampmGetter,
        Z: timeZoneGetter,
        ww: weekGetter(2),
        w: weekGetter(1),
        G: eraGetter,
        GG: eraGetter,
        GGG: eraGetter,
        GGGG: longEraGetter
      };
      var DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/,
          NUMBER_STRING = /^\-?\d+$/;
      dateFilter.$inject = ['$locale'];
      function dateFilter($locale) {
        var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        function jsonStringToDate(string) {
          var match;
          if (match = string.match(R_ISO8601_STR)) {
            var date = new Date(0),
                tzHour = 0,
                tzMin = 0,
                dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,
                timeSetter = match[8] ? date.setUTCHours : date.setHours;
            if (match[9]) {
              tzHour = toInt(match[9] + match[10]);
              tzMin = toInt(match[9] + match[11]);
            }
            dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
            var h = toInt(match[4] || 0) - tzHour;
            var m = toInt(match[5] || 0) - tzMin;
            var s = toInt(match[6] || 0);
            var ms = Math.round(parseFloat('0.' + (match[7] || 0)) * 1000);
            timeSetter.call(date, h, m, s, ms);
            return date;
          }
          return string;
        }
        return function(date, format, timezone) {
          var text = '',
              parts = [],
              fn,
              match;
          format = format || 'mediumDate';
          format = $locale.DATETIME_FORMATS[format] || format;
          if (isString(date)) {
            date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date);
          }
          if (isNumber(date)) {
            date = new Date(date);
          }
          if (!isDate(date) || !isFinite(date.getTime())) {
            return date;
          }
          while (format) {
            match = DATE_FORMATS_SPLIT.exec(format);
            if (match) {
              parts = concat(parts, match, 1);
              format = parts.pop();
            } else {
              parts.push(format);
              format = null;
            }
          }
          var dateTimezoneOffset = date.getTimezoneOffset();
          if (timezone) {
            dateTimezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());
            date = convertTimezoneToLocal(date, timezone, true);
          }
          forEach(parts, function(value) {
            fn = DATE_FORMATS[value];
            text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) : value.replace(/(^'|'$)/g, '').replace(/''/g, "'");
          });
          return text;
        };
      }
      function jsonFilter() {
        return function(object, spacing) {
          if (isUndefined(spacing)) {
            spacing = 2;
          }
          return toJson(object, spacing);
        };
      }
      var lowercaseFilter = valueFn(lowercase);
      var uppercaseFilter = valueFn(uppercase);
      function limitToFilter() {
        return function(input, limit, begin) {
          if (Math.abs(Number(limit)) === Infinity) {
            limit = Number(limit);
          } else {
            limit = toInt(limit);
          }
          if (isNaN(limit))
            return input;
          if (isNumber(input))
            input = input.toString();
          if (!isArray(input) && !isString(input))
            return input;
          begin = (!begin || isNaN(begin)) ? 0 : toInt(begin);
          begin = (begin < 0) ? Math.max(0, input.length + begin) : begin;
          if (limit >= 0) {
            return input.slice(begin, begin + limit);
          } else {
            if (begin === 0) {
              return input.slice(limit, input.length);
            } else {
              return input.slice(Math.max(0, begin + limit), begin);
            }
          }
        };
      }
      orderByFilter.$inject = ['$parse'];
      function orderByFilter($parse) {
        return function(array, sortPredicate, reverseOrder) {
          if (!(isArrayLike(array)))
            return array;
          if (!isArray(sortPredicate)) {
            sortPredicate = [sortPredicate];
          }
          if (sortPredicate.length === 0) {
            sortPredicate = ['+'];
          }
          var predicates = processPredicates(sortPredicate, reverseOrder);
          predicates.push({
            get: function() {
              return {};
            },
            descending: reverseOrder ? -1 : 1
          });
          var compareValues = Array.prototype.map.call(array, getComparisonObject);
          compareValues.sort(doComparison);
          array = compareValues.map(function(item) {
            return item.value;
          });
          return array;
          function getComparisonObject(value, index) {
            return {
              value: value,
              predicateValues: predicates.map(function(predicate) {
                return getPredicateValue(predicate.get(value), index);
              })
            };
          }
          function doComparison(v1, v2) {
            var result = 0;
            for (var index = 0,
                length = predicates.length; index < length; ++index) {
              result = compare(v1.predicateValues[index], v2.predicateValues[index]) * predicates[index].descending;
              if (result)
                break;
            }
            return result;
          }
        };
        function processPredicates(sortPredicate, reverseOrder) {
          reverseOrder = reverseOrder ? -1 : 1;
          return sortPredicate.map(function(predicate) {
            var descending = 1,
                get = identity;
            if (isFunction(predicate)) {
              get = predicate;
            } else if (isString(predicate)) {
              if ((predicate.charAt(0) == '+' || predicate.charAt(0) == '-')) {
                descending = predicate.charAt(0) == '-' ? -1 : 1;
                predicate = predicate.substring(1);
              }
              if (predicate !== '') {
                get = $parse(predicate);
                if (get.constant) {
                  var key = get();
                  get = function(value) {
                    return value[key];
                  };
                }
              }
            }
            return {
              get: get,
              descending: descending * reverseOrder
            };
          });
        }
        function isPrimitive(value) {
          switch (typeof value) {
            case 'number':
            case 'boolean':
            case 'string':
              return true;
            default:
              return false;
          }
        }
        function objectValue(value, index) {
          if (typeof value.valueOf === 'function') {
            value = value.valueOf();
            if (isPrimitive(value))
              return value;
          }
          if (hasCustomToString(value)) {
            value = value.toString();
            if (isPrimitive(value))
              return value;
          }
          return index;
        }
        function getPredicateValue(value, index) {
          var type = typeof value;
          if (value === null) {
            type = 'string';
            value = 'null';
          } else if (type === 'string') {
            value = value.toLowerCase();
          } else if (type === 'object') {
            value = objectValue(value, index);
          }
          return {
            value: value,
            type: type
          };
        }
        function compare(v1, v2) {
          var result = 0;
          if (v1.type === v2.type) {
            if (v1.value !== v2.value) {
              result = v1.value < v2.value ? -1 : 1;
            }
          } else {
            result = v1.type < v2.type ? -1 : 1;
          }
          return result;
        }
      }
      function ngDirective(directive) {
        if (isFunction(directive)) {
          directive = {link: directive};
        }
        directive.restrict = directive.restrict || 'AC';
        return valueFn(directive);
      }
      var htmlAnchorDirective = valueFn({
        restrict: 'E',
        compile: function(element, attr) {
          if (!attr.href && !attr.xlinkHref) {
            return function(scope, element) {
              if (element[0].nodeName.toLowerCase() !== 'a')
                return;
              var href = toString.call(element.prop('href')) === '[object SVGAnimatedString]' ? 'xlink:href' : 'href';
              element.on('click', function(event) {
                if (!element.attr(href)) {
                  event.preventDefault();
                }
              });
            };
          }
        }
      });
      var ngAttributeAliasDirectives = {};
      forEach(BOOLEAN_ATTR, function(propName, attrName) {
        if (propName == "multiple")
          return;
        function defaultLinkFn(scope, element, attr) {
          scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
            attr.$set(attrName, !!value);
          });
        }
        var normalized = directiveNormalize('ng-' + attrName);
        var linkFn = defaultLinkFn;
        if (propName === 'checked') {
          linkFn = function(scope, element, attr) {
            if (attr.ngModel !== attr[normalized]) {
              defaultLinkFn(scope, element, attr);
            }
          };
        }
        ngAttributeAliasDirectives[normalized] = function() {
          return {
            restrict: 'A',
            priority: 100,
            link: linkFn
          };
        };
      });
      forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
        ngAttributeAliasDirectives[ngAttr] = function() {
          return {
            priority: 100,
            link: function(scope, element, attr) {
              if (ngAttr === "ngPattern" && attr.ngPattern.charAt(0) == "/") {
                var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                if (match) {
                  attr.$set("ngPattern", new RegExp(match[1], match[2]));
                  return;
                }
              }
              scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
                attr.$set(ngAttr, value);
              });
            }
          };
        };
      });
      forEach(['src', 'srcset', 'href'], function(attrName) {
        var normalized = directiveNormalize('ng-' + attrName);
        ngAttributeAliasDirectives[normalized] = function() {
          return {
            priority: 99,
            link: function(scope, element, attr) {
              var propName = attrName,
                  name = attrName;
              if (attrName === 'href' && toString.call(element.prop('href')) === '[object SVGAnimatedString]') {
                name = 'xlinkHref';
                attr.$attr[name] = 'xlink:href';
                propName = null;
              }
              attr.$observe(normalized, function(value) {
                if (!value) {
                  if (attrName === 'href') {
                    attr.$set(name, null);
                  }
                  return;
                }
                attr.$set(name, value);
                if (msie && propName)
                  element.prop(propName, attr[name]);
              });
            }
          };
        };
      });
      var nullFormCtrl = {
        $addControl: noop,
        $$renameControl: nullFormRenameControl,
        $removeControl: noop,
        $setValidity: noop,
        $setDirty: noop,
        $setPristine: noop,
        $setSubmitted: noop
      },
          SUBMITTED_CLASS = 'ng-submitted';
      function nullFormRenameControl(control, name) {
        control.$name = name;
      }
      FormController.$inject = ['$element', '$attrs', '$scope', '$animate', '$interpolate'];
      function FormController(element, attrs, $scope, $animate, $interpolate) {
        var form = this,
            controls = [];
        form.$error = {};
        form.$$success = {};
        form.$pending = undefined;
        form.$name = $interpolate(attrs.name || attrs.ngForm || '')($scope);
        form.$dirty = false;
        form.$pristine = true;
        form.$valid = true;
        form.$invalid = false;
        form.$submitted = false;
        form.$$parentForm = nullFormCtrl;
        form.$rollbackViewValue = function() {
          forEach(controls, function(control) {
            control.$rollbackViewValue();
          });
        };
        form.$commitViewValue = function() {
          forEach(controls, function(control) {
            control.$commitViewValue();
          });
        };
        form.$addControl = function(control) {
          assertNotHasOwnProperty(control.$name, 'input');
          controls.push(control);
          if (control.$name) {
            form[control.$name] = control;
          }
          control.$$parentForm = form;
        };
        form.$$renameControl = function(control, newName) {
          var oldName = control.$name;
          if (form[oldName] === control) {
            delete form[oldName];
          }
          form[newName] = control;
          control.$name = newName;
        };
        form.$removeControl = function(control) {
          if (control.$name && form[control.$name] === control) {
            delete form[control.$name];
          }
          forEach(form.$pending, function(value, name) {
            form.$setValidity(name, null, control);
          });
          forEach(form.$error, function(value, name) {
            form.$setValidity(name, null, control);
          });
          forEach(form.$$success, function(value, name) {
            form.$setValidity(name, null, control);
          });
          arrayRemove(controls, control);
          control.$$parentForm = nullFormCtrl;
        };
        addSetValidityMethod({
          ctrl: this,
          $element: element,
          set: function(object, property, controller) {
            var list = object[property];
            if (!list) {
              object[property] = [controller];
            } else {
              var index = list.indexOf(controller);
              if (index === -1) {
                list.push(controller);
              }
            }
          },
          unset: function(object, property, controller) {
            var list = object[property];
            if (!list) {
              return;
            }
            arrayRemove(list, controller);
            if (list.length === 0) {
              delete object[property];
            }
          },
          $animate: $animate
        });
        form.$setDirty = function() {
          $animate.removeClass(element, PRISTINE_CLASS);
          $animate.addClass(element, DIRTY_CLASS);
          form.$dirty = true;
          form.$pristine = false;
          form.$$parentForm.$setDirty();
        };
        form.$setPristine = function() {
          $animate.setClass(element, PRISTINE_CLASS, DIRTY_CLASS + ' ' + SUBMITTED_CLASS);
          form.$dirty = false;
          form.$pristine = true;
          form.$submitted = false;
          forEach(controls, function(control) {
            control.$setPristine();
          });
        };
        form.$setUntouched = function() {
          forEach(controls, function(control) {
            control.$setUntouched();
          });
        };
        form.$setSubmitted = function() {
          $animate.addClass(element, SUBMITTED_CLASS);
          form.$submitted = true;
          form.$$parentForm.$setSubmitted();
        };
      }
      var formDirectiveFactory = function(isNgForm) {
        return ['$timeout', '$parse', function($timeout, $parse) {
          var formDirective = {
            name: 'form',
            restrict: isNgForm ? 'EAC' : 'E',
            require: ['form', '^^?form'],
            controller: FormController,
            compile: function ngFormCompile(formElement, attr) {
              formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
              var nameAttr = attr.name ? 'name' : (isNgForm && attr.ngForm ? 'ngForm' : false);
              return {pre: function ngFormPreLink(scope, formElement, attr, ctrls) {
                  var controller = ctrls[0];
                  if (!('action' in attr)) {
                    var handleFormSubmission = function(event) {
                      scope.$apply(function() {
                        controller.$commitViewValue();
                        controller.$setSubmitted();
                      });
                      event.preventDefault();
                    };
                    addEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                    formElement.on('$destroy', function() {
                      $timeout(function() {
                        removeEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                      }, 0, false);
                    });
                  }
                  var parentFormCtrl = ctrls[1] || controller.$$parentForm;
                  parentFormCtrl.$addControl(controller);
                  var setter = nameAttr ? getSetter(controller.$name) : noop;
                  if (nameAttr) {
                    setter(scope, controller);
                    attr.$observe(nameAttr, function(newValue) {
                      if (controller.$name === newValue)
                        return;
                      setter(scope, undefined);
                      controller.$$parentForm.$$renameControl(controller, newValue);
                      setter = getSetter(controller.$name);
                      setter(scope, controller);
                    });
                  }
                  formElement.on('$destroy', function() {
                    controller.$$parentForm.$removeControl(controller);
                    setter(scope, undefined);
                    extend(controller, nullFormCtrl);
                  });
                }};
            }
          };
          return formDirective;
          function getSetter(expression) {
            if (expression === '') {
              return $parse('this[""]').assign;
            }
            return $parse(expression).assign || noop;
          }
        }];
      };
      var formDirective = formDirectiveFactory();
      var ngFormDirective = formDirectiveFactory(true);
      var ISO_DATE_REGEXP = /\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/;
      var URL_REGEXP = /^[A-Za-z][A-Za-z\d.+-]*:\/*(?:\w+(?::\w+)?@)?[^\s/]+(?::\d+)?(?:\/[\w#!:.?+=&%@\-/]*)?$/;
      var EMAIL_REGEXP = /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i;
      var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/;
      var DATE_REGEXP = /^(\d{4})-(\d{2})-(\d{2})$/;
      var DATETIMELOCAL_REGEXP = /^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
      var WEEK_REGEXP = /^(\d{4})-W(\d\d)$/;
      var MONTH_REGEXP = /^(\d{4})-(\d\d)$/;
      var TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
      var inputType = {
        'text': textInputType,
        'date': createDateInputType('date', DATE_REGEXP, createDateParser(DATE_REGEXP, ['yyyy', 'MM', 'dd']), 'yyyy-MM-dd'),
        'datetime-local': createDateInputType('datetimelocal', DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, ['yyyy', 'MM', 'dd', 'HH', 'mm', 'ss', 'sss']), 'yyyy-MM-ddTHH:mm:ss.sss'),
        'time': createDateInputType('time', TIME_REGEXP, createDateParser(TIME_REGEXP, ['HH', 'mm', 'ss', 'sss']), 'HH:mm:ss.sss'),
        'week': createDateInputType('week', WEEK_REGEXP, weekParser, 'yyyy-Www'),
        'month': createDateInputType('month', MONTH_REGEXP, createDateParser(MONTH_REGEXP, ['yyyy', 'MM']), 'yyyy-MM'),
        'number': numberInputType,
        'url': urlInputType,
        'email': emailInputType,
        'radio': radioInputType,
        'checkbox': checkboxInputType,
        'hidden': noop,
        'button': noop,
        'submit': noop,
        'reset': noop,
        'file': noop
      };
      function stringBasedInputType(ctrl) {
        ctrl.$formatters.push(function(value) {
          return ctrl.$isEmpty(value) ? value : value.toString();
        });
      }
      function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
      }
      function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        var type = lowercase(element[0].type);
        if (!$sniffer.android) {
          var composing = false;
          element.on('compositionstart', function(data) {
            composing = true;
          });
          element.on('compositionend', function() {
            composing = false;
            listener();
          });
        }
        var listener = function(ev) {
          if (timeout) {
            $browser.defer.cancel(timeout);
            timeout = null;
          }
          if (composing)
            return;
          var value = element.val(),
              event = ev && ev.type;
          if (type !== 'password' && (!attr.ngTrim || attr.ngTrim !== 'false')) {
            value = trim(value);
          }
          if (ctrl.$viewValue !== value || (value === '' && ctrl.$$hasNativeValidators)) {
            ctrl.$setViewValue(value, event);
          }
        };
        if ($sniffer.hasEvent('input')) {
          element.on('input', listener);
        } else {
          var timeout;
          var deferListener = function(ev, input, origValue) {
            if (!timeout) {
              timeout = $browser.defer(function() {
                timeout = null;
                if (!input || input.value !== origValue) {
                  listener(ev);
                }
              });
            }
          };
          element.on('keydown', function(event) {
            var key = event.keyCode;
            if (key === 91 || (15 < key && key < 19) || (37 <= key && key <= 40))
              return;
            deferListener(event, this, this.value);
          });
          if ($sniffer.hasEvent('paste')) {
            element.on('paste cut', deferListener);
          }
        }
        element.on('change', listener);
        ctrl.$render = function() {
          var value = ctrl.$isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue;
          if (element.val() !== value) {
            element.val(value);
          }
        };
      }
      function weekParser(isoWeek, existingDate) {
        if (isDate(isoWeek)) {
          return isoWeek;
        }
        if (isString(isoWeek)) {
          WEEK_REGEXP.lastIndex = 0;
          var parts = WEEK_REGEXP.exec(isoWeek);
          if (parts) {
            var year = +parts[1],
                week = +parts[2],
                hours = 0,
                minutes = 0,
                seconds = 0,
                milliseconds = 0,
                firstThurs = getFirstThursdayOfYear(year),
                addDays = (week - 1) * 7;
            if (existingDate) {
              hours = existingDate.getHours();
              minutes = existingDate.getMinutes();
              seconds = existingDate.getSeconds();
              milliseconds = existingDate.getMilliseconds();
            }
            return new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
          }
        }
        return NaN;
      }
      function createDateParser(regexp, mapping) {
        return function(iso, date) {
          var parts,
              map;
          if (isDate(iso)) {
            return iso;
          }
          if (isString(iso)) {
            if (iso.charAt(0) == '"' && iso.charAt(iso.length - 1) == '"') {
              iso = iso.substring(1, iso.length - 1);
            }
            if (ISO_DATE_REGEXP.test(iso)) {
              return new Date(iso);
            }
            regexp.lastIndex = 0;
            parts = regexp.exec(iso);
            if (parts) {
              parts.shift();
              if (date) {
                map = {
                  yyyy: date.getFullYear(),
                  MM: date.getMonth() + 1,
                  dd: date.getDate(),
                  HH: date.getHours(),
                  mm: date.getMinutes(),
                  ss: date.getSeconds(),
                  sss: date.getMilliseconds() / 1000
                };
              } else {
                map = {
                  yyyy: 1970,
                  MM: 1,
                  dd: 1,
                  HH: 0,
                  mm: 0,
                  ss: 0,
                  sss: 0
                };
              }
              forEach(parts, function(part, index) {
                if (index < mapping.length) {
                  map[mapping[index]] = +part;
                }
              });
              return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1000 || 0);
            }
          }
          return NaN;
        };
      }
      function createDateInputType(type, regexp, parseDate, format) {
        return function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
          badInputChecker(scope, element, attr, ctrl);
          baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
          var timezone = ctrl && ctrl.$options && ctrl.$options.timezone;
          var previousDate;
          ctrl.$$parserName = type;
          ctrl.$parsers.push(function(value) {
            if (ctrl.$isEmpty(value))
              return null;
            if (regexp.test(value)) {
              var parsedDate = parseDate(value, previousDate);
              if (timezone) {
                parsedDate = convertTimezoneToLocal(parsedDate, timezone);
              }
              return parsedDate;
            }
            return undefined;
          });
          ctrl.$formatters.push(function(value) {
            if (value && !isDate(value)) {
              throw ngModelMinErr('datefmt', 'Expected `{0}` to be a date', value);
            }
            if (isValidDate(value)) {
              previousDate = value;
              if (previousDate && timezone) {
                previousDate = convertTimezoneToLocal(previousDate, timezone, true);
              }
              return $filter('date')(value, format, timezone);
            } else {
              previousDate = null;
              return '';
            }
          });
          if (isDefined(attr.min) || attr.ngMin) {
            var minVal;
            ctrl.$validators.min = function(value) {
              return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
            };
            attr.$observe('min', function(val) {
              minVal = parseObservedDateValue(val);
              ctrl.$validate();
            });
          }
          if (isDefined(attr.max) || attr.ngMax) {
            var maxVal;
            ctrl.$validators.max = function(value) {
              return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
            };
            attr.$observe('max', function(val) {
              maxVal = parseObservedDateValue(val);
              ctrl.$validate();
            });
          }
          function isValidDate(value) {
            return value && !(value.getTime && value.getTime() !== value.getTime());
          }
          function parseObservedDateValue(val) {
            return isDefined(val) && !isDate(val) ? parseDate(val) || undefined : val;
          }
        };
      }
      function badInputChecker(scope, element, attr, ctrl) {
        var node = element[0];
        var nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
        if (nativeValidation) {
          ctrl.$parsers.push(function(value) {
            var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
            return validity.badInput && !validity.typeMismatch ? undefined : value;
          });
        }
      }
      function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        badInputChecker(scope, element, attr, ctrl);
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        ctrl.$$parserName = 'number';
        ctrl.$parsers.push(function(value) {
          if (ctrl.$isEmpty(value))
            return null;
          if (NUMBER_REGEXP.test(value))
            return parseFloat(value);
          return undefined;
        });
        ctrl.$formatters.push(function(value) {
          if (!ctrl.$isEmpty(value)) {
            if (!isNumber(value)) {
              throw ngModelMinErr('numfmt', 'Expected `{0}` to be a number', value);
            }
            value = value.toString();
          }
          return value;
        });
        if (isDefined(attr.min) || attr.ngMin) {
          var minVal;
          ctrl.$validators.min = function(value) {
            return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
          };
          attr.$observe('min', function(val) {
            if (isDefined(val) && !isNumber(val)) {
              val = parseFloat(val, 10);
            }
            minVal = isNumber(val) && !isNaN(val) ? val : undefined;
            ctrl.$validate();
          });
        }
        if (isDefined(attr.max) || attr.ngMax) {
          var maxVal;
          ctrl.$validators.max = function(value) {
            return ctrl.$isEmpty(value) || isUndefined(maxVal) || value <= maxVal;
          };
          attr.$observe('max', function(val) {
            if (isDefined(val) && !isNumber(val)) {
              val = parseFloat(val, 10);
            }
            maxVal = isNumber(val) && !isNaN(val) ? val : undefined;
            ctrl.$validate();
          });
        }
      }
      function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$$parserName = 'url';
        ctrl.$validators.url = function(modelValue, viewValue) {
          var value = modelValue || viewValue;
          return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
        };
      }
      function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$$parserName = 'email';
        ctrl.$validators.email = function(modelValue, viewValue) {
          var value = modelValue || viewValue;
          return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
        };
      }
      function radioInputType(scope, element, attr, ctrl) {
        if (isUndefined(attr.name)) {
          element.attr('name', nextUid());
        }
        var listener = function(ev) {
          if (element[0].checked) {
            ctrl.$setViewValue(attr.value, ev && ev.type);
          }
        };
        element.on('click', listener);
        ctrl.$render = function() {
          var value = attr.value;
          element[0].checked = (value == ctrl.$viewValue);
        };
        attr.$observe('value', ctrl.$render);
      }
      function parseConstantExpr($parse, context, name, expression, fallback) {
        var parseFn;
        if (isDefined(expression)) {
          parseFn = $parse(expression);
          if (!parseFn.constant) {
            throw ngModelMinErr('constexpr', 'Expected constant expression for `{0}`, but saw ' + '`{1}`.', name, expression);
          }
          return parseFn(context);
        }
        return fallback;
      }
      function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
        var trueValue = parseConstantExpr($parse, scope, 'ngTrueValue', attr.ngTrueValue, true);
        var falseValue = parseConstantExpr($parse, scope, 'ngFalseValue', attr.ngFalseValue, false);
        var listener = function(ev) {
          ctrl.$setViewValue(element[0].checked, ev && ev.type);
        };
        element.on('click', listener);
        ctrl.$render = function() {
          element[0].checked = ctrl.$viewValue;
        };
        ctrl.$isEmpty = function(value) {
          return value === false;
        };
        ctrl.$formatters.push(function(value) {
          return equals(value, trueValue);
        });
        ctrl.$parsers.push(function(value) {
          return value ? trueValue : falseValue;
        });
      }
      var inputDirective = ['$browser', '$sniffer', '$filter', '$parse', function($browser, $sniffer, $filter, $parse) {
        return {
          restrict: 'E',
          require: ['?ngModel'],
          link: {pre: function(scope, element, attr, ctrls) {
              if (ctrls[0]) {
                (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse);
              }
            }}
        };
      }];
      var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
      var ngValueDirective = function() {
        return {
          restrict: 'A',
          priority: 100,
          compile: function(tpl, tplAttr) {
            if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
              return function ngValueConstantLink(scope, elm, attr) {
                attr.$set('value', scope.$eval(attr.ngValue));
              };
            } else {
              return function ngValueLink(scope, elm, attr) {
                scope.$watch(attr.ngValue, function valueWatchAction(value) {
                  attr.$set('value', value);
                });
              };
            }
          }
        };
      };
      var ngBindDirective = ['$compile', function($compile) {
        return {
          restrict: 'AC',
          compile: function ngBindCompile(templateElement) {
            $compile.$$addBindingClass(templateElement);
            return function ngBindLink(scope, element, attr) {
              $compile.$$addBindingInfo(element, attr.ngBind);
              element = element[0];
              scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
                element.textContent = isUndefined(value) ? '' : value;
              });
            };
          }
        };
      }];
      var ngBindTemplateDirective = ['$interpolate', '$compile', function($interpolate, $compile) {
        return {compile: function ngBindTemplateCompile(templateElement) {
            $compile.$$addBindingClass(templateElement);
            return function ngBindTemplateLink(scope, element, attr) {
              var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
              $compile.$$addBindingInfo(element, interpolateFn.expressions);
              element = element[0];
              attr.$observe('ngBindTemplate', function(value) {
                element.textContent = isUndefined(value) ? '' : value;
              });
            };
          }};
      }];
      var ngBindHtmlDirective = ['$sce', '$parse', '$compile', function($sce, $parse, $compile) {
        return {
          restrict: 'A',
          compile: function ngBindHtmlCompile(tElement, tAttrs) {
            var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);
            var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function getStringValue(value) {
              return (value || '').toString();
            });
            $compile.$$addBindingClass(tElement);
            return function ngBindHtmlLink(scope, element, attr) {
              $compile.$$addBindingInfo(element, attr.ngBindHtml);
              scope.$watch(ngBindHtmlWatch, function ngBindHtmlWatchAction() {
                element.html($sce.getTrustedHtml(ngBindHtmlGetter(scope)) || '');
              });
            };
          }
        };
      }];
      var ngChangeDirective = valueFn({
        restrict: 'A',
        require: 'ngModel',
        link: function(scope, element, attr, ctrl) {
          ctrl.$viewChangeListeners.push(function() {
            scope.$eval(attr.ngChange);
          });
        }
      });
      function classDirective(name, selector) {
        name = 'ngClass' + name;
        return ['$animate', function($animate) {
          return {
            restrict: 'AC',
            link: function(scope, element, attr) {
              var oldVal;
              scope.$watch(attr[name], ngClassWatchAction, true);
              attr.$observe('class', function(value) {
                ngClassWatchAction(scope.$eval(attr[name]));
              });
              if (name !== 'ngClass') {
                scope.$watch('$index', function($index, old$index) {
                  var mod = $index & 1;
                  if (mod !== (old$index & 1)) {
                    var classes = arrayClasses(scope.$eval(attr[name]));
                    mod === selector ? addClasses(classes) : removeClasses(classes);
                  }
                });
              }
              function addClasses(classes) {
                var newClasses = digestClassCounts(classes, 1);
                attr.$addClass(newClasses);
              }
              function removeClasses(classes) {
                var newClasses = digestClassCounts(classes, -1);
                attr.$removeClass(newClasses);
              }
              function digestClassCounts(classes, count) {
                var classCounts = element.data('$classCounts') || createMap();
                var classesToUpdate = [];
                forEach(classes, function(className) {
                  if (count > 0 || classCounts[className]) {
                    classCounts[className] = (classCounts[className] || 0) + count;
                    if (classCounts[className] === +(count > 0)) {
                      classesToUpdate.push(className);
                    }
                  }
                });
                element.data('$classCounts', classCounts);
                return classesToUpdate.join(' ');
              }
              function updateClasses(oldClasses, newClasses) {
                var toAdd = arrayDifference(newClasses, oldClasses);
                var toRemove = arrayDifference(oldClasses, newClasses);
                toAdd = digestClassCounts(toAdd, 1);
                toRemove = digestClassCounts(toRemove, -1);
                if (toAdd && toAdd.length) {
                  $animate.addClass(element, toAdd);
                }
                if (toRemove && toRemove.length) {
                  $animate.removeClass(element, toRemove);
                }
              }
              function ngClassWatchAction(newVal) {
                if (selector === true || scope.$index % 2 === selector) {
                  var newClasses = arrayClasses(newVal || []);
                  if (!oldVal) {
                    addClasses(newClasses);
                  } else if (!equals(newVal, oldVal)) {
                    var oldClasses = arrayClasses(oldVal);
                    updateClasses(oldClasses, newClasses);
                  }
                }
                oldVal = shallowCopy(newVal);
              }
            }
          };
          function arrayDifference(tokens1, tokens2) {
            var values = [];
            outer: for (var i = 0; i < tokens1.length; i++) {
              var token = tokens1[i];
              for (var j = 0; j < tokens2.length; j++) {
                if (token == tokens2[j])
                  continue outer;
              }
              values.push(token);
            }
            return values;
          }
          function arrayClasses(classVal) {
            var classes = [];
            if (isArray(classVal)) {
              forEach(classVal, function(v) {
                classes = classes.concat(arrayClasses(v));
              });
              return classes;
            } else if (isString(classVal)) {
              return classVal.split(' ');
            } else if (isObject(classVal)) {
              forEach(classVal, function(v, k) {
                if (v) {
                  classes = classes.concat(k.split(' '));
                }
              });
              return classes;
            }
            return classVal;
          }
        }];
      }
      var ngClassDirective = classDirective('', true);
      var ngClassOddDirective = classDirective('Odd', 0);
      var ngClassEvenDirective = classDirective('Even', 1);
      var ngCloakDirective = ngDirective({compile: function(element, attr) {
          attr.$set('ngCloak', undefined);
          element.removeClass('ng-cloak');
        }});
      var ngControllerDirective = [function() {
        return {
          restrict: 'A',
          scope: true,
          controller: '@',
          priority: 500
        };
      }];
      var ngEventDirectives = {};
      var forceAsyncEvents = {
        'blur': true,
        'focus': true
      };
      forEach('click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste'.split(' '), function(eventName) {
        var directiveName = directiveNormalize('ng-' + eventName);
        ngEventDirectives[directiveName] = ['$parse', '$rootScope', function($parse, $rootScope) {
          return {
            restrict: 'A',
            compile: function($element, attr) {
              var fn = $parse(attr[directiveName], null, true);
              return function ngEventHandler(scope, element) {
                element.on(eventName, function(event) {
                  var callback = function() {
                    fn(scope, {$event: event});
                  };
                  if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                    scope.$evalAsync(callback);
                  } else {
                    scope.$apply(callback);
                  }
                });
              };
            }
          };
        }];
      });
      var ngIfDirective = ['$animate', function($animate) {
        return {
          multiElement: true,
          transclude: 'element',
          priority: 600,
          terminal: true,
          restrict: 'A',
          $$tlb: true,
          link: function($scope, $element, $attr, ctrl, $transclude) {
            var block,
                childScope,
                previousElements;
            $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
              if (value) {
                if (!childScope) {
                  $transclude(function(clone, newScope) {
                    childScope = newScope;
                    clone[clone.length++] = document.createComment(' end ngIf: ' + $attr.ngIf + ' ');
                    block = {clone: clone};
                    $animate.enter(clone, $element.parent(), $element);
                  });
                }
              } else {
                if (previousElements) {
                  previousElements.remove();
                  previousElements = null;
                }
                if (childScope) {
                  childScope.$destroy();
                  childScope = null;
                }
                if (block) {
                  previousElements = getBlockNodes(block.clone);
                  $animate.leave(previousElements).then(function() {
                    previousElements = null;
                  });
                  block = null;
                }
              }
            });
          }
        };
      }];
      var ngIncludeDirective = ['$templateRequest', '$anchorScroll', '$animate', function($templateRequest, $anchorScroll, $animate) {
        return {
          restrict: 'ECA',
          priority: 400,
          terminal: true,
          transclude: 'element',
          controller: angular.noop,
          compile: function(element, attr) {
            var srcExp = attr.ngInclude || attr.src,
                onloadExp = attr.onload || '',
                autoScrollExp = attr.autoscroll;
            return function(scope, $element, $attr, ctrl, $transclude) {
              var changeCounter = 0,
                  currentScope,
                  previousElement,
                  currentElement;
              var cleanupLastIncludeContent = function() {
                if (previousElement) {
                  previousElement.remove();
                  previousElement = null;
                }
                if (currentScope) {
                  currentScope.$destroy();
                  currentScope = null;
                }
                if (currentElement) {
                  $animate.leave(currentElement).then(function() {
                    previousElement = null;
                  });
                  previousElement = currentElement;
                  currentElement = null;
                }
              };
              scope.$watch(srcExp, function ngIncludeWatchAction(src) {
                var afterAnimation = function() {
                  if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                    $anchorScroll();
                  }
                };
                var thisChangeId = ++changeCounter;
                if (src) {
                  $templateRequest(src, true).then(function(response) {
                    if (thisChangeId !== changeCounter)
                      return;
                    var newScope = scope.$new();
                    ctrl.template = response;
                    var clone = $transclude(newScope, function(clone) {
                      cleanupLastIncludeContent();
                      $animate.enter(clone, null, $element).then(afterAnimation);
                    });
                    currentScope = newScope;
                    currentElement = clone;
                    currentScope.$emit('$includeContentLoaded', src);
                    scope.$eval(onloadExp);
                  }, function() {
                    if (thisChangeId === changeCounter) {
                      cleanupLastIncludeContent();
                      scope.$emit('$includeContentError', src);
                    }
                  });
                  scope.$emit('$includeContentRequested', src);
                } else {
                  cleanupLastIncludeContent();
                  ctrl.template = null;
                }
              });
            };
          }
        };
      }];
      var ngIncludeFillContentDirective = ['$compile', function($compile) {
        return {
          restrict: 'ECA',
          priority: -400,
          require: 'ngInclude',
          link: function(scope, $element, $attr, ctrl) {
            if (/SVG/.test($element[0].toString())) {
              $element.empty();
              $compile(jqLiteBuildFragment(ctrl.template, document).childNodes)(scope, function namespaceAdaptedClone(clone) {
                $element.append(clone);
              }, {futureParentElement: $element});
              return;
            }
            $element.html(ctrl.template);
            $compile($element.contents())(scope);
          }
        };
      }];
      var ngInitDirective = ngDirective({
        priority: 450,
        compile: function() {
          return {pre: function(scope, element, attrs) {
              scope.$eval(attrs.ngInit);
            }};
        }
      });
      var ngListDirective = function() {
        return {
          restrict: 'A',
          priority: 100,
          require: 'ngModel',
          link: function(scope, element, attr, ctrl) {
            var ngList = element.attr(attr.$attr.ngList) || ', ';
            var trimValues = attr.ngTrim !== 'false';
            var separator = trimValues ? trim(ngList) : ngList;
            var parse = function(viewValue) {
              if (isUndefined(viewValue))
                return;
              var list = [];
              if (viewValue) {
                forEach(viewValue.split(separator), function(value) {
                  if (value)
                    list.push(trimValues ? trim(value) : value);
                });
              }
              return list;
            };
            ctrl.$parsers.push(parse);
            ctrl.$formatters.push(function(value) {
              if (isArray(value)) {
                return value.join(ngList);
              }
              return undefined;
            });
            ctrl.$isEmpty = function(value) {
              return !value || !value.length;
            };
          }
        };
      };
      var VALID_CLASS = 'ng-valid',
          INVALID_CLASS = 'ng-invalid',
          PRISTINE_CLASS = 'ng-pristine',
          DIRTY_CLASS = 'ng-dirty',
          UNTOUCHED_CLASS = 'ng-untouched',
          TOUCHED_CLASS = 'ng-touched',
          PENDING_CLASS = 'ng-pending';
      var ngModelMinErr = minErr('ngModel');
      var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$parse', '$animate', '$timeout', '$rootScope', '$q', '$interpolate', function($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $rootScope, $q, $interpolate) {
        this.$viewValue = Number.NaN;
        this.$modelValue = Number.NaN;
        this.$$rawModelValue = undefined;
        this.$validators = {};
        this.$asyncValidators = {};
        this.$parsers = [];
        this.$formatters = [];
        this.$viewChangeListeners = [];
        this.$untouched = true;
        this.$touched = false;
        this.$pristine = true;
        this.$dirty = false;
        this.$valid = true;
        this.$invalid = false;
        this.$error = {};
        this.$$success = {};
        this.$pending = undefined;
        this.$name = $interpolate($attr.name || '', false)($scope);
        this.$$parentForm = nullFormCtrl;
        var parsedNgModel = $parse($attr.ngModel),
            parsedNgModelAssign = parsedNgModel.assign,
            ngModelGet = parsedNgModel,
            ngModelSet = parsedNgModelAssign,
            pendingDebounce = null,
            parserValid,
            ctrl = this;
        this.$$setOptions = function(options) {
          ctrl.$options = options;
          if (options && options.getterSetter) {
            var invokeModelGetter = $parse($attr.ngModel + '()'),
                invokeModelSetter = $parse($attr.ngModel + '($$$p)');
            ngModelGet = function($scope) {
              var modelValue = parsedNgModel($scope);
              if (isFunction(modelValue)) {
                modelValue = invokeModelGetter($scope);
              }
              return modelValue;
            };
            ngModelSet = function($scope, newValue) {
              if (isFunction(parsedNgModel($scope))) {
                invokeModelSetter($scope, {$$$p: ctrl.$modelValue});
              } else {
                parsedNgModelAssign($scope, ctrl.$modelValue);
              }
            };
          } else if (!parsedNgModel.assign) {
            throw ngModelMinErr('nonassign', "Expression '{0}' is non-assignable. Element: {1}", $attr.ngModel, startingTag($element));
          }
        };
        this.$render = noop;
        this.$isEmpty = function(value) {
          return isUndefined(value) || value === '' || value === null || value !== value;
        };
        var currentValidationRunId = 0;
        addSetValidityMethod({
          ctrl: this,
          $element: $element,
          set: function(object, property) {
            object[property] = true;
          },
          unset: function(object, property) {
            delete object[property];
          },
          $animate: $animate
        });
        this.$setPristine = function() {
          ctrl.$dirty = false;
          ctrl.$pristine = true;
          $animate.removeClass($element, DIRTY_CLASS);
          $animate.addClass($element, PRISTINE_CLASS);
        };
        this.$setDirty = function() {
          ctrl.$dirty = true;
          ctrl.$pristine = false;
          $animate.removeClass($element, PRISTINE_CLASS);
          $animate.addClass($element, DIRTY_CLASS);
          ctrl.$$parentForm.$setDirty();
        };
        this.$setUntouched = function() {
          ctrl.$touched = false;
          ctrl.$untouched = true;
          $animate.setClass($element, UNTOUCHED_CLASS, TOUCHED_CLASS);
        };
        this.$setTouched = function() {
          ctrl.$touched = true;
          ctrl.$untouched = false;
          $animate.setClass($element, TOUCHED_CLASS, UNTOUCHED_CLASS);
        };
        this.$rollbackViewValue = function() {
          $timeout.cancel(pendingDebounce);
          ctrl.$viewValue = ctrl.$$lastCommittedViewValue;
          ctrl.$render();
        };
        this.$validate = function() {
          if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
            return;
          }
          var viewValue = ctrl.$$lastCommittedViewValue;
          var modelValue = ctrl.$$rawModelValue;
          var prevValid = ctrl.$valid;
          var prevModelValue = ctrl.$modelValue;
          var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
          ctrl.$$runValidators(modelValue, viewValue, function(allValid) {
            if (!allowInvalid && prevValid !== allValid) {
              ctrl.$modelValue = allValid ? modelValue : undefined;
              if (ctrl.$modelValue !== prevModelValue) {
                ctrl.$$writeModelToScope();
              }
            }
          });
        };
        this.$$runValidators = function(modelValue, viewValue, doneCallback) {
          currentValidationRunId++;
          var localValidationRunId = currentValidationRunId;
          if (!processParseErrors()) {
            validationDone(false);
            return;
          }
          if (!processSyncValidators()) {
            validationDone(false);
            return;
          }
          processAsyncValidators();
          function processParseErrors() {
            var errorKey = ctrl.$$parserName || 'parse';
            if (isUndefined(parserValid)) {
              setValidity(errorKey, null);
            } else {
              if (!parserValid) {
                forEach(ctrl.$validators, function(v, name) {
                  setValidity(name, null);
                });
                forEach(ctrl.$asyncValidators, function(v, name) {
                  setValidity(name, null);
                });
              }
              setValidity(errorKey, parserValid);
              return parserValid;
            }
            return true;
          }
          function processSyncValidators() {
            var syncValidatorsValid = true;
            forEach(ctrl.$validators, function(validator, name) {
              var result = validator(modelValue, viewValue);
              syncValidatorsValid = syncValidatorsValid && result;
              setValidity(name, result);
            });
            if (!syncValidatorsValid) {
              forEach(ctrl.$asyncValidators, function(v, name) {
                setValidity(name, null);
              });
              return false;
            }
            return true;
          }
          function processAsyncValidators() {
            var validatorPromises = [];
            var allValid = true;
            forEach(ctrl.$asyncValidators, function(validator, name) {
              var promise = validator(modelValue, viewValue);
              if (!isPromiseLike(promise)) {
                throw ngModelMinErr("$asyncValidators", "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
              }
              setValidity(name, undefined);
              validatorPromises.push(promise.then(function() {
                setValidity(name, true);
              }, function(error) {
                allValid = false;
                setValidity(name, false);
              }));
            });
            if (!validatorPromises.length) {
              validationDone(true);
            } else {
              $q.all(validatorPromises).then(function() {
                validationDone(allValid);
              }, noop);
            }
          }
          function setValidity(name, isValid) {
            if (localValidationRunId === currentValidationRunId) {
              ctrl.$setValidity(name, isValid);
            }
          }
          function validationDone(allValid) {
            if (localValidationRunId === currentValidationRunId) {
              doneCallback(allValid);
            }
          }
        };
        this.$commitViewValue = function() {
          var viewValue = ctrl.$viewValue;
          $timeout.cancel(pendingDebounce);
          if (ctrl.$$lastCommittedViewValue === viewValue && (viewValue !== '' || !ctrl.$$hasNativeValidators)) {
            return;
          }
          ctrl.$$lastCommittedViewValue = viewValue;
          if (ctrl.$pristine) {
            this.$setDirty();
          }
          this.$$parseAndValidate();
        };
        this.$$parseAndValidate = function() {
          var viewValue = ctrl.$$lastCommittedViewValue;
          var modelValue = viewValue;
          parserValid = isUndefined(modelValue) ? undefined : true;
          if (parserValid) {
            for (var i = 0; i < ctrl.$parsers.length; i++) {
              modelValue = ctrl.$parsers[i](modelValue);
              if (isUndefined(modelValue)) {
                parserValid = false;
                break;
              }
            }
          }
          if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
            ctrl.$modelValue = ngModelGet($scope);
          }
          var prevModelValue = ctrl.$modelValue;
          var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
          ctrl.$$rawModelValue = modelValue;
          if (allowInvalid) {
            ctrl.$modelValue = modelValue;
            writeToModelIfNeeded();
          }
          ctrl.$$runValidators(modelValue, ctrl.$$lastCommittedViewValue, function(allValid) {
            if (!allowInvalid) {
              ctrl.$modelValue = allValid ? modelValue : undefined;
              writeToModelIfNeeded();
            }
          });
          function writeToModelIfNeeded() {
            if (ctrl.$modelValue !== prevModelValue) {
              ctrl.$$writeModelToScope();
            }
          }
        };
        this.$$writeModelToScope = function() {
          ngModelSet($scope, ctrl.$modelValue);
          forEach(ctrl.$viewChangeListeners, function(listener) {
            try {
              listener();
            } catch (e) {
              $exceptionHandler(e);
            }
          });
        };
        this.$setViewValue = function(value, trigger) {
          ctrl.$viewValue = value;
          if (!ctrl.$options || ctrl.$options.updateOnDefault) {
            ctrl.$$debounceViewValueCommit(trigger);
          }
        };
        this.$$debounceViewValueCommit = function(trigger) {
          var debounceDelay = 0,
              options = ctrl.$options,
              debounce;
          if (options && isDefined(options.debounce)) {
            debounce = options.debounce;
            if (isNumber(debounce)) {
              debounceDelay = debounce;
            } else if (isNumber(debounce[trigger])) {
              debounceDelay = debounce[trigger];
            } else if (isNumber(debounce['default'])) {
              debounceDelay = debounce['default'];
            }
          }
          $timeout.cancel(pendingDebounce);
          if (debounceDelay) {
            pendingDebounce = $timeout(function() {
              ctrl.$commitViewValue();
            }, debounceDelay);
          } else if ($rootScope.$$phase) {
            ctrl.$commitViewValue();
          } else {
            $scope.$apply(function() {
              ctrl.$commitViewValue();
            });
          }
        };
        $scope.$watch(function ngModelWatch() {
          var modelValue = ngModelGet($scope);
          if (modelValue !== ctrl.$modelValue && (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)) {
            ctrl.$modelValue = ctrl.$$rawModelValue = modelValue;
            parserValid = undefined;
            var formatters = ctrl.$formatters,
                idx = formatters.length;
            var viewValue = modelValue;
            while (idx--) {
              viewValue = formatters[idx](viewValue);
            }
            if (ctrl.$viewValue !== viewValue) {
              ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue;
              ctrl.$render();
              ctrl.$$runValidators(modelValue, viewValue, noop);
            }
          }
          return modelValue;
        });
      }];
      var ngModelDirective = ['$rootScope', function($rootScope) {
        return {
          restrict: 'A',
          require: ['ngModel', '^?form', '^?ngModelOptions'],
          controller: NgModelController,
          priority: 1,
          compile: function ngModelCompile(element) {
            element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS);
            return {
              pre: function ngModelPreLink(scope, element, attr, ctrls) {
                var modelCtrl = ctrls[0],
                    formCtrl = ctrls[1] || modelCtrl.$$parentForm;
                modelCtrl.$$setOptions(ctrls[2] && ctrls[2].$options);
                formCtrl.$addControl(modelCtrl);
                attr.$observe('name', function(newValue) {
                  if (modelCtrl.$name !== newValue) {
                    modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue);
                  }
                });
                scope.$on('$destroy', function() {
                  modelCtrl.$$parentForm.$removeControl(modelCtrl);
                });
              },
              post: function ngModelPostLink(scope, element, attr, ctrls) {
                var modelCtrl = ctrls[0];
                if (modelCtrl.$options && modelCtrl.$options.updateOn) {
                  element.on(modelCtrl.$options.updateOn, function(ev) {
                    modelCtrl.$$debounceViewValueCommit(ev && ev.type);
                  });
                }
                element.on('blur', function(ev) {
                  if (modelCtrl.$touched)
                    return;
                  if ($rootScope.$$phase) {
                    scope.$evalAsync(modelCtrl.$setTouched);
                  } else {
                    scope.$apply(modelCtrl.$setTouched);
                  }
                });
              }
            };
          }
        };
      }];
      var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
      var ngModelOptionsDirective = function() {
        return {
          restrict: 'A',
          controller: ['$scope', '$attrs', function($scope, $attrs) {
            var that = this;
            this.$options = copy($scope.$eval($attrs.ngModelOptions));
            if (isDefined(this.$options.updateOn)) {
              this.$options.updateOnDefault = false;
              this.$options.updateOn = trim(this.$options.updateOn.replace(DEFAULT_REGEXP, function() {
                that.$options.updateOnDefault = true;
                return ' ';
              }));
            } else {
              this.$options.updateOnDefault = true;
            }
          }]
        };
      };
      function addSetValidityMethod(context) {
        var ctrl = context.ctrl,
            $element = context.$element,
            classCache = {},
            set = context.set,
            unset = context.unset,
            $animate = context.$animate;
        classCache[INVALID_CLASS] = !(classCache[VALID_CLASS] = $element.hasClass(VALID_CLASS));
        ctrl.$setValidity = setValidity;
        function setValidity(validationErrorKey, state, controller) {
          if (isUndefined(state)) {
            createAndSet('$pending', validationErrorKey, controller);
          } else {
            unsetAndCleanup('$pending', validationErrorKey, controller);
          }
          if (!isBoolean(state)) {
            unset(ctrl.$error, validationErrorKey, controller);
            unset(ctrl.$$success, validationErrorKey, controller);
          } else {
            if (state) {
              unset(ctrl.$error, validationErrorKey, controller);
              set(ctrl.$$success, validationErrorKey, controller);
            } else {
              set(ctrl.$error, validationErrorKey, controller);
              unset(ctrl.$$success, validationErrorKey, controller);
            }
          }
          if (ctrl.$pending) {
            cachedToggleClass(PENDING_CLASS, true);
            ctrl.$valid = ctrl.$invalid = undefined;
            toggleValidationCss('', null);
          } else {
            cachedToggleClass(PENDING_CLASS, false);
            ctrl.$valid = isObjectEmpty(ctrl.$error);
            ctrl.$invalid = !ctrl.$valid;
            toggleValidationCss('', ctrl.$valid);
          }
          var combinedState;
          if (ctrl.$pending && ctrl.$pending[validationErrorKey]) {
            combinedState = undefined;
          } else if (ctrl.$error[validationErrorKey]) {
            combinedState = false;
          } else if (ctrl.$$success[validationErrorKey]) {
            combinedState = true;
          } else {
            combinedState = null;
          }
          toggleValidationCss(validationErrorKey, combinedState);
          ctrl.$$parentForm.$setValidity(validationErrorKey, combinedState, ctrl);
        }
        function createAndSet(name, value, controller) {
          if (!ctrl[name]) {
            ctrl[name] = {};
          }
          set(ctrl[name], value, controller);
        }
        function unsetAndCleanup(name, value, controller) {
          if (ctrl[name]) {
            unset(ctrl[name], value, controller);
          }
          if (isObjectEmpty(ctrl[name])) {
            ctrl[name] = undefined;
          }
        }
        function cachedToggleClass(className, switchValue) {
          if (switchValue && !classCache[className]) {
            $animate.addClass($element, className);
            classCache[className] = true;
          } else if (!switchValue && classCache[className]) {
            $animate.removeClass($element, className);
            classCache[className] = false;
          }
        }
        function toggleValidationCss(validationErrorKey, isValid) {
          validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
          cachedToggleClass(VALID_CLASS + validationErrorKey, isValid === true);
          cachedToggleClass(INVALID_CLASS + validationErrorKey, isValid === false);
        }
      }
      function isObjectEmpty(obj) {
        if (obj) {
          for (var prop in obj) {
            if (obj.hasOwnProperty(prop)) {
              return false;
            }
          }
        }
        return true;
      }
      var ngNonBindableDirective = ngDirective({
        terminal: true,
        priority: 1000
      });
      var ngOptionsMinErr = minErr('ngOptions');
      var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;
      var ngOptionsDirective = ['$compile', '$parse', function($compile, $parse) {
        function parseOptionsExpression(optionsExp, selectElement, scope) {
          var match = optionsExp.match(NG_OPTIONS_REGEXP);
          if (!(match)) {
            throw ngOptionsMinErr('iexp', "Expected expression in form of " + "'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" + " but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
          }
          var valueName = match[5] || match[7];
          var keyName = match[6];
          var selectAs = / as /.test(match[0]) && match[1];
          var trackBy = match[9];
          var valueFn = $parse(match[2] ? match[1] : valueName);
          var selectAsFn = selectAs && $parse(selectAs);
          var viewValueFn = selectAsFn || valueFn;
          var trackByFn = trackBy && $parse(trackBy);
          var getTrackByValueFn = trackBy ? function(value, locals) {
            return trackByFn(scope, locals);
          } : function getHashOfValue(value) {
            return hashKey(value);
          };
          var getTrackByValue = function(value, key) {
            return getTrackByValueFn(value, getLocals(value, key));
          };
          var displayFn = $parse(match[2] || match[1]);
          var groupByFn = $parse(match[3] || '');
          var disableWhenFn = $parse(match[4] || '');
          var valuesFn = $parse(match[8]);
          var locals = {};
          var getLocals = keyName ? function(value, key) {
            locals[keyName] = key;
            locals[valueName] = value;
            return locals;
          } : function(value) {
            locals[valueName] = value;
            return locals;
          };
          function Option(selectValue, viewValue, label, group, disabled) {
            this.selectValue = selectValue;
            this.viewValue = viewValue;
            this.label = label;
            this.group = group;
            this.disabled = disabled;
          }
          function getOptionValuesKeys(optionValues) {
            var optionValuesKeys;
            if (!keyName && isArrayLike(optionValues)) {
              optionValuesKeys = optionValues;
            } else {
              optionValuesKeys = [];
              for (var itemKey in optionValues) {
                if (optionValues.hasOwnProperty(itemKey) && itemKey.charAt(0) !== '$') {
                  optionValuesKeys.push(itemKey);
                }
              }
            }
            return optionValuesKeys;
          }
          return {
            trackBy: trackBy,
            getTrackByValue: getTrackByValue,
            getWatchables: $parse(valuesFn, function(optionValues) {
              var watchedArray = [];
              optionValues = optionValues || [];
              var optionValuesKeys = getOptionValuesKeys(optionValues);
              var optionValuesLength = optionValuesKeys.length;
              for (var index = 0; index < optionValuesLength; index++) {
                var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
                var value = optionValues[key];
                var locals = getLocals(optionValues[key], key);
                var selectValue = getTrackByValueFn(optionValues[key], locals);
                watchedArray.push(selectValue);
                if (match[2] || match[1]) {
                  var label = displayFn(scope, locals);
                  watchedArray.push(label);
                }
                if (match[4]) {
                  var disableWhen = disableWhenFn(scope, locals);
                  watchedArray.push(disableWhen);
                }
              }
              return watchedArray;
            }),
            getOptions: function() {
              var optionItems = [];
              var selectValueMap = {};
              var optionValues = valuesFn(scope) || [];
              var optionValuesKeys = getOptionValuesKeys(optionValues);
              var optionValuesLength = optionValuesKeys.length;
              for (var index = 0; index < optionValuesLength; index++) {
                var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
                var value = optionValues[key];
                var locals = getLocals(value, key);
                var viewValue = viewValueFn(scope, locals);
                var selectValue = getTrackByValueFn(viewValue, locals);
                var label = displayFn(scope, locals);
                var group = groupByFn(scope, locals);
                var disabled = disableWhenFn(scope, locals);
                var optionItem = new Option(selectValue, viewValue, label, group, disabled);
                optionItems.push(optionItem);
                selectValueMap[selectValue] = optionItem;
              }
              return {
                items: optionItems,
                selectValueMap: selectValueMap,
                getOptionFromViewValue: function(value) {
                  return selectValueMap[getTrackByValue(value)];
                },
                getViewValueFromOption: function(option) {
                  return trackBy ? angular.copy(option.viewValue) : option.viewValue;
                }
              };
            }
          };
        }
        var optionTemplate = document.createElement('option'),
            optGroupTemplate = document.createElement('optgroup');
        function ngOptionsPostLink(scope, selectElement, attr, ctrls) {
          var ngModelCtrl = ctrls[1];
          if (!ngModelCtrl)
            return;
          var selectCtrl = ctrls[0];
          var multiple = attr.multiple;
          var emptyOption;
          for (var i = 0,
              children = selectElement.children(),
              ii = children.length; i < ii; i++) {
            if (children[i].value === '') {
              emptyOption = children.eq(i);
              break;
            }
          }
          var providedEmptyOption = !!emptyOption;
          var unknownOption = jqLite(optionTemplate.cloneNode(false));
          unknownOption.val('?');
          var options;
          var ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope);
          var renderEmptyOption = function() {
            if (!providedEmptyOption) {
              selectElement.prepend(emptyOption);
            }
            selectElement.val('');
            emptyOption.prop('selected', true);
            emptyOption.attr('selected', true);
          };
          var removeEmptyOption = function() {
            if (!providedEmptyOption) {
              emptyOption.remove();
            }
          };
          var renderUnknownOption = function() {
            selectElement.prepend(unknownOption);
            selectElement.val('?');
            unknownOption.prop('selected', true);
            unknownOption.attr('selected', true);
          };
          var removeUnknownOption = function() {
            unknownOption.remove();
          };
          if (!multiple) {
            selectCtrl.writeValue = function writeNgOptionsValue(value) {
              var option = options.getOptionFromViewValue(value);
              if (option && !option.disabled) {
                if (selectElement[0].value !== option.selectValue) {
                  removeUnknownOption();
                  removeEmptyOption();
                  selectElement[0].value = option.selectValue;
                  option.element.selected = true;
                  option.element.setAttribute('selected', 'selected');
                }
              } else {
                if (value === null || providedEmptyOption) {
                  removeUnknownOption();
                  renderEmptyOption();
                } else {
                  removeEmptyOption();
                  renderUnknownOption();
                }
              }
            };
            selectCtrl.readValue = function readNgOptionsValue() {
              var selectedOption = options.selectValueMap[selectElement.val()];
              if (selectedOption && !selectedOption.disabled) {
                removeEmptyOption();
                removeUnknownOption();
                return options.getViewValueFromOption(selectedOption);
              }
              return null;
            };
            if (ngOptions.trackBy) {
              scope.$watch(function() {
                return ngOptions.getTrackByValue(ngModelCtrl.$viewValue);
              }, function() {
                ngModelCtrl.$render();
              });
            }
          } else {
            ngModelCtrl.$isEmpty = function(value) {
              return !value || value.length === 0;
            };
            selectCtrl.writeValue = function writeNgOptionsMultiple(value) {
              options.items.forEach(function(option) {
                option.element.selected = false;
              });
              if (value) {
                value.forEach(function(item) {
                  var option = options.getOptionFromViewValue(item);
                  if (option && !option.disabled)
                    option.element.selected = true;
                });
              }
            };
            selectCtrl.readValue = function readNgOptionsMultiple() {
              var selectedValues = selectElement.val() || [],
                  selections = [];
              forEach(selectedValues, function(value) {
                var option = options.selectValueMap[value];
                if (option && !option.disabled)
                  selections.push(options.getViewValueFromOption(option));
              });
              return selections;
            };
            if (ngOptions.trackBy) {
              scope.$watchCollection(function() {
                if (isArray(ngModelCtrl.$viewValue)) {
                  return ngModelCtrl.$viewValue.map(function(value) {
                    return ngOptions.getTrackByValue(value);
                  });
                }
              }, function() {
                ngModelCtrl.$render();
              });
            }
          }
          if (providedEmptyOption) {
            emptyOption.remove();
            $compile(emptyOption)(scope);
            emptyOption.removeClass('ng-scope');
          } else {
            emptyOption = jqLite(optionTemplate.cloneNode(false));
          }
          updateOptions();
          scope.$watchCollection(ngOptions.getWatchables, updateOptions);
          function updateOptionElement(option, element) {
            option.element = element;
            element.disabled = option.disabled;
            if (option.label !== element.label) {
              element.label = option.label;
              element.textContent = option.label;
            }
            if (option.value !== element.value)
              element.value = option.selectValue;
          }
          function addOrReuseElement(parent, current, type, templateElement) {
            var element;
            if (current && lowercase(current.nodeName) === type) {
              element = current;
            } else {
              element = templateElement.cloneNode(false);
              if (!current) {
                parent.appendChild(element);
              } else {
                parent.insertBefore(element, current);
              }
            }
            return element;
          }
          function removeExcessElements(current) {
            var next;
            while (current) {
              next = current.nextSibling;
              jqLiteRemove(current);
              current = next;
            }
          }
          function skipEmptyAndUnknownOptions(current) {
            var emptyOption_ = emptyOption && emptyOption[0];
            var unknownOption_ = unknownOption && unknownOption[0];
            if (emptyOption_ || unknownOption_) {
              while (current && (current === emptyOption_ || current === unknownOption_ || current.nodeType === NODE_TYPE_COMMENT || current.value === '')) {
                current = current.nextSibling;
              }
            }
            return current;
          }
          function updateOptions() {
            var previousValue = options && selectCtrl.readValue();
            options = ngOptions.getOptions();
            var groupMap = {};
            var currentElement = selectElement[0].firstChild;
            if (providedEmptyOption) {
              selectElement.prepend(emptyOption);
            }
            currentElement = skipEmptyAndUnknownOptions(currentElement);
            options.items.forEach(function updateOption(option) {
              var group;
              var groupElement;
              var optionElement;
              if (option.group) {
                group = groupMap[option.group];
                if (!group) {
                  groupElement = addOrReuseElement(selectElement[0], currentElement, 'optgroup', optGroupTemplate);
                  currentElement = groupElement.nextSibling;
                  groupElement.label = option.group;
                  group = groupMap[option.group] = {
                    groupElement: groupElement,
                    currentOptionElement: groupElement.firstChild
                  };
                }
                optionElement = addOrReuseElement(group.groupElement, group.currentOptionElement, 'option', optionTemplate);
                updateOptionElement(option, optionElement);
                group.currentOptionElement = optionElement.nextSibling;
              } else {
                optionElement = addOrReuseElement(selectElement[0], currentElement, 'option', optionTemplate);
                updateOptionElement(option, optionElement);
                currentElement = optionElement.nextSibling;
              }
            });
            Object.keys(groupMap).forEach(function(key) {
              removeExcessElements(groupMap[key].currentOptionElement);
            });
            removeExcessElements(currentElement);
            ngModelCtrl.$render();
            if (!ngModelCtrl.$isEmpty(previousValue)) {
              var nextValue = selectCtrl.readValue();
              if (ngOptions.trackBy ? !equals(previousValue, nextValue) : previousValue !== nextValue) {
                ngModelCtrl.$setViewValue(nextValue);
                ngModelCtrl.$render();
              }
            }
          }
        }
        return {
          restrict: 'A',
          terminal: true,
          require: ['select', '?ngModel'],
          link: {
            pre: function ngOptionsPreLink(scope, selectElement, attr, ctrls) {
              ctrls[0].registerOption = noop;
            },
            post: ngOptionsPostLink
          }
        };
      }];
      var ngPluralizeDirective = ['$locale', '$interpolate', '$log', function($locale, $interpolate, $log) {
        var BRACE = /{}/g,
            IS_WHEN = /^when(Minus)?(.+)$/;
        return {link: function(scope, element, attr) {
            var numberExp = attr.count,
                whenExp = attr.$attr.when && element.attr(attr.$attr.when),
                offset = attr.offset || 0,
                whens = scope.$eval(whenExp) || {},
                whensExpFns = {},
                startSymbol = $interpolate.startSymbol(),
                endSymbol = $interpolate.endSymbol(),
                braceReplacement = startSymbol + numberExp + '-' + offset + endSymbol,
                watchRemover = angular.noop,
                lastCount;
            forEach(attr, function(expression, attributeName) {
              var tmpMatch = IS_WHEN.exec(attributeName);
              if (tmpMatch) {
                var whenKey = (tmpMatch[1] ? '-' : '') + lowercase(tmpMatch[2]);
                whens[whenKey] = element.attr(attr.$attr[attributeName]);
              }
            });
            forEach(whens, function(expression, key) {
              whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
            });
            scope.$watch(numberExp, function ngPluralizeWatchAction(newVal) {
              var count = parseFloat(newVal);
              var countIsNaN = isNaN(count);
              if (!countIsNaN && !(count in whens)) {
                count = $locale.pluralCat(count - offset);
              }
              if ((count !== lastCount) && !(countIsNaN && isNumber(lastCount) && isNaN(lastCount))) {
                watchRemover();
                var whenExpFn = whensExpFns[count];
                if (isUndefined(whenExpFn)) {
                  if (newVal != null) {
                    $log.debug("ngPluralize: no rule defined for '" + count + "' in " + whenExp);
                  }
                  watchRemover = noop;
                  updateElementText();
                } else {
                  watchRemover = scope.$watch(whenExpFn, updateElementText);
                }
                lastCount = count;
              }
            });
            function updateElementText(newText) {
              element.text(newText || '');
            }
          }};
      }];
      var ngRepeatDirective = ['$parse', '$animate', function($parse, $animate) {
        var NG_REMOVED = '$$NG_REMOVED';
        var ngRepeatMinErr = minErr('ngRepeat');
        var updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
          scope[valueIdentifier] = value;
          if (keyIdentifier)
            scope[keyIdentifier] = key;
          scope.$index = index;
          scope.$first = (index === 0);
          scope.$last = (index === (arrayLength - 1));
          scope.$middle = !(scope.$first || scope.$last);
          scope.$odd = !(scope.$even = (index & 1) === 0);
        };
        var getBlockStart = function(block) {
          return block.clone[0];
        };
        var getBlockEnd = function(block) {
          return block.clone[block.clone.length - 1];
        };
        return {
          restrict: 'A',
          multiElement: true,
          transclude: 'element',
          priority: 1000,
          terminal: true,
          $$tlb: true,
          compile: function ngRepeatCompile($element, $attr) {
            var expression = $attr.ngRepeat;
            var ngRepeatEndComment = document.createComment(' end ngRepeat: ' + expression + ' ');
            var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
            if (!match) {
              throw ngRepeatMinErr('iexp', "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
            }
            var lhs = match[1];
            var rhs = match[2];
            var aliasAs = match[3];
            var trackByExp = match[4];
            match = lhs.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/);
            if (!match) {
              throw ngRepeatMinErr('iidexp', "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
            }
            var valueIdentifier = match[3] || match[1];
            var keyIdentifier = match[2];
            if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) {
              throw ngRepeatMinErr('badident', "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", aliasAs);
            }
            var trackByExpGetter,
                trackByIdExpFn,
                trackByIdArrayFn,
                trackByIdObjFn;
            var hashFnLocals = {$id: hashKey};
            if (trackByExp) {
              trackByExpGetter = $parse(trackByExp);
            } else {
              trackByIdArrayFn = function(key, value) {
                return hashKey(value);
              };
              trackByIdObjFn = function(key) {
                return key;
              };
            }
            return function ngRepeatLink($scope, $element, $attr, ctrl, $transclude) {
              if (trackByExpGetter) {
                trackByIdExpFn = function(key, value, index) {
                  if (keyIdentifier)
                    hashFnLocals[keyIdentifier] = key;
                  hashFnLocals[valueIdentifier] = value;
                  hashFnLocals.$index = index;
                  return trackByExpGetter($scope, hashFnLocals);
                };
              }
              var lastBlockMap = createMap();
              $scope.$watchCollection(rhs, function ngRepeatAction(collection) {
                var index,
                    length,
                    previousNode = $element[0],
                    nextNode,
                    nextBlockMap = createMap(),
                    collectionLength,
                    key,
                    value,
                    trackById,
                    trackByIdFn,
                    collectionKeys,
                    block,
                    nextBlockOrder,
                    elementsToRemove;
                if (aliasAs) {
                  $scope[aliasAs] = collection;
                }
                if (isArrayLike(collection)) {
                  collectionKeys = collection;
                  trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
                } else {
                  trackByIdFn = trackByIdExpFn || trackByIdObjFn;
                  collectionKeys = [];
                  for (var itemKey in collection) {
                    if (hasOwnProperty.call(collection, itemKey) && itemKey.charAt(0) !== '$') {
                      collectionKeys.push(itemKey);
                    }
                  }
                }
                collectionLength = collectionKeys.length;
                nextBlockOrder = new Array(collectionLength);
                for (index = 0; index < collectionLength; index++) {
                  key = (collection === collectionKeys) ? index : collectionKeys[index];
                  value = collection[key];
                  trackById = trackByIdFn(key, value, index);
                  if (lastBlockMap[trackById]) {
                    block = lastBlockMap[trackById];
                    delete lastBlockMap[trackById];
                    nextBlockMap[trackById] = block;
                    nextBlockOrder[index] = block;
                  } else if (nextBlockMap[trackById]) {
                    forEach(nextBlockOrder, function(block) {
                      if (block && block.scope)
                        lastBlockMap[block.id] = block;
                    });
                    throw ngRepeatMinErr('dupes', "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, value);
                  } else {
                    nextBlockOrder[index] = {
                      id: trackById,
                      scope: undefined,
                      clone: undefined
                    };
                    nextBlockMap[trackById] = true;
                  }
                }
                for (var blockKey in lastBlockMap) {
                  block = lastBlockMap[blockKey];
                  elementsToRemove = getBlockNodes(block.clone);
                  $animate.leave(elementsToRemove);
                  if (elementsToRemove[0].parentNode) {
                    for (index = 0, length = elementsToRemove.length; index < length; index++) {
                      elementsToRemove[index][NG_REMOVED] = true;
                    }
                  }
                  block.scope.$destroy();
                }
                for (index = 0; index < collectionLength; index++) {
                  key = (collection === collectionKeys) ? index : collectionKeys[index];
                  value = collection[key];
                  block = nextBlockOrder[index];
                  if (block.scope) {
                    nextNode = previousNode;
                    do {
                      nextNode = nextNode.nextSibling;
                    } while (nextNode && nextNode[NG_REMOVED]);
                    if (getBlockStart(block) != nextNode) {
                      $animate.move(getBlockNodes(block.clone), null, jqLite(previousNode));
                    }
                    previousNode = getBlockEnd(block);
                    updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                  } else {
                    $transclude(function ngRepeatTransclude(clone, scope) {
                      block.scope = scope;
                      var endNode = ngRepeatEndComment.cloneNode(false);
                      clone[clone.length++] = endNode;
                      $animate.enter(clone, null, jqLite(previousNode));
                      previousNode = endNode;
                      block.clone = clone;
                      nextBlockMap[block.id] = block;
                      updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                    });
                  }
                }
                lastBlockMap = nextBlockMap;
              });
            };
          }
        };
      }];
      var NG_HIDE_CLASS = 'ng-hide';
      var NG_HIDE_IN_PROGRESS_CLASS = 'ng-hide-animate';
      var ngShowDirective = ['$animate', function($animate) {
        return {
          restrict: 'A',
          multiElement: true,
          link: function(scope, element, attr) {
            scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
              $animate[value ? 'removeClass' : 'addClass'](element, NG_HIDE_CLASS, {tempClasses: NG_HIDE_IN_PROGRESS_CLASS});
            });
          }
        };
      }];
      var ngHideDirective = ['$animate', function($animate) {
        return {
          restrict: 'A',
          multiElement: true,
          link: function(scope, element, attr) {
            scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
              $animate[value ? 'addClass' : 'removeClass'](element, NG_HIDE_CLASS, {tempClasses: NG_HIDE_IN_PROGRESS_CLASS});
            });
          }
        };
      }];
      var ngStyleDirective = ngDirective(function(scope, element, attr) {
        scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
          if (oldStyles && (newStyles !== oldStyles)) {
            forEach(oldStyles, function(val, style) {
              element.css(style, '');
            });
          }
          if (newStyles)
            element.css(newStyles);
        }, true);
      });
      var ngSwitchDirective = ['$animate', function($animate) {
        return {
          require: 'ngSwitch',
          controller: ['$scope', function ngSwitchController() {
            this.cases = {};
          }],
          link: function(scope, element, attr, ngSwitchController) {
            var watchExpr = attr.ngSwitch || attr.on,
                selectedTranscludes = [],
                selectedElements = [],
                previousLeaveAnimations = [],
                selectedScopes = [];
            var spliceFactory = function(array, index) {
              return function() {
                array.splice(index, 1);
              };
            };
            scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
              var i,
                  ii;
              for (i = 0, ii = previousLeaveAnimations.length; i < ii; ++i) {
                $animate.cancel(previousLeaveAnimations[i]);
              }
              previousLeaveAnimations.length = 0;
              for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
                var selected = getBlockNodes(selectedElements[i].clone);
                selectedScopes[i].$destroy();
                var promise = previousLeaveAnimations[i] = $animate.leave(selected);
                promise.then(spliceFactory(previousLeaveAnimations, i));
              }
              selectedElements.length = 0;
              selectedScopes.length = 0;
              if ((selectedTranscludes = ngSwitchController.cases['!' + value] || ngSwitchController.cases['?'])) {
                forEach(selectedTranscludes, function(selectedTransclude) {
                  selectedTransclude.transclude(function(caseElement, selectedScope) {
                    selectedScopes.push(selectedScope);
                    var anchor = selectedTransclude.element;
                    caseElement[caseElement.length++] = document.createComment(' end ngSwitchWhen: ');
                    var block = {clone: caseElement};
                    selectedElements.push(block);
                    $animate.enter(caseElement, anchor.parent(), anchor);
                  });
                });
              }
            });
          }
        };
      }];
      var ngSwitchWhenDirective = ngDirective({
        transclude: 'element',
        priority: 1200,
        require: '^ngSwitch',
        multiElement: true,
        link: function(scope, element, attrs, ctrl, $transclude) {
          ctrl.cases['!' + attrs.ngSwitchWhen] = (ctrl.cases['!' + attrs.ngSwitchWhen] || []);
          ctrl.cases['!' + attrs.ngSwitchWhen].push({
            transclude: $transclude,
            element: element
          });
        }
      });
      var ngSwitchDefaultDirective = ngDirective({
        transclude: 'element',
        priority: 1200,
        require: '^ngSwitch',
        multiElement: true,
        link: function(scope, element, attr, ctrl, $transclude) {
          ctrl.cases['?'] = (ctrl.cases['?'] || []);
          ctrl.cases['?'].push({
            transclude: $transclude,
            element: element
          });
        }
      });
      var ngTranscludeDirective = ngDirective({
        restrict: 'EAC',
        link: function($scope, $element, $attrs, controller, $transclude) {
          if (!$transclude) {
            throw minErr('ngTransclude')('orphan', 'Illegal use of ngTransclude directive in the template! ' + 'No parent directive that requires a transclusion found. ' + 'Element: {0}', startingTag($element));
          }
          $transclude(function(clone) {
            $element.empty();
            $element.append(clone);
          });
        }
      });
      var scriptDirective = ['$templateCache', function($templateCache) {
        return {
          restrict: 'E',
          terminal: true,
          compile: function(element, attr) {
            if (attr.type == 'text/ng-template') {
              var templateUrl = attr.id,
                  text = element[0].text;
              $templateCache.put(templateUrl, text);
            }
          }
        };
      }];
      var noopNgModelController = {
        $setViewValue: noop,
        $render: noop
      };
      function chromeHack(optionElement) {
        if (optionElement[0].hasAttribute('selected')) {
          optionElement[0].selected = true;
        }
      }
      var SelectController = ['$element', '$scope', '$attrs', function($element, $scope, $attrs) {
        var self = this,
            optionsMap = new HashMap();
        self.ngModelCtrl = noopNgModelController;
        self.unknownOption = jqLite(document.createElement('option'));
        self.renderUnknownOption = function(val) {
          var unknownVal = '? ' + hashKey(val) + ' ?';
          self.unknownOption.val(unknownVal);
          $element.prepend(self.unknownOption);
          $element.val(unknownVal);
        };
        $scope.$on('$destroy', function() {
          self.renderUnknownOption = noop;
        });
        self.removeUnknownOption = function() {
          if (self.unknownOption.parent())
            self.unknownOption.remove();
        };
        self.readValue = function readSingleValue() {
          self.removeUnknownOption();
          return $element.val();
        };
        self.writeValue = function writeSingleValue(value) {
          if (self.hasOption(value)) {
            self.removeUnknownOption();
            $element.val(value);
            if (value === '')
              self.emptyOption.prop('selected', true);
          } else {
            if (value == null && self.emptyOption) {
              self.removeUnknownOption();
              $element.val('');
            } else {
              self.renderUnknownOption(value);
            }
          }
        };
        self.addOption = function(value, element) {
          assertNotHasOwnProperty(value, '"option value"');
          if (value === '') {
            self.emptyOption = element;
          }
          var count = optionsMap.get(value) || 0;
          optionsMap.put(value, count + 1);
          self.ngModelCtrl.$render();
          chromeHack(element);
        };
        self.removeOption = function(value) {
          var count = optionsMap.get(value);
          if (count) {
            if (count === 1) {
              optionsMap.remove(value);
              if (value === '') {
                self.emptyOption = undefined;
              }
            } else {
              optionsMap.put(value, count - 1);
            }
          }
        };
        self.hasOption = function(value) {
          return !!optionsMap.get(value);
        };
        self.registerOption = function(optionScope, optionElement, optionAttrs, interpolateValueFn, interpolateTextFn) {
          if (interpolateValueFn) {
            var oldVal;
            optionAttrs.$observe('value', function valueAttributeObserveAction(newVal) {
              if (isDefined(oldVal)) {
                self.removeOption(oldVal);
              }
              oldVal = newVal;
              self.addOption(newVal, optionElement);
            });
          } else if (interpolateTextFn) {
            optionScope.$watch(interpolateTextFn, function interpolateWatchAction(newVal, oldVal) {
              optionAttrs.$set('value', newVal);
              if (oldVal !== newVal) {
                self.removeOption(oldVal);
              }
              self.addOption(newVal, optionElement);
            });
          } else {
            self.addOption(optionAttrs.value, optionElement);
          }
          optionElement.on('$destroy', function() {
            self.removeOption(optionAttrs.value);
            self.ngModelCtrl.$render();
          });
        };
      }];
      var selectDirective = function() {
        return {
          restrict: 'E',
          require: ['select', '?ngModel'],
          controller: SelectController,
          priority: 1,
          link: {pre: selectPreLink}
        };
        function selectPreLink(scope, element, attr, ctrls) {
          var ngModelCtrl = ctrls[1];
          if (!ngModelCtrl)
            return;
          var selectCtrl = ctrls[0];
          selectCtrl.ngModelCtrl = ngModelCtrl;
          ngModelCtrl.$render = function() {
            selectCtrl.writeValue(ngModelCtrl.$viewValue);
          };
          element.on('change', function() {
            scope.$apply(function() {
              ngModelCtrl.$setViewValue(selectCtrl.readValue());
            });
          });
          if (attr.multiple) {
            selectCtrl.readValue = function readMultipleValue() {
              var array = [];
              forEach(element.find('option'), function(option) {
                if (option.selected) {
                  array.push(option.value);
                }
              });
              return array;
            };
            selectCtrl.writeValue = function writeMultipleValue(value) {
              var items = new HashMap(value);
              forEach(element.find('option'), function(option) {
                option.selected = isDefined(items.get(option.value));
              });
            };
            var lastView,
                lastViewRef = NaN;
            scope.$watch(function selectMultipleWatch() {
              if (lastViewRef === ngModelCtrl.$viewValue && !equals(lastView, ngModelCtrl.$viewValue)) {
                lastView = shallowCopy(ngModelCtrl.$viewValue);
                ngModelCtrl.$render();
              }
              lastViewRef = ngModelCtrl.$viewValue;
            });
            ngModelCtrl.$isEmpty = function(value) {
              return !value || value.length === 0;
            };
          }
        }
      };
      var optionDirective = ['$interpolate', function($interpolate) {
        return {
          restrict: 'E',
          priority: 100,
          compile: function(element, attr) {
            if (isDefined(attr.value)) {
              var interpolateValueFn = $interpolate(attr.value, true);
            } else {
              var interpolateTextFn = $interpolate(element.text(), true);
              if (!interpolateTextFn) {
                attr.$set('value', element.text());
              }
            }
            return function(scope, element, attr) {
              var selectCtrlName = '$selectController',
                  parent = element.parent(),
                  selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
              if (selectCtrl) {
                selectCtrl.registerOption(scope, element, attr, interpolateValueFn, interpolateTextFn);
              }
            };
          }
        };
      }];
      var styleDirective = valueFn({
        restrict: 'E',
        terminal: false
      });
      var requiredDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            attr.required = true;
            ctrl.$validators.required = function(modelValue, viewValue) {
              return !attr.required || !ctrl.$isEmpty(viewValue);
            };
            attr.$observe('required', function() {
              ctrl.$validate();
            });
          }
        };
      };
      var patternDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            var regexp,
                patternExp = attr.ngPattern || attr.pattern;
            attr.$observe('pattern', function(regex) {
              if (isString(regex) && regex.length > 0) {
                regex = new RegExp('^' + regex + '$');
              }
              if (regex && !regex.test) {
                throw minErr('ngPattern')('noregexp', 'Expected {0} to be a RegExp but was {1}. Element: {2}', patternExp, regex, startingTag(elm));
              }
              regexp = regex || undefined;
              ctrl.$validate();
            });
            ctrl.$validators.pattern = function(modelValue, viewValue) {
              return ctrl.$isEmpty(viewValue) || isUndefined(regexp) || regexp.test(viewValue);
            };
          }
        };
      };
      var maxlengthDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            var maxlength = -1;
            attr.$observe('maxlength', function(value) {
              var intVal = toInt(value);
              maxlength = isNaN(intVal) ? -1 : intVal;
              ctrl.$validate();
            });
            ctrl.$validators.maxlength = function(modelValue, viewValue) {
              return (maxlength < 0) || ctrl.$isEmpty(viewValue) || (viewValue.length <= maxlength);
            };
          }
        };
      };
      var minlengthDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            var minlength = 0;
            attr.$observe('minlength', function(value) {
              minlength = toInt(value) || 0;
              ctrl.$validate();
            });
            ctrl.$validators.minlength = function(modelValue, viewValue) {
              return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
            };
          }
        };
      };
      if (window.angular.bootstrap) {
        console.log('WARNING: Tried to load angular more than once.');
        return;
      }
      bindJQuery();
      publishExternalAPI(angular);
      angular.module("ngLocale", [], ["$provide", function($provide) {
        var PLURAL_CATEGORY = {
          ZERO: "zero",
          ONE: "one",
          TWO: "two",
          FEW: "few",
          MANY: "many",
          OTHER: "other"
        };
        function getDecimals(n) {
          n = n + '';
          var i = n.indexOf('.');
          return (i == -1) ? 0 : n.length - i - 1;
        }
        function getVF(n, opt_precision) {
          var v = opt_precision;
          if (undefined === v) {
            v = Math.min(getDecimals(n), 3);
          }
          var base = Math.pow(10, v);
          var f = ((n * base) | 0) % base;
          return {
            v: v,
            f: f
          };
        }
        $provide.value("$locale", {
          "DATETIME_FORMATS": {
            "AMPMS": ["AM", "PM"],
            "DAY": ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            "ERANAMES": ["Before Christ", "Anno Domini"],
            "ERAS": ["BC", "AD"],
            "FIRSTDAYOFWEEK": 6,
            "MONTH": ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            "SHORTDAY": ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            "SHORTMONTH": ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            "WEEKENDRANGE": [5, 6],
            "fullDate": "EEEE, MMMM d, y",
            "longDate": "MMMM d, y",
            "medium": "MMM d, y h:mm:ss a",
            "mediumDate": "MMM d, y",
            "mediumTime": "h:mm:ss a",
            "short": "M/d/yy h:mm a",
            "shortDate": "M/d/yy",
            "shortTime": "h:mm a"
          },
          "NUMBER_FORMATS": {
            "CURRENCY_SYM": "$",
            "DECIMAL_SEP": ".",
            "GROUP_SEP": ",",
            "PATTERNS": [{
              "gSize": 3,
              "lgSize": 3,
              "maxFrac": 3,
              "minFrac": 0,
              "minInt": 1,
              "negPre": "-",
              "negSuf": "",
              "posPre": "",
              "posSuf": ""
            }, {
              "gSize": 3,
              "lgSize": 3,
              "maxFrac": 2,
              "minFrac": 2,
              "minInt": 1,
              "negPre": "-\u00a4",
              "negSuf": "",
              "posPre": "\u00a4",
              "posSuf": ""
            }]
          },
          "id": "en-us",
          "pluralCat": function(n, opt_precision) {
            var i = n | 0;
            var vf = getVF(n, opt_precision);
            if (i == 1 && vf.v == 0) {
              return PLURAL_CATEGORY.ONE;
            }
            return PLURAL_CATEGORY.OTHER;
          }
        });
      }]);
      jqLite(document).ready(function() {
        angularInit(document, bootstrap);
      });
    })(window, document);
    !window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');
  })();
  return _retrieveGlobal();
});

System.registerDynamic("github:angular/bower-angular@1.4.8", ["github:angular/bower-angular@1.4.8/angular"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('github:angular/bower-angular@1.4.8/angular');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:angular-ui/ui-router@0.2.15/angular-ui-router", ["angular"], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {
    "format global";
    "deps angular";
    if (typeof module !== "undefined" && typeof exports !== "undefined" && module.exports === exports) {
      module.exports = 'ui.router';
    }
    (function(window, angular, undefined) {
      'use strict';
      var isDefined = angular.isDefined,
          isFunction = angular.isFunction,
          isString = angular.isString,
          isObject = angular.isObject,
          isArray = angular.isArray,
          forEach = angular.forEach,
          extend = angular.extend,
          copy = angular.copy;
      function inherit(parent, extra) {
        return extend(new (extend(function() {}, {prototype: parent}))(), extra);
      }
      function merge(dst) {
        forEach(arguments, function(obj) {
          if (obj !== dst) {
            forEach(obj, function(value, key) {
              if (!dst.hasOwnProperty(key))
                dst[key] = value;
            });
          }
        });
        return dst;
      }
      function ancestors(first, second) {
        var path = [];
        for (var n in first.path) {
          if (first.path[n] !== second.path[n])
            break;
          path.push(first.path[n]);
        }
        return path;
      }
      function objectKeys(object) {
        if (Object.keys) {
          return Object.keys(object);
        }
        var result = [];
        forEach(object, function(val, key) {
          result.push(key);
        });
        return result;
      }
      function indexOf(array, value) {
        if (Array.prototype.indexOf) {
          return array.indexOf(value, Number(arguments[2]) || 0);
        }
        var len = array.length >>> 0,
            from = Number(arguments[2]) || 0;
        from = (from < 0) ? Math.ceil(from) : Math.floor(from);
        if (from < 0)
          from += len;
        for (; from < len; from++) {
          if (from in array && array[from] === value)
            return from;
        }
        return -1;
      }
      function inheritParams(currentParams, newParams, $current, $to) {
        var parents = ancestors($current, $to),
            parentParams,
            inherited = {},
            inheritList = [];
        for (var i in parents) {
          if (!parents[i].params)
            continue;
          parentParams = objectKeys(parents[i].params);
          if (!parentParams.length)
            continue;
          for (var j in parentParams) {
            if (indexOf(inheritList, parentParams[j]) >= 0)
              continue;
            inheritList.push(parentParams[j]);
            inherited[parentParams[j]] = currentParams[parentParams[j]];
          }
        }
        return extend({}, inherited, newParams);
      }
      function equalForKeys(a, b, keys) {
        if (!keys) {
          keys = [];
          for (var n in a)
            keys.push(n);
        }
        for (var i = 0; i < keys.length; i++) {
          var k = keys[i];
          if (a[k] != b[k])
            return false;
        }
        return true;
      }
      function filterByKeys(keys, values) {
        var filtered = {};
        forEach(keys, function(name) {
          filtered[name] = values[name];
        });
        return filtered;
      }
      function indexBy(array, propName) {
        var result = {};
        forEach(array, function(item) {
          result[item[propName]] = item;
        });
        return result;
      }
      function pick(obj) {
        var copy = {};
        var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        forEach(keys, function(key) {
          if (key in obj)
            copy[key] = obj[key];
        });
        return copy;
      }
      function omit(obj) {
        var copy = {};
        var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        for (var key in obj) {
          if (indexOf(keys, key) == -1)
            copy[key] = obj[key];
        }
        return copy;
      }
      function pluck(collection, key) {
        var result = isArray(collection) ? [] : {};
        forEach(collection, function(val, i) {
          result[i] = isFunction(key) ? key(val) : val[key];
        });
        return result;
      }
      function filter(collection, callback) {
        var array = isArray(collection);
        var result = array ? [] : {};
        forEach(collection, function(val, i) {
          if (callback(val, i)) {
            result[array ? result.length : i] = val;
          }
        });
        return result;
      }
      function map(collection, callback) {
        var result = isArray(collection) ? [] : {};
        forEach(collection, function(val, i) {
          result[i] = callback(val, i);
        });
        return result;
      }
      angular.module('ui.router.util', ['ng']);
      angular.module('ui.router.router', ['ui.router.util']);
      angular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);
      angular.module('ui.router', ['ui.router.state']);
      angular.module('ui.router.compat', ['ui.router']);
      $Resolve.$inject = ['$q', '$injector'];
      function $Resolve($q, $injector) {
        var VISIT_IN_PROGRESS = 1,
            VISIT_DONE = 2,
            NOTHING = {},
            NO_DEPENDENCIES = [],
            NO_LOCALS = NOTHING,
            NO_PARENT = extend($q.when(NOTHING), {
              $$promises: NOTHING,
              $$values: NOTHING
            });
        this.study = function(invocables) {
          if (!isObject(invocables))
            throw new Error("'invocables' must be an object");
          var invocableKeys = objectKeys(invocables || {});
          var plan = [],
              cycle = [],
              visited = {};
          function visit(value, key) {
            if (visited[key] === VISIT_DONE)
              return;
            cycle.push(key);
            if (visited[key] === VISIT_IN_PROGRESS) {
              cycle.splice(0, indexOf(cycle, key));
              throw new Error("Cyclic dependency: " + cycle.join(" -> "));
            }
            visited[key] = VISIT_IN_PROGRESS;
            if (isString(value)) {
              plan.push(key, [function() {
                return $injector.get(value);
              }], NO_DEPENDENCIES);
            } else {
              var params = $injector.annotate(value);
              forEach(params, function(param) {
                if (param !== key && invocables.hasOwnProperty(param))
                  visit(invocables[param], param);
              });
              plan.push(key, value, params);
            }
            cycle.pop();
            visited[key] = VISIT_DONE;
          }
          forEach(invocables, visit);
          invocables = cycle = visited = null;
          function isResolve(value) {
            return isObject(value) && value.then && value.$$promises;
          }
          return function(locals, parent, self) {
            if (isResolve(locals) && self === undefined) {
              self = parent;
              parent = locals;
              locals = null;
            }
            if (!locals)
              locals = NO_LOCALS;
            else if (!isObject(locals)) {
              throw new Error("'locals' must be an object");
            }
            if (!parent)
              parent = NO_PARENT;
            else if (!isResolve(parent)) {
              throw new Error("'parent' must be a promise returned by $resolve.resolve()");
            }
            var resolution = $q.defer(),
                result = resolution.promise,
                promises = result.$$promises = {},
                values = extend({}, locals),
                wait = 1 + plan.length / 3,
                merged = false;
            function done() {
              if (!--wait) {
                if (!merged)
                  merge(values, parent.$$values);
                result.$$values = values;
                result.$$promises = result.$$promises || true;
                delete result.$$inheritedValues;
                resolution.resolve(values);
              }
            }
            function fail(reason) {
              result.$$failure = reason;
              resolution.reject(reason);
            }
            if (isDefined(parent.$$failure)) {
              fail(parent.$$failure);
              return result;
            }
            if (parent.$$inheritedValues) {
              merge(values, omit(parent.$$inheritedValues, invocableKeys));
            }
            extend(promises, parent.$$promises);
            if (parent.$$values) {
              merged = merge(values, omit(parent.$$values, invocableKeys));
              result.$$inheritedValues = omit(parent.$$values, invocableKeys);
              done();
            } else {
              if (parent.$$inheritedValues) {
                result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);
              }
              parent.then(done, fail);
            }
            for (var i = 0,
                ii = plan.length; i < ii; i += 3) {
              if (locals.hasOwnProperty(plan[i]))
                done();
              else
                invoke(plan[i], plan[i + 1], plan[i + 2]);
            }
            function invoke(key, invocable, params) {
              var invocation = $q.defer(),
                  waitParams = 0;
              function onfailure(reason) {
                invocation.reject(reason);
                fail(reason);
              }
              forEach(params, function(dep) {
                if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {
                  waitParams++;
                  promises[dep].then(function(result) {
                    values[dep] = result;
                    if (!(--waitParams))
                      proceed();
                  }, onfailure);
                }
              });
              if (!waitParams)
                proceed();
              function proceed() {
                if (isDefined(result.$$failure))
                  return;
                try {
                  invocation.resolve($injector.invoke(invocable, self, values));
                  invocation.promise.then(function(result) {
                    values[key] = result;
                    done();
                  }, onfailure);
                } catch (e) {
                  onfailure(e);
                }
              }
              promises[key] = invocation.promise;
            }
            return result;
          };
        };
        this.resolve = function(invocables, locals, parent, self) {
          return this.study(invocables)(locals, parent, self);
        };
      }
      angular.module('ui.router.util').service('$resolve', $Resolve);
      $TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];
      function $TemplateFactory($http, $templateCache, $injector) {
        this.fromConfig = function(config, params, locals) {
          return (isDefined(config.template) ? this.fromString(config.template, params) : isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) : isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) : null);
        };
        this.fromString = function(template, params) {
          return isFunction(template) ? template(params) : template;
        };
        this.fromUrl = function(url, params) {
          if (isFunction(url))
            url = url(params);
          if (url == null)
            return null;
          else
            return $http.get(url, {
              cache: $templateCache,
              headers: {Accept: 'text/html'}
            }).then(function(response) {
              return response.data;
            });
        };
        this.fromProvider = function(provider, params, locals) {
          return $injector.invoke(provider, null, locals || {params: params});
        };
      }
      angular.module('ui.router.util').service('$templateFactory', $TemplateFactory);
      var $$UMFP;
      function UrlMatcher(pattern, config, parentMatcher) {
        config = extend({params: {}}, isObject(config) ? config : {});
        var placeholder = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
            searchPlaceholder = /([:]?)([\w\[\]-]+)|\{([\w\[\]-]+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
            compiled = '^',
            last = 0,
            m,
            segments = this.segments = [],
            parentParams = parentMatcher ? parentMatcher.params : {},
            params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),
            paramNames = [];
        function addParameter(id, type, config, location) {
          paramNames.push(id);
          if (parentParams[id])
            return parentParams[id];
          if (!/^\w+(-+\w+)*(?:\[\])?$/.test(id))
            throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
          if (params[id])
            throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
          params[id] = new $$UMFP.Param(id, type, config, location);
          return params[id];
        }
        function quoteRegExp(string, pattern, squash, optional) {
          var surroundPattern = ['', ''],
              result = string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
          if (!pattern)
            return result;
          switch (squash) {
            case false:
              surroundPattern = ['(', ')' + (optional ? "?" : "")];
              break;
            case true:
              surroundPattern = ['?(', ')?'];
              break;
            default:
              surroundPattern = ['(' + squash + "|", ')?'];
              break;
          }
          return result + surroundPattern[0] + pattern + surroundPattern[1];
        }
        this.source = pattern;
        function matchDetails(m, isSearch) {
          var id,
              regexp,
              segment,
              type,
              cfg,
              arrayMode;
          id = m[2] || m[3];
          cfg = config.params[id];
          segment = pattern.substring(last, m.index);
          regexp = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);
          type = $$UMFP.type(regexp || "string") || inherit($$UMFP.type("string"), {pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined)});
          return {
            id: id,
            regexp: regexp,
            segment: segment,
            type: type,
            cfg: cfg
          };
        }
        var p,
            param,
            segment;
        while ((m = placeholder.exec(pattern))) {
          p = matchDetails(m, false);
          if (p.segment.indexOf('?') >= 0)
            break;
          param = addParameter(p.id, p.type, p.cfg, "path");
          compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);
          segments.push(p.segment);
          last = placeholder.lastIndex;
        }
        segment = pattern.substring(last);
        var i = segment.indexOf('?');
        if (i >= 0) {
          var search = this.sourceSearch = segment.substring(i);
          segment = segment.substring(0, i);
          this.sourcePath = pattern.substring(0, last + i);
          if (search.length > 0) {
            last = 0;
            while ((m = searchPlaceholder.exec(search))) {
              p = matchDetails(m, true);
              param = addParameter(p.id, p.type, p.cfg, "search");
              last = placeholder.lastIndex;
            }
          }
        } else {
          this.sourcePath = pattern;
          this.sourceSearch = '';
        }
        compiled += quoteRegExp(segment) + (config.strict === false ? '\/?' : '') + '$';
        segments.push(segment);
        this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);
        this.prefix = segments[0];
        this.$$paramNames = paramNames;
      }
      UrlMatcher.prototype.concat = function(pattern, config) {
        var defaultConfig = {
          caseInsensitive: $$UMFP.caseInsensitive(),
          strict: $$UMFP.strictMode(),
          squash: $$UMFP.defaultSquashPolicy()
        };
        return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);
      };
      UrlMatcher.prototype.toString = function() {
        return this.source;
      };
      UrlMatcher.prototype.exec = function(path, searchParams) {
        var m = this.regexp.exec(path);
        if (!m)
          return null;
        searchParams = searchParams || {};
        var paramNames = this.parameters(),
            nTotal = paramNames.length,
            nPath = this.segments.length - 1,
            values = {},
            i,
            j,
            cfg,
            paramName;
        if (nPath !== m.length - 1)
          throw new Error("Unbalanced capture group in route '" + this.source + "'");
        function decodePathArray(string) {
          function reverseString(str) {
            return str.split("").reverse().join("");
          }
          function unquoteDashes(str) {
            return str.replace(/\\-/g, "-");
          }
          var split = reverseString(string).split(/-(?!\\)/);
          var allReversed = map(split, reverseString);
          return map(allReversed, unquoteDashes).reverse();
        }
        for (i = 0; i < nPath; i++) {
          paramName = paramNames[i];
          var param = this.params[paramName];
          var paramVal = m[i + 1];
          for (j = 0; j < param.replace; j++) {
            if (param.replace[j].from === paramVal)
              paramVal = param.replace[j].to;
          }
          if (paramVal && param.array === true)
            paramVal = decodePathArray(paramVal);
          values[paramName] = param.value(paramVal);
        }
        for (; i < nTotal; i++) {
          paramName = paramNames[i];
          values[paramName] = this.params[paramName].value(searchParams[paramName]);
        }
        return values;
      };
      UrlMatcher.prototype.parameters = function(param) {
        if (!isDefined(param))
          return this.$$paramNames;
        return this.params[param] || null;
      };
      UrlMatcher.prototype.validates = function(params) {
        return this.params.$$validates(params);
      };
      UrlMatcher.prototype.format = function(values) {
        values = values || {};
        var segments = this.segments,
            params = this.parameters(),
            paramset = this.params;
        if (!this.validates(values))
          return null;
        var i,
            search = false,
            nPath = segments.length - 1,
            nTotal = params.length,
            result = segments[0];
        function encodeDashes(str) {
          return encodeURIComponent(str).replace(/-/g, function(c) {
            return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase();
          });
        }
        for (i = 0; i < nTotal; i++) {
          var isPathParam = i < nPath;
          var name = params[i],
              param = paramset[name],
              value = param.value(values[name]);
          var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);
          var squash = isDefaultValue ? param.squash : false;
          var encoded = param.type.encode(value);
          if (isPathParam) {
            var nextSegment = segments[i + 1];
            if (squash === false) {
              if (encoded != null) {
                if (isArray(encoded)) {
                  result += map(encoded, encodeDashes).join("-");
                } else {
                  result += encodeURIComponent(encoded);
                }
              }
              result += nextSegment;
            } else if (squash === true) {
              var capture = result.match(/\/$/) ? /\/?(.*)/ : /(.*)/;
              result += nextSegment.match(capture)[1];
            } else if (isString(squash)) {
              result += squash + nextSegment;
            }
          } else {
            if (encoded == null || (isDefaultValue && squash !== false))
              continue;
            if (!isArray(encoded))
              encoded = [encoded];
            encoded = map(encoded, encodeURIComponent).join('&' + name + '=');
            result += (search ? '&' : '?') + (name + '=' + encoded);
            search = true;
          }
        }
        return result;
      };
      function Type(config) {
        extend(this, config);
      }
      Type.prototype.is = function(val, key) {
        return true;
      };
      Type.prototype.encode = function(val, key) {
        return val;
      };
      Type.prototype.decode = function(val, key) {
        return val;
      };
      Type.prototype.equals = function(a, b) {
        return a == b;
      };
      Type.prototype.$subPattern = function() {
        var sub = this.pattern.toString();
        return sub.substr(1, sub.length - 2);
      };
      Type.prototype.pattern = /.*/;
      Type.prototype.toString = function() {
        return "{Type:" + this.name + "}";
      };
      Type.prototype.$normalize = function(val) {
        return this.is(val) ? val : this.decode(val);
      };
      Type.prototype.$asArray = function(mode, isSearch) {
        if (!mode)
          return this;
        if (mode === "auto" && !isSearch)
          throw new Error("'auto' array mode is for query parameters only");
        function ArrayType(type, mode) {
          function bindTo(type, callbackName) {
            return function() {
              return type[callbackName].apply(type, arguments);
            };
          }
          function arrayWrap(val) {
            return isArray(val) ? val : (isDefined(val) ? [val] : []);
          }
          function arrayUnwrap(val) {
            switch (val.length) {
              case 0:
                return undefined;
              case 1:
                return mode === "auto" ? val[0] : val;
              default:
                return val;
            }
          }
          function falsey(val) {
            return !val;
          }
          function arrayHandler(callback, allTruthyMode) {
            return function handleArray(val) {
              val = arrayWrap(val);
              var result = map(val, callback);
              if (allTruthyMode === true)
                return filter(result, falsey).length === 0;
              return arrayUnwrap(result);
            };
          }
          function arrayEqualsHandler(callback) {
            return function handleArray(val1, val2) {
              var left = arrayWrap(val1),
                  right = arrayWrap(val2);
              if (left.length !== right.length)
                return false;
              for (var i = 0; i < left.length; i++) {
                if (!callback(left[i], right[i]))
                  return false;
              }
              return true;
            };
          }
          this.encode = arrayHandler(bindTo(type, 'encode'));
          this.decode = arrayHandler(bindTo(type, 'decode'));
          this.is = arrayHandler(bindTo(type, 'is'), true);
          this.equals = arrayEqualsHandler(bindTo(type, 'equals'));
          this.pattern = type.pattern;
          this.$normalize = arrayHandler(bindTo(type, '$normalize'));
          this.name = type.name;
          this.$arrayMode = mode;
        }
        return new ArrayType(this, mode);
      };
      function $UrlMatcherFactory() {
        $$UMFP = this;
        var isCaseInsensitive = false,
            isStrictMode = true,
            defaultSquashPolicy = false;
        function valToString(val) {
          return val != null ? val.toString().replace(/\//g, "%2F") : val;
        }
        function valFromString(val) {
          return val != null ? val.toString().replace(/%2F/g, "/") : val;
        }
        var $types = {},
            enqueue = true,
            typeQueue = [],
            injector,
            defaultTypes = {
              string: {
                encode: valToString,
                decode: valFromString,
                is: function(val) {
                  return val == null || !isDefined(val) || typeof val === "string";
                },
                pattern: /[^/]*/
              },
              int: {
                encode: valToString,
                decode: function(val) {
                  return parseInt(val, 10);
                },
                is: function(val) {
                  return isDefined(val) && this.decode(val.toString()) === val;
                },
                pattern: /\d+/
              },
              bool: {
                encode: function(val) {
                  return val ? 1 : 0;
                },
                decode: function(val) {
                  return parseInt(val, 10) !== 0;
                },
                is: function(val) {
                  return val === true || val === false;
                },
                pattern: /0|1/
              },
              date: {
                encode: function(val) {
                  if (!this.is(val))
                    return undefined;
                  return [val.getFullYear(), ('0' + (val.getMonth() + 1)).slice(-2), ('0' + val.getDate()).slice(-2)].join("-");
                },
                decode: function(val) {
                  if (this.is(val))
                    return val;
                  var match = this.capture.exec(val);
                  return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
                },
                is: function(val) {
                  return val instanceof Date && !isNaN(val.valueOf());
                },
                equals: function(a, b) {
                  return this.is(a) && this.is(b) && a.toISOString() === b.toISOString();
                },
                pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
                capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
              },
              json: {
                encode: angular.toJson,
                decode: angular.fromJson,
                is: angular.isObject,
                equals: angular.equals,
                pattern: /[^/]*/
              },
              any: {
                encode: angular.identity,
                decode: angular.identity,
                equals: angular.equals,
                pattern: /.*/
              }
            };
        function getDefaultConfig() {
          return {
            strict: isStrictMode,
            caseInsensitive: isCaseInsensitive
          };
        }
        function isInjectable(value) {
          return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));
        }
        $UrlMatcherFactory.$$getDefaultValue = function(config) {
          if (!isInjectable(config.value))
            return config.value;
          if (!injector)
            throw new Error("Injectable functions cannot be called at configuration time");
          return injector.invoke(config.value);
        };
        this.caseInsensitive = function(value) {
          if (isDefined(value))
            isCaseInsensitive = value;
          return isCaseInsensitive;
        };
        this.strictMode = function(value) {
          if (isDefined(value))
            isStrictMode = value;
          return isStrictMode;
        };
        this.defaultSquashPolicy = function(value) {
          if (!isDefined(value))
            return defaultSquashPolicy;
          if (value !== true && value !== false && !isString(value))
            throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");
          defaultSquashPolicy = value;
          return value;
        };
        this.compile = function(pattern, config) {
          return new UrlMatcher(pattern, extend(getDefaultConfig(), config));
        };
        this.isMatcher = function(o) {
          if (!isObject(o))
            return false;
          var result = true;
          forEach(UrlMatcher.prototype, function(val, name) {
            if (isFunction(val)) {
              result = result && (isDefined(o[name]) && isFunction(o[name]));
            }
          });
          return result;
        };
        this.type = function(name, definition, definitionFn) {
          if (!isDefined(definition))
            return $types[name];
          if ($types.hasOwnProperty(name))
            throw new Error("A type named '" + name + "' has already been defined.");
          $types[name] = new Type(extend({name: name}, definition));
          if (definitionFn) {
            typeQueue.push({
              name: name,
              def: definitionFn
            });
            if (!enqueue)
              flushTypeQueue();
          }
          return this;
        };
        function flushTypeQueue() {
          while (typeQueue.length) {
            var type = typeQueue.shift();
            if (type.pattern)
              throw new Error("You cannot override a type's .pattern at runtime.");
            angular.extend($types[type.name], injector.invoke(type.def));
          }
        }
        forEach(defaultTypes, function(type, name) {
          $types[name] = new Type(extend({name: name}, type));
        });
        $types = inherit($types, {});
        this.$get = ['$injector', function($injector) {
          injector = $injector;
          enqueue = false;
          flushTypeQueue();
          forEach(defaultTypes, function(type, name) {
            if (!$types[name])
              $types[name] = new Type(type);
          });
          return this;
        }];
        this.Param = function Param(id, type, config, location) {
          var self = this;
          config = unwrapShorthand(config);
          type = getType(config, type, location);
          var arrayMode = getArrayMode();
          type = arrayMode ? type.$asArray(arrayMode, location === "search") : type;
          if (type.name === "string" && !arrayMode && location === "path" && config.value === undefined)
            config.value = "";
          var isOptional = config.value !== undefined;
          var squash = getSquashPolicy(config, isOptional);
          var replace = getReplace(config, arrayMode, isOptional, squash);
          function unwrapShorthand(config) {
            var keys = isObject(config) ? objectKeys(config) : [];
            var isShorthand = indexOf(keys, "value") === -1 && indexOf(keys, "type") === -1 && indexOf(keys, "squash") === -1 && indexOf(keys, "array") === -1;
            if (isShorthand)
              config = {value: config};
            config.$$fn = isInjectable(config.value) ? config.value : function() {
              return config.value;
            };
            return config;
          }
          function getType(config, urlType, location) {
            if (config.type && urlType)
              throw new Error("Param '" + id + "' has two type configurations.");
            if (urlType)
              return urlType;
            if (!config.type)
              return (location === "config" ? $types.any : $types.string);
            return config.type instanceof Type ? config.type : new Type(config.type);
          }
          function getArrayMode() {
            var arrayDefaults = {array: (location === "search" ? "auto" : false)};
            var arrayParamNomenclature = id.match(/\[\]$/) ? {array: true} : {};
            return extend(arrayDefaults, arrayParamNomenclature, config).array;
          }
          function getSquashPolicy(config, isOptional) {
            var squash = config.squash;
            if (!isOptional || squash === false)
              return false;
            if (!isDefined(squash) || squash == null)
              return defaultSquashPolicy;
            if (squash === true || isString(squash))
              return squash;
            throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string");
          }
          function getReplace(config, arrayMode, isOptional, squash) {
            var replace,
                configuredKeys,
                defaultPolicy = [{
                  from: "",
                  to: (isOptional || arrayMode ? undefined : "")
                }, {
                  from: null,
                  to: (isOptional || arrayMode ? undefined : "")
                }];
            replace = isArray(config.replace) ? config.replace : [];
            if (isString(squash))
              replace.push({
                from: squash,
                to: undefined
              });
            configuredKeys = map(replace, function(item) {
              return item.from;
            });
            return filter(defaultPolicy, function(item) {
              return indexOf(configuredKeys, item.from) === -1;
            }).concat(replace);
          }
          function $$getDefaultValue() {
            if (!injector)
              throw new Error("Injectable functions cannot be called at configuration time");
            var defaultValue = injector.invoke(config.$$fn);
            if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))
              throw new Error("Default value (" + defaultValue + ") for parameter '" + self.id + "' is not an instance of Type (" + self.type.name + ")");
            return defaultValue;
          }
          function $value(value) {
            function hasReplaceVal(val) {
              return function(obj) {
                return obj.from === val;
              };
            }
            function $replace(value) {
              var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) {
                return obj.to;
              });
              return replacement.length ? replacement[0] : value;
            }
            value = $replace(value);
            return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);
          }
          function toString() {
            return "{Param:" + id + " " + type + " squash: '" + squash + "' optional: " + isOptional + "}";
          }
          extend(this, {
            id: id,
            type: type,
            location: location,
            array: arrayMode,
            squash: squash,
            replace: replace,
            isOptional: isOptional,
            value: $value,
            dynamic: undefined,
            config: config,
            toString: toString
          });
        };
        function ParamSet(params) {
          extend(this, params || {});
        }
        ParamSet.prototype = {
          $$new: function() {
            return inherit(this, extend(new ParamSet(), {$$parent: this}));
          },
          $$keys: function() {
            var keys = [],
                chain = [],
                parent = this,
                ignore = objectKeys(ParamSet.prototype);
            while (parent) {
              chain.push(parent);
              parent = parent.$$parent;
            }
            chain.reverse();
            forEach(chain, function(paramset) {
              forEach(objectKeys(paramset), function(key) {
                if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1)
                  keys.push(key);
              });
            });
            return keys;
          },
          $$values: function(paramValues) {
            var values = {},
                self = this;
            forEach(self.$$keys(), function(key) {
              values[key] = self[key].value(paramValues && paramValues[key]);
            });
            return values;
          },
          $$equals: function(paramValues1, paramValues2) {
            var equal = true,
                self = this;
            forEach(self.$$keys(), function(key) {
              var left = paramValues1 && paramValues1[key],
                  right = paramValues2 && paramValues2[key];
              if (!self[key].type.equals(left, right))
                equal = false;
            });
            return equal;
          },
          $$validates: function $$validate(paramValues) {
            var keys = this.$$keys(),
                i,
                param,
                rawVal,
                normalized,
                encoded;
            for (i = 0; i < keys.length; i++) {
              param = this[keys[i]];
              rawVal = paramValues[keys[i]];
              if ((rawVal === undefined || rawVal === null) && param.isOptional)
                break;
              normalized = param.type.$normalize(rawVal);
              if (!param.type.is(normalized))
                return false;
              encoded = param.type.encode(normalized);
              if (angular.isString(encoded) && !param.type.pattern.exec(encoded))
                return false;
            }
            return true;
          },
          $$parent: undefined
        };
        this.ParamSet = ParamSet;
      }
      angular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);
      angular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) {}]);
      $UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];
      function $UrlRouterProvider($locationProvider, $urlMatcherFactory) {
        var rules = [],
            otherwise = null,
            interceptDeferred = false,
            listener;
        function regExpPrefix(re) {
          var prefix = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(re.source);
          return (prefix != null) ? prefix[1].replace(/\\(.)/g, "$1") : '';
        }
        function interpolate(pattern, match) {
          return pattern.replace(/\$(\$|\d{1,2})/, function(m, what) {
            return match[what === '$' ? 0 : Number(what)];
          });
        }
        this.rule = function(rule) {
          if (!isFunction(rule))
            throw new Error("'rule' must be a function");
          rules.push(rule);
          return this;
        };
        this.otherwise = function(rule) {
          if (isString(rule)) {
            var redirect = rule;
            rule = function() {
              return redirect;
            };
          } else if (!isFunction(rule))
            throw new Error("'rule' must be a function");
          otherwise = rule;
          return this;
        };
        function handleIfMatch($injector, handler, match) {
          if (!match)
            return false;
          var result = $injector.invoke(handler, handler, {$match: match});
          return isDefined(result) ? result : true;
        }
        this.when = function(what, handler) {
          var redirect,
              handlerIsString = isString(handler);
          if (isString(what))
            what = $urlMatcherFactory.compile(what);
          if (!handlerIsString && !isFunction(handler) && !isArray(handler))
            throw new Error("invalid 'handler' in when()");
          var strategies = {
            matcher: function(what, handler) {
              if (handlerIsString) {
                redirect = $urlMatcherFactory.compile(handler);
                handler = ['$match', function($match) {
                  return redirect.format($match);
                }];
              }
              return extend(function($injector, $location) {
                return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));
              }, {prefix: isString(what.prefix) ? what.prefix : ''});
            },
            regex: function(what, handler) {
              if (what.global || what.sticky)
                throw new Error("when() RegExp must not be global or sticky");
              if (handlerIsString) {
                redirect = handler;
                handler = ['$match', function($match) {
                  return interpolate(redirect, $match);
                }];
              }
              return extend(function($injector, $location) {
                return handleIfMatch($injector, handler, what.exec($location.path()));
              }, {prefix: regExpPrefix(what)});
            }
          };
          var check = {
            matcher: $urlMatcherFactory.isMatcher(what),
            regex: what instanceof RegExp
          };
          for (var n in check) {
            if (check[n])
              return this.rule(strategies[n](what, handler));
          }
          throw new Error("invalid 'what' in when()");
        };
        this.deferIntercept = function(defer) {
          if (defer === undefined)
            defer = true;
          interceptDeferred = defer;
        };
        this.$get = $get;
        $get.$inject = ['$location', '$rootScope', '$injector', '$browser'];
        function $get($location, $rootScope, $injector, $browser) {
          var baseHref = $browser.baseHref(),
              location = $location.url(),
              lastPushedUrl;
          function appendBasePath(url, isHtml5, absolute) {
            if (baseHref === '/')
              return url;
            if (isHtml5)
              return baseHref.slice(0, -1) + url;
            if (absolute)
              return baseHref.slice(1) + url;
            return url;
          }
          function update(evt) {
            if (evt && evt.defaultPrevented)
              return;
            var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;
            lastPushedUrl = undefined;
            function check(rule) {
              var handled = rule($injector, $location);
              if (!handled)
                return false;
              if (isString(handled))
                $location.replace().url(handled);
              return true;
            }
            var n = rules.length,
                i;
            for (i = 0; i < n; i++) {
              if (check(rules[i]))
                return;
            }
            if (otherwise)
              check(otherwise);
          }
          function listen() {
            listener = listener || $rootScope.$on('$locationChangeSuccess', update);
            return listener;
          }
          if (!interceptDeferred)
            listen();
          return {
            sync: function() {
              update();
            },
            listen: function() {
              return listen();
            },
            update: function(read) {
              if (read) {
                location = $location.url();
                return;
              }
              if ($location.url() === location)
                return;
              $location.url(location);
              $location.replace();
            },
            push: function(urlMatcher, params, options) {
              var url = urlMatcher.format(params || {});
              if (url !== null && params && params['#']) {
                url += '#' + params['#'];
              }
              $location.url(url);
              lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;
              if (options && options.replace)
                $location.replace();
            },
            href: function(urlMatcher, params, options) {
              if (!urlMatcher.validates(params))
                return null;
              var isHtml5 = $locationProvider.html5Mode();
              if (angular.isObject(isHtml5)) {
                isHtml5 = isHtml5.enabled;
              }
              var url = urlMatcher.format(params);
              options = options || {};
              if (!isHtml5 && url !== null) {
                url = "#" + $locationProvider.hashPrefix() + url;
              }
              if (url !== null && params && params['#']) {
                url += '#' + params['#'];
              }
              url = appendBasePath(url, isHtml5, options.absolute);
              if (!options.absolute || !url) {
                return url;
              }
              var slash = (!isHtml5 && url ? '/' : ''),
                  port = $location.port();
              port = (port === 80 || port === 443 ? '' : ':' + port);
              return [$location.protocol(), '://', $location.host(), port, slash, url].join('');
            }
          };
        }
      }
      angular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);
      $StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];
      function $StateProvider($urlRouterProvider, $urlMatcherFactory) {
        var root,
            states = {},
            $state,
            queue = {},
            abstractKey = 'abstract';
        var stateBuilder = {
          parent: function(state) {
            if (isDefined(state.parent) && state.parent)
              return findState(state.parent);
            var compositeName = /^(.+)\.[^.]+$/.exec(state.name);
            return compositeName ? findState(compositeName[1]) : root;
          },
          data: function(state) {
            if (state.parent && state.parent.data) {
              state.data = state.self.data = extend({}, state.parent.data, state.data);
            }
            return state.data;
          },
          url: function(state) {
            var url = state.url,
                config = {params: state.params || {}};
            if (isString(url)) {
              if (url.charAt(0) == '^')
                return $urlMatcherFactory.compile(url.substring(1), config);
              return (state.parent.navigable || root).url.concat(url, config);
            }
            if (!url || $urlMatcherFactory.isMatcher(url))
              return url;
            throw new Error("Invalid url '" + url + "' in state '" + state + "'");
          },
          navigable: function(state) {
            return state.url ? state : (state.parent ? state.parent.navigable : null);
          },
          ownParams: function(state) {
            var params = state.url && state.url.params || new $$UMFP.ParamSet();
            forEach(state.params || {}, function(config, id) {
              if (!params[id])
                params[id] = new $$UMFP.Param(id, null, config, "config");
            });
            return params;
          },
          params: function(state) {
            return state.parent && state.parent.params ? extend(state.parent.params.$$new(), state.ownParams) : new $$UMFP.ParamSet();
          },
          views: function(state) {
            var views = {};
            forEach(isDefined(state.views) ? state.views : {'': state}, function(view, name) {
              if (name.indexOf('@') < 0)
                name += '@' + state.parent.name;
              views[name] = view;
            });
            return views;
          },
          path: function(state) {
            return state.parent ? state.parent.path.concat(state) : [];
          },
          includes: function(state) {
            var includes = state.parent ? extend({}, state.parent.includes) : {};
            includes[state.name] = true;
            return includes;
          },
          $delegates: {}
        };
        function isRelative(stateName) {
          return stateName.indexOf(".") === 0 || stateName.indexOf("^") === 0;
        }
        function findState(stateOrName, base) {
          if (!stateOrName)
            return undefined;
          var isStr = isString(stateOrName),
              name = isStr ? stateOrName : stateOrName.name,
              path = isRelative(name);
          if (path) {
            if (!base)
              throw new Error("No reference point given for path '" + name + "'");
            base = findState(base);
            var rel = name.split("."),
                i = 0,
                pathLength = rel.length,
                current = base;
            for (; i < pathLength; i++) {
              if (rel[i] === "" && i === 0) {
                current = base;
                continue;
              }
              if (rel[i] === "^") {
                if (!current.parent)
                  throw new Error("Path '" + name + "' not valid for state '" + base.name + "'");
                current = current.parent;
                continue;
              }
              break;
            }
            rel = rel.slice(i).join(".");
            name = current.name + (current.name && rel ? "." : "") + rel;
          }
          var state = states[name];
          if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {
            return state;
          }
          return undefined;
        }
        function queueState(parentName, state) {
          if (!queue[parentName]) {
            queue[parentName] = [];
          }
          queue[parentName].push(state);
        }
        function flushQueuedChildren(parentName) {
          var queued = queue[parentName] || [];
          while (queued.length) {
            registerState(queued.shift());
          }
        }
        function registerState(state) {
          state = inherit(state, {
            self: state,
            resolve: state.resolve || {},
            toString: function() {
              return this.name;
            }
          });
          var name = state.name;
          if (!isString(name) || name.indexOf('@') >= 0)
            throw new Error("State must have a valid name");
          if (states.hasOwnProperty(name))
            throw new Error("State '" + name + "'' is already defined");
          var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.')) : (isString(state.parent)) ? state.parent : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name : '';
          if (parentName && !states[parentName]) {
            return queueState(parentName, state.self);
          }
          for (var key in stateBuilder) {
            if (isFunction(stateBuilder[key]))
              state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);
          }
          states[name] = state;
          if (!state[abstractKey] && state.url) {
            $urlRouterProvider.when(state.url, ['$match', '$stateParams', function($match, $stateParams) {
              if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {
                $state.transitionTo(state, $match, {
                  inherit: true,
                  location: false
                });
              }
            }]);
          }
          flushQueuedChildren(name);
          return state;
        }
        function isGlob(text) {
          return text.indexOf('*') > -1;
        }
        function doesStateMatchGlob(glob) {
          var globSegments = glob.split('.'),
              segments = $state.$current.name.split('.');
          for (var i = 0,
              l = globSegments.length; i < l; i++) {
            if (globSegments[i] === '*') {
              segments[i] = '*';
            }
          }
          if (globSegments[0] === '**') {
            segments = segments.slice(indexOf(segments, globSegments[1]));
            segments.unshift('**');
          }
          if (globSegments[globSegments.length - 1] === '**') {
            segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);
            segments.push('**');
          }
          if (globSegments.length != segments.length) {
            return false;
          }
          return segments.join('') === globSegments.join('');
        }
        root = registerState({
          name: '',
          url: '^',
          views: null,
          'abstract': true
        });
        root.navigable = null;
        this.decorator = decorator;
        function decorator(name, func) {
          if (isString(name) && !isDefined(func)) {
            return stateBuilder[name];
          }
          if (!isFunction(func) || !isString(name)) {
            return this;
          }
          if (stateBuilder[name] && !stateBuilder.$delegates[name]) {
            stateBuilder.$delegates[name] = stateBuilder[name];
          }
          stateBuilder[name] = func;
          return this;
        }
        this.state = state;
        function state(name, definition) {
          if (isObject(name))
            definition = name;
          else
            definition.name = name;
          registerState(definition);
          return this;
        }
        this.$get = $get;
        $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];
        function $get($rootScope, $q, $view, $injector, $resolve, $stateParams, $urlRouter, $location, $urlMatcherFactory) {
          var TransitionSuperseded = $q.reject(new Error('transition superseded'));
          var TransitionPrevented = $q.reject(new Error('transition prevented'));
          var TransitionAborted = $q.reject(new Error('transition aborted'));
          var TransitionFailed = $q.reject(new Error('transition failed'));
          function handleRedirect(redirect, state, params, options) {
            var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);
            if (evt.defaultPrevented) {
              $urlRouter.update();
              return TransitionAborted;
            }
            if (!evt.retry) {
              return null;
            }
            if (options.$retry) {
              $urlRouter.update();
              return TransitionFailed;
            }
            var retryTransition = $state.transition = $q.when(evt.retry);
            retryTransition.then(function() {
              if (retryTransition !== $state.transition)
                return TransitionSuperseded;
              redirect.options.$retry = true;
              return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);
            }, function() {
              return TransitionAborted;
            });
            $urlRouter.update();
            return retryTransition;
          }
          root.locals = {
            resolve: null,
            globals: {$stateParams: {}}
          };
          $state = {
            params: {},
            current: root.self,
            $current: root,
            transition: null
          };
          $state.reload = function reload(state) {
            return $state.transitionTo($state.current, $stateParams, {
              reload: state || true,
              inherit: false,
              notify: true
            });
          };
          $state.go = function go(to, params, options) {
            return $state.transitionTo(to, params, extend({
              inherit: true,
              relative: $state.$current
            }, options));
          };
          $state.transitionTo = function transitionTo(to, toParams, options) {
            toParams = toParams || {};
            options = extend({
              location: true,
              inherit: false,
              relative: null,
              notify: true,
              reload: false,
              $retry: false
            }, options || {});
            var from = $state.$current,
                fromParams = $state.params,
                fromPath = from.path;
            var evt,
                toState = findState(to, options.relative);
            var hash = toParams['#'];
            if (!isDefined(toState)) {
              var redirect = {
                to: to,
                toParams: toParams,
                options: options
              };
              var redirectResult = handleRedirect(redirect, from.self, fromParams, options);
              if (redirectResult) {
                return redirectResult;
              }
              to = redirect.to;
              toParams = redirect.toParams;
              options = redirect.options;
              toState = findState(to, options.relative);
              if (!isDefined(toState)) {
                if (!options.relative)
                  throw new Error("No such state '" + to + "'");
                throw new Error("Could not resolve '" + to + "' from state '" + options.relative + "'");
              }
            }
            if (toState[abstractKey])
              throw new Error("Cannot transition to abstract state '" + to + "'");
            if (options.inherit)
              toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);
            if (!toState.params.$$validates(toParams))
              return TransitionFailed;
            toParams = toState.params.$$values(toParams);
            to = toState;
            var toPath = to.path;
            var keep = 0,
                state = toPath[keep],
                locals = root.locals,
                toLocals = [];
            if (!options.reload) {
              while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {
                locals = toLocals[keep] = state.locals;
                keep++;
                state = toPath[keep];
              }
            } else if (isString(options.reload) || isObject(options.reload)) {
              if (isObject(options.reload) && !options.reload.name) {
                throw new Error('Invalid reload state object');
              }
              var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);
              if (options.reload && !reloadState) {
                throw new Error("No such reload state '" + (isString(options.reload) ? options.reload : options.reload.name) + "'");
              }
              while (state && state === fromPath[keep] && state !== reloadState) {
                locals = toLocals[keep] = state.locals;
                keep++;
                state = toPath[keep];
              }
            }
            if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {
              if (hash)
                toParams['#'] = hash;
              $state.params = toParams;
              copy($state.params, $stateParams);
              if (options.location && to.navigable && to.navigable.url) {
                $urlRouter.push(to.navigable.url, toParams, {
                  $$avoidResync: true,
                  replace: options.location === 'replace'
                });
                $urlRouter.update(true);
              }
              $state.transition = null;
              return $q.when($state.current);
            }
            toParams = filterByKeys(to.params.$$keys(), toParams || {});
            if (options.notify) {
              if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams).defaultPrevented) {
                $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);
                $urlRouter.update();
                return TransitionPrevented;
              }
            }
            var resolved = $q.when(locals);
            for (var l = keep; l < toPath.length; l++, state = toPath[l]) {
              locals = toLocals[l] = inherit(locals);
              resolved = resolveState(state, toParams, state === to, resolved, locals, options);
            }
            var transition = $state.transition = resolved.then(function() {
              var l,
                  entering,
                  exiting;
              if ($state.transition !== transition)
                return TransitionSuperseded;
              for (l = fromPath.length - 1; l >= keep; l--) {
                exiting = fromPath[l];
                if (exiting.self.onExit) {
                  $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);
                }
                exiting.locals = null;
              }
              for (l = keep; l < toPath.length; l++) {
                entering = toPath[l];
                entering.locals = toLocals[l];
                if (entering.self.onEnter) {
                  $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);
                }
              }
              if (hash)
                toParams['#'] = hash;
              if ($state.transition !== transition)
                return TransitionSuperseded;
              $state.$current = to;
              $state.current = to.self;
              $state.params = toParams;
              copy($state.params, $stateParams);
              $state.transition = null;
              if (options.location && to.navigable) {
                $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {
                  $$avoidResync: true,
                  replace: options.location === 'replace'
                });
              }
              if (options.notify) {
                $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);
              }
              $urlRouter.update(true);
              return $state.current;
            }, function(error) {
              if ($state.transition !== transition)
                return TransitionSuperseded;
              $state.transition = null;
              evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);
              if (!evt.defaultPrevented) {
                $urlRouter.update();
              }
              return $q.reject(error);
            });
            return transition;
          };
          $state.is = function is(stateOrName, params, options) {
            options = extend({relative: $state.$current}, options || {});
            var state = findState(stateOrName, options.relative);
            if (!isDefined(state)) {
              return undefined;
            }
            if ($state.$current !== state) {
              return false;
            }
            return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;
          };
          $state.includes = function includes(stateOrName, params, options) {
            options = extend({relative: $state.$current}, options || {});
            if (isString(stateOrName) && isGlob(stateOrName)) {
              if (!doesStateMatchGlob(stateOrName)) {
                return false;
              }
              stateOrName = $state.$current.name;
            }
            var state = findState(stateOrName, options.relative);
            if (!isDefined(state)) {
              return undefined;
            }
            if (!isDefined($state.$current.includes[state.name])) {
              return false;
            }
            return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;
          };
          $state.href = function href(stateOrName, params, options) {
            options = extend({
              lossy: true,
              inherit: true,
              absolute: false,
              relative: $state.$current
            }, options || {});
            var state = findState(stateOrName, options.relative);
            if (!isDefined(state))
              return null;
            if (options.inherit)
              params = inheritParams($stateParams, params || {}, $state.$current, state);
            var nav = (state && options.lossy) ? state.navigable : state;
            if (!nav || nav.url === undefined || nav.url === null) {
              return null;
            }
            return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {absolute: options.absolute});
          };
          $state.get = function(stateOrName, context) {
            if (arguments.length === 0)
              return map(objectKeys(states), function(name) {
                return states[name].self;
              });
            var state = findState(stateOrName, context || $state.$current);
            return (state && state.self) ? state.self : null;
          };
          function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {
            var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);
            var locals = {$stateParams: $stateParams};
            dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);
            var promises = [dst.resolve.then(function(globals) {
              dst.globals = globals;
            })];
            if (inherited)
              promises.push(inherited);
            function resolveViews() {
              var viewsPromises = [];
              forEach(state.views, function(view, name) {
                var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});
                injectables.$template = [function() {
                  return $view.load(name, {
                    view: view,
                    locals: dst.globals,
                    params: $stateParams,
                    notify: options.notify
                  }) || '';
                }];
                viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function(result) {
                  if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {
                    var injectLocals = angular.extend({}, injectables, dst.globals);
                    result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);
                  } else {
                    result.$$controller = view.controller;
                  }
                  result.$$state = state;
                  result.$$controllerAs = view.controllerAs;
                  dst[name] = result;
                }));
              });
              return $q.all(viewsPromises).then(function() {
                return dst.globals;
              });
            }
            return $q.all(promises).then(resolveViews).then(function(values) {
              return dst;
            });
          }
          return $state;
        }
        function shouldSkipReload(to, toParams, from, fromParams, locals, options) {
          function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {
            function notSearchParam(key) {
              return fromAndToState.params[key].location != "search";
            }
            var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);
            var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));
            var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);
            return nonQueryParamSet.$$equals(fromParams, toParams);
          }
          if (!options.reload && to === from && (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {
            return true;
          }
        }
      }
      angular.module('ui.router.state').value('$stateParams', {}).provider('$state', $StateProvider);
      $ViewProvider.$inject = [];
      function $ViewProvider() {
        this.$get = $get;
        $get.$inject = ['$rootScope', '$templateFactory'];
        function $get($rootScope, $templateFactory) {
          return {load: function load(name, options) {
              var result,
                  defaults = {
                    template: null,
                    controller: null,
                    view: null,
                    locals: null,
                    notify: true,
                    async: true,
                    params: {}
                  };
              options = extend(defaults, options);
              if (options.view) {
                result = $templateFactory.fromConfig(options.view, options.params, options.locals);
              }
              if (result && options.notify) {
                $rootScope.$broadcast('$viewContentLoading', options);
              }
              return result;
            }};
        }
      }
      angular.module('ui.router.state').provider('$view', $ViewProvider);
      function $ViewScrollProvider() {
        var useAnchorScroll = false;
        this.useAnchorScroll = function() {
          useAnchorScroll = true;
        };
        this.$get = ['$anchorScroll', '$timeout', function($anchorScroll, $timeout) {
          if (useAnchorScroll) {
            return $anchorScroll;
          }
          return function($element) {
            return $timeout(function() {
              $element[0].scrollIntoView();
            }, 0, false);
          };
        }];
      }
      angular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);
      $ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate'];
      function $ViewDirective($state, $injector, $uiViewScroll, $interpolate) {
        function getService() {
          return ($injector.has) ? function(service) {
            return $injector.has(service) ? $injector.get(service) : null;
          } : function(service) {
            try {
              return $injector.get(service);
            } catch (e) {
              return null;
            }
          };
        }
        var service = getService(),
            $animator = service('$animator'),
            $animate = service('$animate');
        function getRenderer(attrs, scope) {
          var statics = function() {
            return {
              enter: function(element, target, cb) {
                target.after(element);
                cb();
              },
              leave: function(element, cb) {
                element.remove();
                cb();
              }
            };
          };
          if ($animate) {
            return {
              enter: function(element, target, cb) {
                var promise = $animate.enter(element, null, target, cb);
                if (promise && promise.then)
                  promise.then(cb);
              },
              leave: function(element, cb) {
                var promise = $animate.leave(element, cb);
                if (promise && promise.then)
                  promise.then(cb);
              }
            };
          }
          if ($animator) {
            var animate = $animator && $animator(scope, attrs);
            return {
              enter: function(element, target, cb) {
                animate.enter(element, null, target);
                cb();
              },
              leave: function(element, cb) {
                animate.leave(element);
                cb();
              }
            };
          }
          return statics();
        }
        var directive = {
          restrict: 'ECA',
          terminal: true,
          priority: 400,
          transclude: 'element',
          compile: function(tElement, tAttrs, $transclude) {
            return function(scope, $element, attrs) {
              var previousEl,
                  currentEl,
                  currentScope,
                  latestLocals,
                  onloadExp = attrs.onload || '',
                  autoScrollExp = attrs.autoscroll,
                  renderer = getRenderer(attrs, scope);
              scope.$on('$stateChangeSuccess', function() {
                updateView(false);
              });
              scope.$on('$viewContentLoading', function() {
                updateView(false);
              });
              updateView(true);
              function cleanupLastView() {
                if (previousEl) {
                  previousEl.remove();
                  previousEl = null;
                }
                if (currentScope) {
                  currentScope.$destroy();
                  currentScope = null;
                }
                if (currentEl) {
                  renderer.leave(currentEl, function() {
                    previousEl = null;
                  });
                  previousEl = currentEl;
                  currentEl = null;
                }
              }
              function updateView(firstTime) {
                var newScope,
                    name = getUiViewName(scope, attrs, $element, $interpolate),
                    previousLocals = name && $state.$current && $state.$current.locals[name];
                if (!firstTime && previousLocals === latestLocals)
                  return;
                newScope = scope.$new();
                latestLocals = $state.$current.locals[name];
                var clone = $transclude(newScope, function(clone) {
                  renderer.enter(clone, $element, function onUiViewEnter() {
                    if (currentScope) {
                      currentScope.$emit('$viewContentAnimationEnded');
                    }
                    if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {
                      $uiViewScroll(clone);
                    }
                  });
                  cleanupLastView();
                });
                currentEl = clone;
                currentScope = newScope;
                currentScope.$emit('$viewContentLoaded');
                currentScope.$eval(onloadExp);
              }
            };
          }
        };
        return directive;
      }
      $ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];
      function $ViewDirectiveFill($compile, $controller, $state, $interpolate) {
        return {
          restrict: 'ECA',
          priority: -400,
          compile: function(tElement) {
            var initial = tElement.html();
            return function(scope, $element, attrs) {
              var current = $state.$current,
                  name = getUiViewName(scope, attrs, $element, $interpolate),
                  locals = current && current.locals[name];
              if (!locals) {
                return;
              }
              $element.data('$uiView', {
                name: name,
                state: locals.$$state
              });
              $element.html(locals.$template ? locals.$template : initial);
              var link = $compile($element.contents());
              if (locals.$$controller) {
                locals.$scope = scope;
                locals.$element = $element;
                var controller = $controller(locals.$$controller, locals);
                if (locals.$$controllerAs) {
                  scope[locals.$$controllerAs] = controller;
                }
                $element.data('$ngControllerController', controller);
                $element.children().data('$ngControllerController', controller);
              }
              link(scope);
            };
          }
        };
      }
      function getUiViewName(scope, attrs, element, $interpolate) {
        var name = $interpolate(attrs.uiView || attrs.name || '')(scope);
        var inherited = element.inheritedData('$uiView');
        return name.indexOf('@') >= 0 ? name : (name + '@' + (inherited ? inherited.state.name : ''));
      }
      angular.module('ui.router.state').directive('uiView', $ViewDirective);
      angular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);
      function parseStateRef(ref, current) {
        var preparsed = ref.match(/^\s*({[^}]*})\s*$/),
            parsed;
        if (preparsed)
          ref = current + '(' + preparsed[1] + ')';
        parsed = ref.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/);
        if (!parsed || parsed.length !== 4)
          throw new Error("Invalid state ref '" + ref + "'");
        return {
          state: parsed[1],
          paramExpr: parsed[3] || null
        };
      }
      function stateContext(el) {
        var stateData = el.parent().inheritedData('$uiView');
        if (stateData && stateData.state && stateData.state.name) {
          return stateData.state;
        }
      }
      $StateRefDirective.$inject = ['$state', '$timeout'];
      function $StateRefDirective($state, $timeout) {
        var allowedOptions = ['location', 'inherit', 'reload', 'absolute'];
        return {
          restrict: 'A',
          require: ['?^uiSrefActive', '?^uiSrefActiveEq'],
          link: function(scope, element, attrs, uiSrefActive) {
            var ref = parseStateRef(attrs.uiSref, $state.current.name);
            var params = null,
                url = null,
                base = stateContext(element) || $state.$current;
            var hrefKind = Object.prototype.toString.call(element.prop('href')) === '[object SVGAnimatedString]' ? 'xlink:href' : 'href';
            var newHref = null,
                isAnchor = element.prop("tagName").toUpperCase() === "A";
            var isForm = element[0].nodeName === "FORM";
            var attr = isForm ? "action" : hrefKind,
                nav = true;
            var options = {
              relative: base,
              inherit: true
            };
            var optionsOverride = scope.$eval(attrs.uiSrefOpts) || {};
            angular.forEach(allowedOptions, function(option) {
              if (option in optionsOverride) {
                options[option] = optionsOverride[option];
              }
            });
            var update = function(newVal) {
              if (newVal)
                params = angular.copy(newVal);
              if (!nav)
                return;
              newHref = $state.href(ref.state, params, options);
              var activeDirective = uiSrefActive[1] || uiSrefActive[0];
              if (activeDirective) {
                activeDirective.$$addStateInfo(ref.state, params);
              }
              if (newHref === null) {
                nav = false;
                return false;
              }
              attrs.$set(attr, newHref);
            };
            if (ref.paramExpr) {
              scope.$watch(ref.paramExpr, function(newVal, oldVal) {
                if (newVal !== params)
                  update(newVal);
              }, true);
              params = angular.copy(scope.$eval(ref.paramExpr));
            }
            update();
            if (isForm)
              return;
            element.bind("click", function(e) {
              var button = e.which || e.button;
              if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || element.attr('target'))) {
                var transition = $timeout(function() {
                  $state.go(ref.state, params, options);
                });
                e.preventDefault();
                var ignorePreventDefaultCount = isAnchor && !newHref ? 1 : 0;
                e.preventDefault = function() {
                  if (ignorePreventDefaultCount-- <= 0)
                    $timeout.cancel(transition);
                };
              }
            });
          }
        };
      }
      $StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];
      function $StateRefActiveDirective($state, $stateParams, $interpolate) {
        return {
          restrict: "A",
          controller: ['$scope', '$element', '$attrs', function($scope, $element, $attrs) {
            var states = [],
                activeClass;
            activeClass = $interpolate($attrs.uiSrefActiveEq || $attrs.uiSrefActive || '', false)($scope);
            this.$$addStateInfo = function(newState, newParams) {
              var state = $state.get(newState, stateContext($element));
              states.push({
                state: state || {name: newState},
                params: newParams
              });
              update();
            };
            $scope.$on('$stateChangeSuccess', update);
            function update() {
              if (anyMatch()) {
                $element.addClass(activeClass);
              } else {
                $element.removeClass(activeClass);
              }
            }
            function anyMatch() {
              for (var i = 0; i < states.length; i++) {
                if (isMatch(states[i].state, states[i].params)) {
                  return true;
                }
              }
              return false;
            }
            function isMatch(state, params) {
              if (typeof $attrs.uiSrefActiveEq !== 'undefined') {
                return $state.is(state.name, params);
              } else {
                return $state.includes(state.name, params);
              }
            }
          }]
        };
      }
      angular.module('ui.router.state').directive('uiSref', $StateRefDirective).directive('uiSrefActive', $StateRefActiveDirective).directive('uiSrefActiveEq', $StateRefActiveDirective);
      $IsStateFilter.$inject = ['$state'];
      function $IsStateFilter($state) {
        var isFilter = function(state) {
          return $state.is(state);
        };
        isFilter.$stateful = true;
        return isFilter;
      }
      $IncludedByStateFilter.$inject = ['$state'];
      function $IncludedByStateFilter($state) {
        var includesFilter = function(state) {
          return $state.includes(state);
        };
        includesFilter.$stateful = true;
        return includesFilter;
      }
      angular.module('ui.router.state').filter('isState', $IsStateFilter).filter('includedByState', $IncludedByStateFilter);
    })(window, window.angular);
  })();
  return _retrieveGlobal();
});

System.registerDynamic("github:angular-ui/ui-router@0.2.15", ["github:angular-ui/ui-router@0.2.15/angular-ui-router"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('github:angular-ui/ui-router@0.2.15/angular-ui-router');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:paulsmith/angular-slugify@1.0.1/angular-slugify", [], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {
    (function() {
      "use strict";
      var mod = angular.module("slugifier", []);
      var charmap = {
        ' ': " ",
        '¡': "!",
        '¢': "c",
        '£': "lb",
        '¥': "yen",
        '¦': "|",
        '§': "SS",
        '¨': "\"",
        '©': "(c)",
        'ª': "a",
        '«': "<<",
        '¬': "not",
        '­': "-",
        '®': "(R)",
        '°': "^0",
        '±': "+/-",
        '²': "^2",
        '³': "^3",
        '´': "'",
        'µ': "u",
        '¶': "P",
        '·': ".",
        '¸': ",",
        '¹': "^1",
        'º': "o",
        '»': ">>",
        '¼': " 1/4 ",
        '½': " 1/2 ",
        '¾': " 3/4 ",
        '¿': "?",
        'À': "`A",
        'Á': "'A",
        'Â': "^A",
        'Ã': "~A",
        'Ä': '"A',
        'Å': "A",
        'Æ': "AE",
        'Ç': "C",
        'È': "`E",
        'É': "'E",
        'Ê': "^E",
        'Ë': '"E',
        'Ì': "`I",
        'Í': "'I",
        'Î': "^I",
        'Ï': '"I',
        'Ð': "D",
        'Ñ': "~N",
        'Ò': "`O",
        'Ó': "'O",
        'Ô': "^O",
        'Õ': "~O",
        'Ö': '"O',
        '×': "x",
        'Ø': "O",
        'Ù': "`U",
        'Ú': "'U",
        'Û': "^U",
        'Ü': '"U',
        'Ý': "'Y",
        'Þ': "Th",
        'ß': "ss",
        'à': "`a",
        'á': "'a",
        'â': "^a",
        'ã': "~a",
        'ä': '"a',
        'å': "a",
        'æ': "ae",
        'ç': "c",
        'è': "`e",
        'é': "'e",
        'ê': "^e",
        'ë': '"e',
        'ì': "`i",
        'í': "'i",
        'î': "^i",
        'ï': '"i',
        'ð': "d",
        'ñ': "~n",
        'ò': "`o",
        'ó': "'o",
        'ô': "^o",
        'õ': "~o",
        'ö': '"o',
        '÷': ":",
        'ø': "o",
        'ù': "`u",
        'ú': "'u",
        'û': "^u",
        'ü': '"u',
        'ý': "'y",
        'þ': "th",
        'ÿ': '"y',
        'Ā': "A",
        'ā': "a",
        'Ă': "A",
        'ă': "a",
        'Ą': "A",
        'ą': "a",
        'Ć': "'C",
        'ć': "'c",
        'Ĉ': "^C",
        'ĉ': "^c",
        'Ċ': "C",
        'ċ': "c",
        'Č': "C",
        'č': "c",
        'Ď': "D",
        'ď': "d",
        'Đ': "D",
        'đ': "d",
        'Ē': "E",
        'ē': "e",
        'Ĕ': "E",
        'ĕ': "e",
        'Ė': "E",
        'ė': "e",
        'Ę': "E",
        'ę': "e",
        'Ě': "E",
        'ě': "e",
        'Ĝ': "^G",
        'ĝ': "^g",
        'Ğ': "G",
        'ğ': "g",
        'Ġ': "G",
        'ġ': "g",
        'Ģ': "G",
        'ģ': "g",
        'Ĥ': "^H",
        'ĥ': "^h",
        'Ħ': "H",
        'ħ': "h",
        'Ĩ': "~I",
        'ĩ': "~i",
        'Ī': "I",
        'ī': "i",
        'Ĭ': "I",
        'ĭ': "i",
        'Į': "I",
        'į': "i",
        'İ': "I",
        'ı': "i",
        'Ĳ': "IJ",
        'ĳ': "ij",
        'Ĵ': "^J",
        'ĵ': "^j",
        'Ķ': "K",
        'ķ': "k",
        'Ĺ': "L",
        'ĺ': "l",
        'Ļ': "L",
        'ļ': "l",
        'Ľ': "L",
        'ľ': "l",
        'Ŀ': "L",
        'ŀ': "l",
        'Ł': "L",
        'ł': "l",
        'Ń': "'N",
        'ń': "'n",
        'Ņ': "N",
        'ņ': "n",
        'Ň': "N",
        'ň': "n",
        'ŉ': "'n",
        'Ō': "O",
        'ō': "o",
        'Ŏ': "O",
        'ŏ': "o",
        'Ő': '"O',
        'ő': '"o',
        'Œ': "OE",
        'œ': "oe",
        'Ŕ': "'R",
        'ŕ': "'r",
        'Ŗ': "R",
        'ŗ': "r",
        'Ř': "R",
        'ř': "r",
        'Ś': "'S",
        'ś': "'s",
        'Ŝ': "^S",
        'ŝ': "^s",
        'Ş': "S",
        'ş': "s",
        'Š': "S",
        'š': "s",
        'Ţ': "T",
        'ţ': "t",
        'Ť': "T",
        'ť': "t",
        'Ŧ': "T",
        'ŧ': "t",
        'Ũ': "~U",
        'ũ': "~u",
        'Ū': "U",
        'ū': "u",
        'Ŭ': "U",
        'ŭ': "u",
        'Ů': "U",
        'ů': "u",
        'Ű': '"U',
        'ű': '"u',
        'Ų': "U",
        'ų': "u",
        'Ŵ': "^W",
        'ŵ': "^w",
        'Ŷ': "^Y",
        'ŷ': "^y",
        'Ÿ': '"Y',
        'Ź': "'Z",
        'ź': "'z",
        'Ż': "Z",
        'ż': "z",
        'Ž': "Z",
        'ž': "z",
        'ſ': "s"
      };
      function _slugify(s) {
        if (!s)
          return "";
        var ascii = [];
        var ch,
            cp;
        for (var i = 0; i < s.length; i++) {
          if ((cp = s.charCodeAt(i)) < 0x180) {
            ch = String.fromCharCode(cp);
            ascii.push(charmap[ch] || ch);
          }
        }
        s = ascii.join("");
        s = s.replace(/[^\w\s-]/g, "").trim().toLowerCase();
        return s.replace(/[-\s]+/g, "-");
      }
      mod.factory("Slug", function() {
        return {slugify: _slugify};
      });
      mod.directive("slug", ["Slug", function(Slug) {
        return {
          restrict: "E",
          scope: {to: "="},
          transclude: true,
          replace: true,
          template: "<div ng-transclude></div>",
          link: function(scope, elem, attrs) {
            if (!attrs.from) {
              throw "must set attribute 'from'";
            }
            scope.$parent.$watch(attrs.from, function(val) {
              scope.to = Slug.slugify(val);
            });
          }
        };
      }]);
      mod.filter("slugify", ["Slug", function(Slug) {
        return function(input) {
          return Slug.slugify(input);
        };
      }]);
    })();
  })();
  return _retrieveGlobal();
});

System.registerDynamic("github:paulsmith/angular-slugify@1.0.1", ["github:paulsmith/angular-slugify@1.0.1/angular-slugify.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('github:paulsmith/angular-slugify@1.0.1/angular-slugify.js');
  global.define = __define;
  return module.exports;
});

System.register("controllers/home.js", ["npm:babel-runtime@5.8.34/helpers/class-call-check"], function (_export) {
  var _classCallCheck, HomeController;

  return {
    setters: [function (_babelRuntimeHelpersClassCallCheck) {
      _classCallCheck = _babelRuntimeHelpersClassCallCheck["default"];
    }],
    execute: function () {
      "use strict";

      HomeController =

      /*@ngInject*/
      function HomeController($scope, currentWarnings) {
        _classCallCheck(this, HomeController);

        $scope.currentWarnings = currentWarnings.data.warnings.items;
      };

      _export("HomeController", HomeController);
    }
  };
});

System.register('controllers/header.js', ['npm:babel-runtime@5.8.34/helpers/class-call-check'], function (_export) {
  var _classCallCheck, HeaderController;

  return {
    setters: [function (_babelRuntimeHelpersClassCallCheck) {
      _classCallCheck = _babelRuntimeHelpersClassCallCheck['default'];
    }],
    execute: function () {
      'use strict';

      HeaderController =

      /*@ngInject*/
      function HeaderController($scope, $rootScope) {
        _classCallCheck(this, HeaderController);

        $rootScope.$on('$stateChangeSuccess', function (event, toState, toParams, fromState, fromParams) {
          $scope.showMenu = false;
        });

        $scope.toggleMenu = function () {
          $scope.showMenu = !$scope.showMenu;
        };
      };

      _export('HeaderController', HeaderController);
    }
  };
});

System.register("controllers/warnings.js", ["npm:babel-runtime@5.8.34/helpers/class-call-check"], function (_export) {
  var _classCallCheck, WarningsController;

  return {
    setters: [function (_babelRuntimeHelpersClassCallCheck) {
      _classCallCheck = _babelRuntimeHelpersClassCallCheck["default"];
    }],
    execute: function () {
      "use strict";

      WarningsController =

      /*@ngInject*/
      function WarningsController($scope, warningsContext) {
        _classCallCheck(this, WarningsController);

        $scope.warnings = warningsContext.data.warnings;
        $scope.current = warningsContext.data.current;
      };

      _export("WarningsController", WarningsController);
    }
  };
});

System.register('controllers/search.js', ['npm:babel-runtime@5.8.34/helpers/class-call-check'], function (_export) {
  var _classCallCheck, SearchController;

  return {
    setters: [function (_babelRuntimeHelpersClassCallCheck) {
      _classCallCheck = _babelRuntimeHelpersClassCallCheck['default'];
    }],
    execute: function () {
      'use strict';

      SearchController =

      /*@ngInject*/
      function SearchController($scope, $http, searchContext, uiGmapGoogleMapApi, uiGmapIsReady) {
        _classCallCheck(this, SearchController);

        $scope.map = {
          center: {
            latitude: '51.500152',
            longitude: '-0.126236'
          },
          polygons: [],
          zoom: 11,
          control: {},
          bounds: {}

        };

        uiGmapGoogleMapApi.then(function (maps) {
          $scope.bounds = new maps.LatLngBounds();

          angular.forEach(searchContext.data.warnings, function (warning, index) {

            $http.get(warning.floodArea.polygon).then(function (polygon) {

              var poly = polygon.data.features[0].geometry;
              angular.forEach(poly.coordinates, function (coords) {

                $scope.map.polygons.push({ id: warning.slug, "geom": {
                    coordinates: coords,
                    type: "Polygon"
                  }
                });

                angular.forEach(coords[0], function (c) {
                  var latLng = new google.maps.LatLng(c[1], c[0]);
                  $scope.bounds.extend(latLng);
                });
              });
            });
          });

          $scope.$watchCollection('map.polygons', function (newval, oldval) {

            $scope.map.center.latitude = $scope.bounds.getCenter().lat();
            $scope.map.center.longitude = $scope.bounds.getCenter().lng();

            //$scope.map.bounds = {
            //    northeast: {
            //      latitude: $scope.bounds.getNorthEast().lat(),
            //      longitude: $scope.bounds.getNorthEast().lng()
            //    },
            //    southwest: {
            //      latitude: $scope.bounds.getSouthWest().lat(),
            //      longitude: $scope.bounds.getSouthWest().lng()
            //    }
            //  };

            //var gmap = $scope.map.control.getGMap();
            //gmap.fitBounds($scope.bounds);
          });
        });
      };

      _export('SearchController', SearchController);
    }
  };
});

System.registerDynamic("npm:babel-runtime@5.8.34/helpers/class-call-check", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports["default"] = function(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:process@0.11.2/browser", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var process = module.exports = {};
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
  }
  process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
      setTimeout(drainQueue, 0);
    }
  };
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  Item.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = '';
  process.versions = {};
  function noop() {}
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.binding = function(name) {
    throw new Error('process.binding is not supported');
  };
  process.cwd = function() {
    return '/';
  };
  process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
  };
  process.umask = function() {
    return 0;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:process@0.11.2", ["npm:process@0.11.2/browser"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:process@0.11.2/browser');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-process@0.1.2/index", ["process"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? process : $__require('process');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-process@0.1.2", ["github:jspm/nodelibs-process@0.1.2/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('github:jspm/nodelibs-process@0.1.2/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1/index", ["process"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(process) {
    ;
    (function() {
      var undefined;
      var VERSION = '3.10.1';
      var BIND_FLAG = 1,
          BIND_KEY_FLAG = 2,
          CURRY_BOUND_FLAG = 4,
          CURRY_FLAG = 8,
          CURRY_RIGHT_FLAG = 16,
          PARTIAL_FLAG = 32,
          PARTIAL_RIGHT_FLAG = 64,
          ARY_FLAG = 128,
          REARG_FLAG = 256;
      var DEFAULT_TRUNC_LENGTH = 30,
          DEFAULT_TRUNC_OMISSION = '...';
      var HOT_COUNT = 150,
          HOT_SPAN = 16;
      var LARGE_ARRAY_SIZE = 200;
      var LAZY_FILTER_FLAG = 1,
          LAZY_MAP_FLAG = 2;
      var FUNC_ERROR_TEXT = 'Expected a function';
      var PLACEHOLDER = '__lodash_placeholder__';
      var argsTag = '[object Arguments]',
          arrayTag = '[object Array]',
          boolTag = '[object Boolean]',
          dateTag = '[object Date]',
          errorTag = '[object Error]',
          funcTag = '[object Function]',
          mapTag = '[object Map]',
          numberTag = '[object Number]',
          objectTag = '[object Object]',
          regexpTag = '[object RegExp]',
          setTag = '[object Set]',
          stringTag = '[object String]',
          weakMapTag = '[object WeakMap]';
      var arrayBufferTag = '[object ArrayBuffer]',
          float32Tag = '[object Float32Array]',
          float64Tag = '[object Float64Array]',
          int8Tag = '[object Int8Array]',
          int16Tag = '[object Int16Array]',
          int32Tag = '[object Int32Array]',
          uint8Tag = '[object Uint8Array]',
          uint8ClampedTag = '[object Uint8ClampedArray]',
          uint16Tag = '[object Uint16Array]',
          uint32Tag = '[object Uint32Array]';
      var reEmptyStringLeading = /\b__p \+= '';/g,
          reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
          reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
          reUnescapedHtml = /[&<>"'`]/g,
          reHasEscapedHtml = RegExp(reEscapedHtml.source),
          reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g,
          reEvaluate = /<%([\s\S]+?)%>/g,
          reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
          reIsPlainProp = /^\w*$/,
          rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;
      var reRegExpChars = /^[:!,]|[\\^$.*+?()[\]{}|\/]|(^[0-9a-fA-Fnrtuvx])|([\n\r\u2028\u2029])/g,
          reHasRegExpChars = RegExp(reRegExpChars.source);
      var reComboMark = /[\u0300-\u036f\ufe20-\ufe23]/g;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reHasHexPrefix = /^0[xX]/;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsUint = /^\d+$/;
      var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var reWords = (function() {
        var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
            lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';
        return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
      }());
      var contextProps = ['Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array', 'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number', 'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'isFinite', 'parseFloat', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array', 'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap'];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[stringTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[mapTag] = cloneableTags[setTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        '\xc0': 'A',
        '\xc1': 'A',
        '\xc2': 'A',
        '\xc3': 'A',
        '\xc4': 'A',
        '\xc5': 'A',
        '\xe0': 'a',
        '\xe1': 'a',
        '\xe2': 'a',
        '\xe3': 'a',
        '\xe4': 'a',
        '\xe5': 'a',
        '\xc7': 'C',
        '\xe7': 'c',
        '\xd0': 'D',
        '\xf0': 'd',
        '\xc8': 'E',
        '\xc9': 'E',
        '\xca': 'E',
        '\xcb': 'E',
        '\xe8': 'e',
        '\xe9': 'e',
        '\xea': 'e',
        '\xeb': 'e',
        '\xcC': 'I',
        '\xcd': 'I',
        '\xce': 'I',
        '\xcf': 'I',
        '\xeC': 'i',
        '\xed': 'i',
        '\xee': 'i',
        '\xef': 'i',
        '\xd1': 'N',
        '\xf1': 'n',
        '\xd2': 'O',
        '\xd3': 'O',
        '\xd4': 'O',
        '\xd5': 'O',
        '\xd6': 'O',
        '\xd8': 'O',
        '\xf2': 'o',
        '\xf3': 'o',
        '\xf4': 'o',
        '\xf5': 'o',
        '\xf6': 'o',
        '\xf8': 'o',
        '\xd9': 'U',
        '\xda': 'U',
        '\xdb': 'U',
        '\xdc': 'U',
        '\xf9': 'u',
        '\xfa': 'u',
        '\xfb': 'u',
        '\xfc': 'u',
        '\xdd': 'Y',
        '\xfd': 'y',
        '\xff': 'y',
        '\xc6': 'Ae',
        '\xe6': 'ae',
        '\xde': 'Th',
        '\xfe': 'th',
        '\xdf': 'ss'
      };
      var htmlEscapes = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;',
        '`': '&#96;'
      };
      var htmlUnescapes = {
        '&amp;': '&',
        '&lt;': '<',
        '&gt;': '>',
        '&quot;': '"',
        '&#39;': "'",
        '&#96;': '`'
      };
      var objectTypes = {
        'function': true,
        'object': true
      };
      var regexpEscapes = {
        '0': 'x30',
        '1': 'x31',
        '2': 'x32',
        '3': 'x33',
        '4': 'x34',
        '5': 'x35',
        '6': 'x36',
        '7': 'x37',
        '8': 'x38',
        '9': 'x39',
        'A': 'x41',
        'B': 'x42',
        'C': 'x43',
        'D': 'x44',
        'E': 'x45',
        'F': 'x46',
        'a': 'x61',
        'b': 'x62',
        'c': 'x63',
        'd': 'x64',
        'e': 'x65',
        'f': 'x66',
        'n': 'x6e',
        'r': 'x72',
        't': 'x74',
        'u': 'x75',
        'v': 'x76',
        'x': 'x78'
      };
      var stringEscapes = {
        '\\': '\\',
        "'": "'",
        '\n': 'n',
        '\r': 'r',
        '\u2028': 'u2028',
        '\u2029': 'u2029'
      };
      var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
      var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
      var freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;
      var freeSelf = objectTypes[typeof self] && self && self.Object && self;
      var freeWindow = objectTypes[typeof window] && window && window.Object && window;
      var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
      var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;
      function baseCompareAscending(value, other) {
        if (value !== other) {
          var valIsNull = value === null,
              valIsUndef = value === undefined,
              valIsReflexive = value === value;
          var othIsNull = other === null,
              othIsUndef = other === undefined,
              othIsReflexive = other === other;
          if ((value > other && !othIsNull) || !valIsReflexive || (valIsNull && !othIsUndef && othIsReflexive) || (valIsUndef && othIsReflexive)) {
            return 1;
          }
          if ((value < other && !valIsNull) || !othIsReflexive || (othIsNull && !valIsUndef && valIsReflexive) || (othIsUndef && valIsReflexive)) {
            return -1;
          }
        }
        return 0;
      }
      function baseFindIndex(array, predicate, fromRight) {
        var length = array.length,
            index = fromRight ? length : -1;
        while ((fromRight ? index-- : ++index < length)) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        if (value !== value) {
          return indexOfNaN(array, fromIndex);
        }
        var index = fromIndex - 1,
            length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function baseIsFunction(value) {
        return typeof value == 'function' || false;
      }
      function baseToString(value) {
        return value == null ? '' : (value + '');
      }
      function charsLeftIndex(string, chars) {
        var index = -1,
            length = string.length;
        while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
        return index;
      }
      function charsRightIndex(string, chars) {
        var index = string.length;
        while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
        return index;
      }
      function compareAscending(object, other) {
        return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
      }
      function compareMultiple(object, other, orders) {
        var index = -1,
            objCriteria = object.criteria,
            othCriteria = other.criteria,
            length = objCriteria.length,
            ordersLength = orders.length;
        while (++index < length) {
          var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
          if (result) {
            if (index >= ordersLength) {
              return result;
            }
            var order = orders[index];
            return result * ((order === 'asc' || order === true) ? 1 : -1);
          }
        }
        return object.index - other.index;
      }
      function deburrLetter(letter) {
        return deburredLetters[letter];
      }
      function escapeHtmlChar(chr) {
        return htmlEscapes[chr];
      }
      function escapeRegExpChar(chr, leadingChar, whitespaceChar) {
        if (leadingChar) {
          chr = regexpEscapes[chr];
        } else if (whitespaceChar) {
          chr = stringEscapes[chr];
        }
        return '\\' + chr;
      }
      function escapeStringChar(chr) {
        return '\\' + stringEscapes[chr];
      }
      function indexOfNaN(array, fromIndex, fromRight) {
        var length = array.length,
            index = fromIndex + (fromRight ? 0 : -1);
        while ((fromRight ? index-- : ++index < length)) {
          var other = array[index];
          if (other !== other) {
            return index;
          }
        }
        return -1;
      }
      function isObjectLike(value) {
        return !!value && typeof value == 'object';
      }
      function isSpace(charCode) {
        return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 || (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
      }
      function replaceHolders(array, placeholder) {
        var index = -1,
            length = array.length,
            resIndex = -1,
            result = [];
        while (++index < length) {
          if (array[index] === placeholder) {
            array[index] = PLACEHOLDER;
            result[++resIndex] = index;
          }
        }
        return result;
      }
      function sortedUniq(array, iteratee) {
        var seen,
            index = -1,
            length = array.length,
            resIndex = -1,
            result = [];
        while (++index < length) {
          var value = array[index],
              computed = iteratee ? iteratee(value, index, array) : value;
          if (!index || seen !== computed) {
            seen = computed;
            result[++resIndex] = value;
          }
        }
        return result;
      }
      function trimmedLeftIndex(string) {
        var index = -1,
            length = string.length;
        while (++index < length && isSpace(string.charCodeAt(index))) {}
        return index;
      }
      function trimmedRightIndex(string) {
        var index = string.length;
        while (index-- && isSpace(string.charCodeAt(index))) {}
        return index;
      }
      function unescapeHtmlChar(chr) {
        return htmlUnescapes[chr];
      }
      function runInContext(context) {
        context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
        var Array = context.Array,
            Date = context.Date,
            Error = context.Error,
            Function = context.Function,
            Math = context.Math,
            Number = context.Number,
            Object = context.Object,
            RegExp = context.RegExp,
            String = context.String,
            TypeError = context.TypeError;
        var arrayProto = Array.prototype,
            objectProto = Object.prototype,
            stringProto = String.prototype;
        var fnToString = Function.prototype.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var objToString = objectProto.toString;
        var oldDash = root._;
        var reIsNative = RegExp('^' + fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
        var ArrayBuffer = context.ArrayBuffer,
            clearTimeout = context.clearTimeout,
            parseFloat = context.parseFloat,
            pow = Math.pow,
            propertyIsEnumerable = objectProto.propertyIsEnumerable,
            Set = getNative(context, 'Set'),
            setTimeout = context.setTimeout,
            splice = arrayProto.splice,
            Uint8Array = context.Uint8Array,
            WeakMap = getNative(context, 'WeakMap');
        var nativeCeil = Math.ceil,
            nativeCreate = getNative(Object, 'create'),
            nativeFloor = Math.floor,
            nativeIsArray = getNative(Array, 'isArray'),
            nativeIsFinite = context.isFinite,
            nativeKeys = getNative(Object, 'keys'),
            nativeMax = Math.max,
            nativeMin = Math.min,
            nativeNow = getNative(Date, 'now'),
            nativeParseInt = context.parseInt,
            nativeRandom = Math.random;
        var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
            POSITIVE_INFINITY = Number.POSITIVE_INFINITY;
        var MAX_ARRAY_LENGTH = 4294967295,
            MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
            HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        var MAX_SAFE_INTEGER = 9007199254740991;
        var metaMap = WeakMap && new WeakMap;
        var realNames = {};
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        function baseLodash() {}
        function LodashWrapper(value, chainAll, actions) {
          this.__wrapped__ = value;
          this.__actions__ = actions || [];
          this.__chain__ = !!chainAll;
        }
        var support = lodash.support = {};
        lodash.templateSettings = {
          'escape': reEscape,
          'evaluate': reEvaluate,
          'interpolate': reInterpolate,
          'variable': '',
          'imports': {'_': lodash}
        };
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = POSITIVE_INFINITY;
          this.__views__ = [];
        }
        function lazyClone() {
          var result = new LazyWrapper(this.__wrapped__);
          result.__actions__ = arrayCopy(this.__actions__);
          result.__dir__ = this.__dir__;
          result.__filtered__ = this.__filtered__;
          result.__iteratees__ = arrayCopy(this.__iteratees__);
          result.__takeCount__ = this.__takeCount__;
          result.__views__ = arrayCopy(this.__views__);
          return result;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result = new LazyWrapper(this);
            result.__dir__ = -1;
            result.__filtered__ = true;
          } else {
            result = this.clone();
            result.__dir__ *= -1;
          }
          return result;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(),
              dir = this.__dir__,
              isArr = isArray(array),
              isRight = dir < 0,
              arrLength = isArr ? array.length : 0,
              view = getView(0, arrLength, this.__views__),
              start = view.start,
              end = view.end,
              length = end - start,
              index = isRight ? end : (start - 1),
              iteratees = this.__iteratees__,
              iterLength = iteratees.length,
              resIndex = 0,
              takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || arrLength < LARGE_ARRAY_SIZE || (arrLength == length && takeCount == length)) {
            return baseWrapperValue((isRight && isArr) ? array.reverse() : array, this.__actions__);
          }
          var result = [];
          outer: while (length-- && resIndex < takeCount) {
            index += dir;
            var iterIndex = -1,
                value = array[index];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex],
                  iteratee = data.iteratee,
                  type = data.type,
                  computed = iteratee(value);
              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result[resIndex++] = value;
          }
          return result;
        }
        function MapCache() {
          this.__data__ = {};
        }
        function mapDelete(key) {
          return this.has(key) && delete this.__data__[key];
        }
        function mapGet(key) {
          return key == '__proto__' ? undefined : this.__data__[key];
        }
        function mapHas(key) {
          return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
        }
        function mapSet(key, value) {
          if (key != '__proto__') {
            this.__data__[key] = value;
          }
          return this;
        }
        function SetCache(values) {
          var length = values ? values.length : 0;
          this.data = {
            'hash': nativeCreate(null),
            'set': new Set
          };
          while (length--) {
            this.push(values[length]);
          }
        }
        function cacheIndexOf(cache, value) {
          var data = cache.data,
              result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];
          return result ? 0 : -1;
        }
        function cachePush(value) {
          var data = this.data;
          if (typeof value == 'string' || isObject(value)) {
            data.set.add(value);
          } else {
            data.hash[value] = true;
          }
        }
        function arrayConcat(array, other) {
          var index = -1,
              length = array.length,
              othIndex = -1,
              othLength = other.length,
              result = Array(length + othLength);
          while (++index < length) {
            result[index] = array[index];
          }
          while (++othIndex < othLength) {
            result[index++] = other[othIndex];
          }
          return result;
        }
        function arrayCopy(source, array) {
          var index = -1,
              length = source.length;
          array || (array = Array(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function arrayEach(array, iteratee) {
          var index = -1,
              length = array.length;
          while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEachRight(array, iteratee) {
          var length = array.length;
          while (length--) {
            if (iteratee(array[length], length, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEvery(array, predicate) {
          var index = -1,
              length = array.length;
          while (++index < length) {
            if (!predicate(array[index], index, array)) {
              return false;
            }
          }
          return true;
        }
        function arrayExtremum(array, iteratee, comparator, exValue) {
          var index = -1,
              length = array.length,
              computed = exValue,
              result = computed;
          while (++index < length) {
            var value = array[index],
                current = +iteratee(value);
            if (comparator(current, computed)) {
              computed = current;
              result = value;
            }
          }
          return result;
        }
        function arrayFilter(array, predicate) {
          var index = -1,
              length = array.length,
              resIndex = -1,
              result = [];
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result[++resIndex] = value;
            }
          }
          return result;
        }
        function arrayMap(array, iteratee) {
          var index = -1,
              length = array.length,
              result = Array(length);
          while (++index < length) {
            result[index] = iteratee(array[index], index, array);
          }
          return result;
        }
        function arrayPush(array, values) {
          var index = -1,
              length = values.length,
              offset = array.length;
          while (++index < length) {
            array[offset + index] = values[index];
          }
          return array;
        }
        function arrayReduce(array, iteratee, accumulator, initFromArray) {
          var index = -1,
              length = array.length;
          if (initFromArray && length) {
            accumulator = array[++index];
          }
          while (++index < length) {
            accumulator = iteratee(accumulator, array[index], index, array);
          }
          return accumulator;
        }
        function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
          var length = array.length;
          if (initFromArray && length) {
            accumulator = array[--length];
          }
          while (length--) {
            accumulator = iteratee(accumulator, array[length], length, array);
          }
          return accumulator;
        }
        function arraySome(array, predicate) {
          var index = -1,
              length = array.length;
          while (++index < length) {
            if (predicate(array[index], index, array)) {
              return true;
            }
          }
          return false;
        }
        function arraySum(array, iteratee) {
          var length = array.length,
              result = 0;
          while (length--) {
            result += +iteratee(array[length]) || 0;
          }
          return result;
        }
        function assignDefaults(objectValue, sourceValue) {
          return objectValue === undefined ? sourceValue : objectValue;
        }
        function assignOwnDefaults(objectValue, sourceValue, key, object) {
          return (objectValue === undefined || !hasOwnProperty.call(object, key)) ? sourceValue : objectValue;
        }
        function assignWith(object, source, customizer) {
          var index = -1,
              props = keys(source),
              length = props.length;
          while (++index < length) {
            var key = props[index],
                value = object[key],
                result = customizer(value, source[key], key, object, source);
            if ((result === result ? (result !== value) : (value === value)) || (value === undefined && !(key in object))) {
              object[key] = result;
            }
          }
          return object;
        }
        function baseAssign(object, source) {
          return source == null ? object : baseCopy(source, keys(source), object);
        }
        function baseAt(collection, props) {
          var index = -1,
              isNil = collection == null,
              isArr = !isNil && isArrayLike(collection),
              length = isArr ? collection.length : 0,
              propsLength = props.length,
              result = Array(propsLength);
          while (++index < propsLength) {
            var key = props[index];
            if (isArr) {
              result[index] = isIndex(key, length) ? collection[key] : undefined;
            } else {
              result[index] = isNil ? undefined : collection[key];
            }
          }
          return result;
        }
        function baseCopy(source, props, object) {
          object || (object = {});
          var index = -1,
              length = props.length;
          while (++index < length) {
            var key = props[index];
            object[key] = source[key];
          }
          return object;
        }
        function baseCallback(func, thisArg, argCount) {
          var type = typeof func;
          if (type == 'function') {
            return thisArg === undefined ? func : bindCallback(func, thisArg, argCount);
          }
          if (func == null) {
            return identity;
          }
          if (type == 'object') {
            return baseMatches(func);
          }
          return thisArg === undefined ? property(func) : baseMatchesProperty(func, thisArg);
        }
        function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
          var result;
          if (customizer) {
            result = object ? customizer(value, key, object) : customizer(value);
          }
          if (result !== undefined) {
            return result;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result = initCloneArray(value);
            if (!isDeep) {
              return arrayCopy(value, result);
            }
          } else {
            var tag = objToString.call(value),
                isFunc = tag == funcTag;
            if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
              result = initCloneObject(isFunc ? {} : value);
              if (!isDeep) {
                return baseAssign(result, value);
              }
            } else {
              return cloneableTags[tag] ? initCloneByTag(value, tag, isDeep) : (object ? value : {});
            }
          }
          stackA || (stackA = []);
          stackB || (stackB = []);
          var length = stackA.length;
          while (length--) {
            if (stackA[length] == value) {
              return stackB[length];
            }
          }
          stackA.push(value);
          stackB.push(result);
          (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
            result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
          });
          return result;
        }
        var baseCreate = (function() {
          function object() {}
          return function(prototype) {
            if (isObject(prototype)) {
              object.prototype = prototype;
              var result = new object;
              object.prototype = undefined;
            }
            return result || {};
          };
        }());
        function baseDelay(func, wait, args) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return setTimeout(function() {
            func.apply(undefined, args);
          }, wait);
        }
        function baseDifference(array, values) {
          var length = array ? array.length : 0,
              result = [];
          if (!length) {
            return result;
          }
          var index = -1,
              indexOf = getIndexOf(),
              isCommon = indexOf == baseIndexOf,
              cache = (isCommon && values.length >= LARGE_ARRAY_SIZE) ? createCache(values) : null,
              valuesLength = values.length;
          if (cache) {
            indexOf = cacheIndexOf;
            isCommon = false;
            values = cache;
          }
          outer: while (++index < length) {
            var value = array[index];
            if (isCommon && value === value) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values[valuesIndex] === value) {
                  continue outer;
                }
              }
              result.push(value);
            } else if (indexOf(values, value, 0) < 0) {
              result.push(value);
            }
          }
          return result;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result = true;
          baseEach(collection, function(value, index, collection) {
            result = !!predicate(value, index, collection);
            return result;
          });
          return result;
        }
        function baseExtremum(collection, iteratee, comparator, exValue) {
          var computed = exValue,
              result = computed;
          baseEach(collection, function(value, index, collection) {
            var current = +iteratee(value, index, collection);
            if (comparator(current, computed) || (current === exValue && current === result)) {
              computed = current;
              result = value;
            }
          });
          return result;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = start == null ? 0 : (+start || 0);
          if (start < 0) {
            start = -start > length ? 0 : (length + start);
          }
          end = (end === undefined || end > length) ? length : (+end || 0);
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : (end >>> 0);
          start >>>= 0;
          while (start < length) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result = [];
          baseEach(collection, function(value, index, collection) {
            if (predicate(value, index, collection)) {
              result.push(value);
            }
          });
          return result;
        }
        function baseFind(collection, predicate, eachFunc, retKey) {
          var result;
          eachFunc(collection, function(value, key, collection) {
            if (predicate(value, key, collection)) {
              result = retKey ? key : value;
              return false;
            }
          });
          return result;
        }
        function baseFlatten(array, isDeep, isStrict, result) {
          result || (result = []);
          var index = -1,
              length = array.length;
          while (++index < length) {
            var value = array[index];
            if (isObjectLike(value) && isArrayLike(value) && (isStrict || isArray(value) || isArguments(value))) {
              if (isDeep) {
                baseFlatten(value, isDeep, isStrict, result);
              } else {
                arrayPush(result, value);
              }
            } else if (!isStrict) {
              result[result.length] = value;
            }
          }
          return result;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForIn(object, iteratee) {
          return baseFor(object, iteratee, keysIn);
        }
        function baseForOwn(object, iteratee) {
          return baseFor(object, iteratee, keys);
        }
        function baseForOwnRight(object, iteratee) {
          return baseForRight(object, iteratee, keys);
        }
        function baseFunctions(object, props) {
          var index = -1,
              length = props.length,
              resIndex = -1,
              result = [];
          while (++index < length) {
            var key = props[index];
            if (isFunction(object[key])) {
              result[++resIndex] = key;
            }
          }
          return result;
        }
        function baseGet(object, path, pathKey) {
          if (object == null) {
            return;
          }
          if (pathKey !== undefined && pathKey in toObject(object)) {
            path = [pathKey];
          }
          var index = 0,
              length = path.length;
          while (object != null && index < length) {
            object = object[path[index++]];
          }
          return (index && index == length) ? object : undefined;
        }
        function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
        }
        function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
          var objIsArr = isArray(object),
              othIsArr = isArray(other),
              objTag = arrayTag,
              othTag = arrayTag;
          if (!objIsArr) {
            objTag = objToString.call(object);
            if (objTag == argsTag) {
              objTag = objectTag;
            } else if (objTag != objectTag) {
              objIsArr = isTypedArray(object);
            }
          }
          if (!othIsArr) {
            othTag = objToString.call(other);
            if (othTag == argsTag) {
              othTag = objectTag;
            } else if (othTag != objectTag) {
              othIsArr = isTypedArray(other);
            }
          }
          var objIsObj = objTag == objectTag,
              othIsObj = othTag == objectTag,
              isSameTag = objTag == othTag;
          if (isSameTag && !(objIsArr || objIsObj)) {
            return equalByTag(object, other, objTag);
          }
          if (!isLoose) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
            if (objIsWrapped || othIsWrapped) {
              return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stackA || (stackA = []);
          stackB || (stackB = []);
          var length = stackA.length;
          while (length--) {
            if (stackA[length] == object) {
              return stackB[length] == other;
            }
          }
          stackA.push(object);
          stackB.push(other);
          var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);
          stackA.pop();
          stackB.pop();
          return result;
        }
        function baseIsMatch(object, matchData, customizer) {
          var index = matchData.length,
              length = index,
              noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = toObject(object);
          while (index--) {
            var data = matchData[index];
            if ((noCustomizer && data[2]) ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0],
                objValue = object[key],
                srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined && !(key in object)) {
                return false;
              }
            } else {
              var result = customizer ? customizer(objValue, srcValue, key) : undefined;
              if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseMap(collection, iteratee) {
          var index = -1,
              result = isArrayLike(collection) ? Array(collection.length) : [];
          baseEach(collection, function(value, key, collection) {
            result[++index] = iteratee(value, key, collection);
          });
          return result;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            var key = matchData[0][0],
                value = matchData[0][1];
            return function(object) {
              if (object == null) {
                return false;
              }
              return object[key] === value && (value !== undefined || (key in toObject(object)));
            };
          }
          return function(object) {
            return baseIsMatch(object, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          var isArr = isArray(path),
              isCommon = isKey(path) && isStrictComparable(srcValue),
              pathKey = (path + '');
          path = toPath(path);
          return function(object) {
            if (object == null) {
              return false;
            }
            var key = pathKey;
            object = toObject(object);
            if ((isArr || !isCommon) && !(key in object)) {
              object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
              if (object == null) {
                return false;
              }
              key = last(path);
              object = toObject(object);
            }
            return object[key] === srcValue ? (srcValue !== undefined || (key in object)) : baseIsEqual(srcValue, object[key], undefined, true);
          };
        }
        function baseMerge(object, source, customizer, stackA, stackB) {
          if (!isObject(object)) {
            return object;
          }
          var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),
              props = isSrcArr ? undefined : keys(source);
          arrayEach(props || source, function(srcValue, key) {
            if (props) {
              key = srcValue;
              srcValue = source[key];
            }
            if (isObjectLike(srcValue)) {
              stackA || (stackA = []);
              stackB || (stackB = []);
              baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
            } else {
              var value = object[key],
                  result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
                  isCommon = result === undefined;
              if (isCommon) {
                result = srcValue;
              }
              if ((result !== undefined || (isSrcArr && !(key in object))) && (isCommon || (result === result ? (result !== value) : (value === value)))) {
                object[key] = result;
              }
            }
          });
          return object;
        }
        function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
          var length = stackA.length,
              srcValue = source[key];
          while (length--) {
            if (stackA[length] == srcValue) {
              object[key] = stackB[length];
              return;
            }
          }
          var value = object[key],
              result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
              isCommon = result === undefined;
          if (isCommon) {
            result = srcValue;
            if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {
              result = isArray(value) ? value : (isArrayLike(value) ? arrayCopy(value) : []);
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              result = isArguments(value) ? toPlainObject(value) : (isPlainObject(value) ? value : {});
            } else {
              isCommon = false;
            }
          }
          stackA.push(srcValue);
          stackB.push(result);
          if (isCommon) {
            object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
          } else if (result === result ? (result !== value) : (value === value)) {
            object[key] = result;
          }
        }
        function baseProperty(key) {
          return function(object) {
            return object == null ? undefined : object[key];
          };
        }
        function basePropertyDeep(path) {
          var pathKey = (path + '');
          path = toPath(path);
          return function(object) {
            return baseGet(object, path, pathKey);
          };
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0;
          while (length--) {
            var index = indexes[length];
            if (index != previous && isIndex(index)) {
              var previous = index;
              splice.call(array, index, 1);
            }
          }
          return array;
        }
        function baseRandom(min, max) {
          return min + nativeFloor(nativeRandom() * (max - min + 1));
        }
        function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
          eachFunc(collection, function(value, index, collection) {
            accumulator = initFromCollection ? (initFromCollection = false, value) : iteratee(accumulator, value, index, collection);
          });
          return accumulator;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        function baseSlice(array, start, end) {
          var index = -1,
              length = array.length;
          start = start == null ? 0 : (+start || 0);
          if (start < 0) {
            start = -start > length ? 0 : (length + start);
          }
          end = (end === undefined || end > length) ? length : (+end || 0);
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : ((end - start) >>> 0);
          start >>>= 0;
          var result = Array(length);
          while (++index < length) {
            result[index] = array[index + start];
          }
          return result;
        }
        function baseSome(collection, predicate) {
          var result;
          baseEach(collection, function(value, index, collection) {
            result = predicate(value, index, collection);
            return !result;
          });
          return !!result;
        }
        function baseSortBy(array, comparer) {
          var length = array.length;
          array.sort(comparer);
          while (length--) {
            array[length] = array[length].value;
          }
          return array;
        }
        function baseSortByOrder(collection, iteratees, orders) {
          var callback = getCallback(),
              index = -1;
          iteratees = arrayMap(iteratees, function(iteratee) {
            return callback(iteratee);
          });
          var result = baseMap(collection, function(value) {
            var criteria = arrayMap(iteratees, function(iteratee) {
              return iteratee(value);
            });
            return {
              'criteria': criteria,
              'index': ++index,
              'value': value
            };
          });
          return baseSortBy(result, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function baseSum(collection, iteratee) {
          var result = 0;
          baseEach(collection, function(value, index, collection) {
            result += +iteratee(value, index, collection) || 0;
          });
          return result;
        }
        function baseUniq(array, iteratee) {
          var index = -1,
              indexOf = getIndexOf(),
              length = array.length,
              isCommon = indexOf == baseIndexOf,
              isLarge = isCommon && length >= LARGE_ARRAY_SIZE,
              seen = isLarge ? createCache() : null,
              result = [];
          if (seen) {
            indexOf = cacheIndexOf;
            isCommon = false;
          } else {
            isLarge = false;
            seen = iteratee ? [] : result;
          }
          outer: while (++index < length) {
            var value = array[index],
                computed = iteratee ? iteratee(value, index, array) : value;
            if (isCommon && value === value) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee) {
                seen.push(computed);
              }
              result.push(value);
            } else if (indexOf(seen, computed, 0) < 0) {
              if (iteratee || isLarge) {
                seen.push(computed);
              }
              result.push(value);
            }
          }
          return result;
        }
        function baseValues(object, props) {
          var index = -1,
              length = props.length,
              result = Array(length);
          while (++index < length) {
            result[index] = object[props[index]];
          }
          return result;
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length,
              index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}
          return isDrop ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length)) : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
        }
        function baseWrapperValue(value, actions) {
          var result = value;
          if (result instanceof LazyWrapper) {
            result = result.value();
          }
          var index = -1,
              length = actions.length;
          while (++index < length) {
            var action = actions[index];
            result = action.func.apply(action.thisArg, arrayPush([result], action.args));
          }
          return result;
        }
        function binaryIndex(array, value, retHighest) {
          var low = 0,
              high = array ? array.length : low;
          if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = (low + high) >>> 1,
                  computed = array[mid];
              if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return binaryIndexBy(array, value, identity, retHighest);
        }
        function binaryIndexBy(array, value, iteratee, retHighest) {
          value = iteratee(value);
          var low = 0,
              high = array ? array.length : 0,
              valIsNaN = value !== value,
              valIsNull = value === null,
              valIsUndef = value === undefined;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2),
                computed = iteratee(array[mid]),
                isDef = computed !== undefined,
                isReflexive = computed === computed;
            if (valIsNaN) {
              var setLow = isReflexive || retHighest;
            } else if (valIsNull) {
              setLow = isReflexive && isDef && (retHighest || computed != null);
            } else if (valIsUndef) {
              setLow = isReflexive && (retHighest || isDef);
            } else if (computed == null) {
              setLow = false;
            } else {
              setLow = retHighest ? (computed <= value) : (computed < value);
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function bindCallback(func, thisArg, argCount) {
          if (typeof func != 'function') {
            return identity;
          }
          if (thisArg === undefined) {
            return func;
          }
          switch (argCount) {
            case 1:
              return function(value) {
                return func.call(thisArg, value);
              };
            case 3:
              return function(value, index, collection) {
                return func.call(thisArg, value, index, collection);
              };
            case 4:
              return function(accumulator, value, index, collection) {
                return func.call(thisArg, accumulator, value, index, collection);
              };
            case 5:
              return function(value, other, key, object, source) {
                return func.call(thisArg, value, other, key, object, source);
              };
          }
          return function() {
            return func.apply(thisArg, arguments);
          };
        }
        function bufferClone(buffer) {
          var result = new ArrayBuffer(buffer.byteLength),
              view = new Uint8Array(result);
          view.set(new Uint8Array(buffer));
          return result;
        }
        function composeArgs(args, partials, holders) {
          var holdersLength = holders.length,
              argsIndex = -1,
              argsLength = nativeMax(args.length - holdersLength, 0),
              leftIndex = -1,
              leftLength = partials.length,
              result = Array(leftLength + argsLength);
          while (++leftIndex < leftLength) {
            result[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            result[holders[argsIndex]] = args[argsIndex];
          }
          while (argsLength--) {
            result[leftIndex++] = args[argsIndex++];
          }
          return result;
        }
        function composeArgsRight(args, partials, holders) {
          var holdersIndex = -1,
              holdersLength = holders.length,
              argsIndex = -1,
              argsLength = nativeMax(args.length - holdersLength, 0),
              rightIndex = -1,
              rightLength = partials.length,
              result = Array(argsLength + rightLength);
          while (++argsIndex < argsLength) {
            result[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            result[offset + holders[holdersIndex]] = args[argsIndex++];
          }
          return result;
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee, thisArg) {
            var result = initializer ? initializer() : {};
            iteratee = getCallback(iteratee, thisArg, 3);
            if (isArray(collection)) {
              var index = -1,
                  length = collection.length;
              while (++index < length) {
                var value = collection[index];
                setter(result, value, iteratee(value, index, collection), collection);
              }
            } else {
              baseEach(collection, function(value, key, collection) {
                setter(result, value, iteratee(value, key, collection), collection);
              });
            }
            return result;
          };
        }
        function createAssigner(assigner) {
          return restParam(function(object, sources) {
            var index = -1,
                length = object == null ? 0 : sources.length,
                customizer = length > 2 ? sources[length - 2] : undefined,
                guard = length > 2 ? sources[2] : undefined,
                thisArg = length > 1 ? sources[length - 1] : undefined;
            if (typeof customizer == 'function') {
              customizer = bindCallback(customizer, thisArg, 5);
              length -= 2;
            } else {
              customizer = typeof thisArg == 'function' ? thisArg : undefined;
              length -= (customizer ? 1 : 0);
            }
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined : customizer;
              length = 1;
            }
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee) {
            var length = collection ? getLength(collection) : 0;
            if (!isLength(length)) {
              return eachFunc(collection, iteratee);
            }
            var index = fromRight ? length : -1,
                iterable = toObject(collection);
            while ((fromRight ? index-- : ++index < length)) {
              if (iteratee(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee, keysFunc) {
            var iterable = toObject(object),
                props = keysFunc(object),
                length = props.length,
                index = fromRight ? length : -1;
            while ((fromRight ? index-- : ++index < length)) {
              var key = props[index];
              if (iteratee(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBindWrapper(func, thisArg) {
          var Ctor = createCtorWrapper(func);
          function wrapper() {
            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
            return fn.apply(thisArg, arguments);
          }
          return wrapper;
        }
        function createCache(values) {
          return (nativeCreate && Set) ? new SetCache(values) : null;
        }
        function createCompounder(callback) {
          return function(string) {
            var index = -1,
                array = words(deburr(string)),
                length = array.length,
                result = '';
            while (++index < length) {
              result = callback(result, array[index], index);
            }
            return result;
          };
        }
        function createCtorWrapper(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor;
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype),
                result = Ctor.apply(thisBinding, args);
            return isObject(result) ? result : thisBinding;
          };
        }
        function createCurry(flag) {
          function curryFunc(func, arity, guard) {
            if (guard && isIterateeCall(func, arity, guard)) {
              arity = undefined;
            }
            var result = createWrapper(func, flag, undefined, undefined, undefined, undefined, undefined, arity);
            result.placeholder = curryFunc.placeholder;
            return result;
          }
          return curryFunc;
        }
        function createDefaults(assigner, customizer) {
          return restParam(function(args) {
            var object = args[0];
            if (object == null) {
              return object;
            }
            args.push(customizer);
            return assigner.apply(undefined, args);
          });
        }
        function createExtremum(comparator, exValue) {
          return function(collection, iteratee, thisArg) {
            if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
              iteratee = undefined;
            }
            iteratee = getCallback(iteratee, thisArg, 3);
            if (iteratee.length == 1) {
              collection = isArray(collection) ? collection : toIterable(collection);
              var result = arrayExtremum(collection, iteratee, comparator, exValue);
              if (!(collection.length && result === exValue)) {
                return result;
              }
            }
            return baseExtremum(collection, iteratee, comparator, exValue);
          };
        }
        function createFind(eachFunc, fromRight) {
          return function(collection, predicate, thisArg) {
            predicate = getCallback(predicate, thisArg, 3);
            if (isArray(collection)) {
              var index = baseFindIndex(collection, predicate, fromRight);
              return index > -1 ? collection[index] : undefined;
            }
            return baseFind(collection, predicate, eachFunc);
          };
        }
        function createFindIndex(fromRight) {
          return function(array, predicate, thisArg) {
            if (!(array && array.length)) {
              return -1;
            }
            predicate = getCallback(predicate, thisArg, 3);
            return baseFindIndex(array, predicate, fromRight);
          };
        }
        function createFindKey(objectFunc) {
          return function(object, predicate, thisArg) {
            predicate = getCallback(predicate, thisArg, 3);
            return baseFind(object, predicate, objectFunc, true);
          };
        }
        function createFlow(fromRight) {
          return function() {
            var wrapper,
                length = arguments.length,
                index = fromRight ? length : -1,
                leftIndex = 0,
                funcs = Array(length);
            while ((fromRight ? index-- : ++index < length)) {
              var func = funcs[leftIndex++] = arguments[index];
              if (typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
              }
              if (!wrapper && LodashWrapper.prototype.thru && getFuncName(func) == 'wrapper') {
                wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? -1 : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func),
                  data = funcName == 'wrapper' ? getData(func) : undefined;
              if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments,
                  value = args[0];
              if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
                return wrapper.plant(value).value();
              }
              var index = 0,
                  result = length ? funcs[index].apply(this, args) : value;
              while (++index < length) {
                result = funcs[index].call(this, result);
              }
              return result;
            };
          };
        }
        function createForEach(arrayFunc, eachFunc) {
          return function(collection, iteratee, thisArg) {
            return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection)) ? arrayFunc(collection, iteratee) : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
          };
        }
        function createForIn(objectFunc) {
          return function(object, iteratee, thisArg) {
            if (typeof iteratee != 'function' || thisArg !== undefined) {
              iteratee = bindCallback(iteratee, thisArg, 3);
            }
            return objectFunc(object, iteratee, keysIn);
          };
        }
        function createForOwn(objectFunc) {
          return function(object, iteratee, thisArg) {
            if (typeof iteratee != 'function' || thisArg !== undefined) {
              iteratee = bindCallback(iteratee, thisArg, 3);
            }
            return objectFunc(object, iteratee);
          };
        }
        function createObjectMapper(isMapKeys) {
          return function(object, iteratee, thisArg) {
            var result = {};
            iteratee = getCallback(iteratee, thisArg, 3);
            baseForOwn(object, function(value, key, object) {
              var mapped = iteratee(value, key, object);
              key = isMapKeys ? mapped : key;
              value = isMapKeys ? value : mapped;
              result[key] = value;
            });
            return result;
          };
        }
        function createPadDir(fromRight) {
          return function(string, length, chars) {
            string = baseToString(string);
            return (fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string);
          };
        }
        function createPartial(flag) {
          var partialFunc = restParam(function(func, partials) {
            var holders = replaceHolders(partials, partialFunc.placeholder);
            return createWrapper(func, flag, undefined, partials, holders);
          });
          return partialFunc;
        }
        function createReduce(arrayFunc, eachFunc) {
          return function(collection, iteratee, accumulator, thisArg) {
            var initFromArray = arguments.length < 3;
            return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection)) ? arrayFunc(collection, iteratee, accumulator, initFromArray) : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
          };
        }
        function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
          var isAry = bitmask & ARY_FLAG,
              isBind = bitmask & BIND_FLAG,
              isBindKey = bitmask & BIND_KEY_FLAG,
              isCurry = bitmask & CURRY_FLAG,
              isCurryBound = bitmask & CURRY_BOUND_FLAG,
              isCurryRight = bitmask & CURRY_RIGHT_FLAG,
              Ctor = isBindKey ? undefined : createCtorWrapper(func);
          function wrapper() {
            var length = arguments.length,
                index = length,
                args = Array(length);
            while (index--) {
              args[index] = arguments[index];
            }
            if (partials) {
              args = composeArgs(args, partials, holders);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight);
            }
            if (isCurry || isCurryRight) {
              var placeholder = wrapper.placeholder,
                  argsHolders = replaceHolders(args, placeholder);
              length -= argsHolders.length;
              if (length < arity) {
                var newArgPos = argPos ? arrayCopy(argPos) : undefined,
                    newArity = nativeMax(arity - length, 0),
                    newsHolders = isCurry ? argsHolders : undefined,
                    newHoldersRight = isCurry ? undefined : argsHolders,
                    newPartials = isCurry ? args : undefined,
                    newPartialsRight = isCurry ? undefined : args;
                bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
                bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);
                if (!isCurryBound) {
                  bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
                }
                var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],
                    result = createHybridWrapper.apply(undefined, newData);
                if (isLaziable(func)) {
                  setData(result, newData);
                }
                result.placeholder = placeholder;
                return result;
              }
            }
            var thisBinding = isBind ? thisArg : this,
                fn = isBindKey ? thisBinding[func] : func;
            if (argPos) {
              args = reorder(args, argPos);
            }
            if (isAry && ary < args.length) {
              args.length = ary;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtorWrapper(func);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createPadding(string, length, chars) {
          var strLength = string.length;
          length = +length;
          if (strLength >= length || !nativeIsFinite(length)) {
            return '';
          }
          var padLength = length - strLength;
          chars = chars == null ? ' ' : (chars + '');
          return repeat(chars, nativeCeil(padLength / chars.length)).slice(0, padLength);
        }
        function createPartialWrapper(func, bitmask, thisArg, partials) {
          var isBind = bitmask & BIND_FLAG,
              Ctor = createCtorWrapper(func);
          function wrapper() {
            var argsIndex = -1,
                argsLength = arguments.length,
                leftIndex = -1,
                leftLength = partials.length,
                args = Array(leftLength + argsLength);
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRound(methodName) {
          var func = Math[methodName];
          return function(number, precision) {
            precision = precision === undefined ? 0 : (+precision || 0);
            if (precision) {
              precision = pow(10, precision);
              return func(number * precision) / precision;
            }
            return func(number);
          };
        }
        function createSortedIndex(retHighest) {
          return function(array, value, iteratee, thisArg) {
            var callback = getCallback(iteratee);
            return (iteratee == null && callback === baseCallback) ? binaryIndex(array, value, retHighest) : binaryIndexBy(array, value, callback(iteratee, thisArg, 1), retHighest);
          };
        }
        function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
          var isBindKey = bitmask & BIND_KEY_FLAG;
          if (!isBindKey && typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
            partials = holders = undefined;
          }
          length -= (holders ? holders.length : 0);
          if (bitmask & PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials,
                holdersRight = holders;
            partials = holders = undefined;
          }
          var data = isBindKey ? undefined : getData(func),
              newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];
          if (data) {
            mergeData(newData, data);
            bitmask = newData[1];
            arity = newData[9];
          }
          newData[9] = arity == null ? (isBindKey ? 0 : func.length) : (nativeMax(arity - length, 0) || 0);
          if (bitmask == BIND_FLAG) {
            var result = createBindWrapper(newData[0], newData[2]);
          } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
            result = createPartialWrapper.apply(undefined, newData);
          } else {
            result = createHybridWrapper.apply(undefined, newData);
          }
          var setter = data ? baseSetData : setData;
          return setter(result, newData);
        }
        function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
          var index = -1,
              arrLength = array.length,
              othLength = other.length;
          if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
            return false;
          }
          while (++index < arrLength) {
            var arrValue = array[index],
                othValue = other[index],
                result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;
            if (result !== undefined) {
              if (result) {
                continue;
              }
              return false;
            }
            if (isLoose) {
              if (!arraySome(other, function(othValue) {
                return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
              })) {
                return false;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
              return false;
            }
          }
          return true;
        }
        function equalByTag(object, other, tag) {
          switch (tag) {
            case boolTag:
            case dateTag:
              return +object == +other;
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case numberTag:
              return (object != +object) ? other != +other : object == +other;
            case regexpTag:
            case stringTag:
              return object == (other + '');
          }
          return false;
        }
        function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
          var objProps = keys(object),
              objLength = objProps.length,
              othProps = keys(other),
              othLength = othProps.length;
          if (objLength != othLength && !isLoose) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var skipCtor = isLoose;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key],
                othValue = other[key],
                result = customizer ? customizer(isLoose ? othValue : objValue, isLoose ? objValue : othValue, key) : undefined;
            if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
              return false;
            }
            skipCtor || (skipCtor = key == 'constructor');
          }
          if (!skipCtor) {
            var objCtor = object.constructor,
                othCtor = other.constructor;
            if (objCtor != othCtor && ('constructor' in object && 'constructor' in other) && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
              return false;
            }
          }
          return true;
        }
        function getCallback(func, thisArg, argCount) {
          var result = lodash.callback || callback;
          result = result === callback ? baseCallback : result;
          return argCount ? result(func, thisArg, argCount) : result;
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result = func.name,
              array = realNames[result],
              length = array ? array.length : 0;
          while (length--) {
            var data = array[length],
                otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result;
        }
        function getIndexOf(collection, target, fromIndex) {
          var result = lodash.indexOf || indexOf;
          result = result === indexOf ? baseIndexOf : result;
          return collection ? result(collection, target, fromIndex) : result;
        }
        var getLength = baseProperty('length');
        function getMatchData(object) {
          var result = pairs(object),
              length = result.length;
          while (length--) {
            result[length][2] = isStrictComparable(result[length][1]);
          }
          return result;
        }
        function getNative(object, key) {
          var value = object == null ? undefined : object[key];
          return isNative(value) ? value : undefined;
        }
        function getView(start, end, transforms) {
          var index = -1,
              length = transforms.length;
          while (++index < length) {
            var data = transforms[index],
                size = data.size;
            switch (data.type) {
              case 'drop':
                start += size;
                break;
              case 'dropRight':
                end -= size;
                break;
              case 'take':
                end = nativeMin(end, start + size);
                break;
              case 'takeRight':
                start = nativeMax(start, end - size);
                break;
            }
          }
          return {
            'start': start,
            'end': end
          };
        }
        function initCloneArray(array) {
          var length = array.length,
              result = new array.constructor(length);
          if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
            result.index = array.index;
            result.input = array.input;
          }
          return result;
        }
        function initCloneObject(object) {
          var Ctor = object.constructor;
          if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
            Ctor = Object;
          }
          return new Ctor;
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return bufferClone(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              var buffer = object.buffer;
              return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              var result = new Ctor(object.source, reFlags.exec(object));
              result.lastIndex = object.lastIndex;
          }
          return result;
        }
        function invokePath(object, path, args) {
          if (object != null && !isKey(path, object)) {
            path = toPath(path);
            object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
            path = last(path);
          }
          var func = object == null ? object : object[path];
          return func == null ? undefined : func.apply(object, args);
        }
        function isArrayLike(value) {
          return value != null && isLength(getLength(value));
        }
        function isIndex(value, length) {
          value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return value > -1 && value % 1 == 0 && value < length;
        }
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == 'number' ? (isArrayLike(object) && isIndex(index, object.length)) : (type == 'string' && index in object)) {
            var other = object[index];
            return value === value ? (value === other) : (other !== other);
          }
          return false;
        }
        function isKey(value, object) {
          var type = typeof value;
          if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
            return true;
          }
          if (isArray(value)) {
            return false;
          }
          var result = !reIsDeepProp.test(value);
          return result || (object != null && value in toObject(object));
        }
        function isLaziable(func) {
          var funcName = getFuncName(func);
          if (!(funcName in LazyWrapper.prototype)) {
            return false;
          }
          var other = lodash[funcName];
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isLength(value) {
          return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        function mergeData(data, source) {
          var bitmask = data[1],
              srcBitmask = source[1],
              newBitmask = bitmask | srcBitmask,
              isCommon = newBitmask < ARY_FLAG;
          var isCombo = (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) || (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) || (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
          }
          value = source[7];
          if (value) {
            data[7] = arrayCopy(value);
          }
          if (srcBitmask & ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function mergeDefaults(objectValue, sourceValue) {
          return objectValue === undefined ? sourceValue : merge(objectValue, sourceValue, mergeDefaults);
        }
        function pickByArray(object, props) {
          object = toObject(object);
          var index = -1,
              length = props.length,
              result = {};
          while (++index < length) {
            var key = props[index];
            if (key in object) {
              result[key] = object[key];
            }
          }
          return result;
        }
        function pickByCallback(object, predicate) {
          var result = {};
          baseForIn(object, function(value, key, object) {
            if (predicate(value, key, object)) {
              result[key] = value;
            }
          });
          return result;
        }
        function reorder(array, indexes) {
          var arrLength = array.length,
              length = nativeMin(indexes.length, arrLength),
              oldArray = arrayCopy(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
          }
          return array;
        }
        var setData = (function() {
          var count = 0,
              lastCalled = 0;
          return function(key, value) {
            var stamp = now(),
                remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return key;
              }
            } else {
              count = 0;
            }
            return baseSetData(key, value);
          };
        }());
        function shimKeys(object) {
          var props = keysIn(object),
              propsLength = props.length,
              length = propsLength && object.length;
          var allowIndexes = !!length && isLength(length) && (isArray(object) || isArguments(object));
          var index = -1,
              result = [];
          while (++index < propsLength) {
            var key = props[index];
            if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
              result.push(key);
            }
          }
          return result;
        }
        function toIterable(value) {
          if (value == null) {
            return [];
          }
          if (!isArrayLike(value)) {
            return values(value);
          }
          return isObject(value) ? value : Object(value);
        }
        function toObject(value) {
          return isObject(value) ? value : Object(value);
        }
        function toPath(value) {
          if (isArray(value)) {
            return value;
          }
          var result = [];
          baseToString(value).replace(rePropName, function(match, number, quote, string) {
            result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
          });
          return result;
        }
        function wrapperClone(wrapper) {
          return wrapper instanceof LazyWrapper ? wrapper.clone() : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
        }
        function chunk(array, size, guard) {
          if (guard ? isIterateeCall(array, size, guard) : size == null) {
            size = 1;
          } else {
            size = nativeMax(nativeFloor(size) || 1, 1);
          }
          var index = 0,
              length = array ? array.length : 0,
              resIndex = -1,
              result = Array(nativeCeil(length / size));
          while (index < length) {
            result[++resIndex] = baseSlice(array, index, (index += size));
          }
          return result;
        }
        function compact(array) {
          var index = -1,
              length = array ? array.length : 0,
              resIndex = -1,
              result = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result[++resIndex] = value;
            }
          }
          return result;
        }
        var difference = restParam(function(array, values) {
          return (isObjectLike(array) && isArrayLike(array)) ? baseDifference(array, baseFlatten(values, false, true)) : [];
        });
        function drop(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          return baseSlice(array, n < 0 ? 0 : n);
        }
        function dropRight(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          n = length - (+n || 0);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate, thisArg) {
          return (array && array.length) ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true) : [];
        }
        function dropWhile(array, predicate, thisArg) {
          return (array && array.length) ? baseWhile(array, getCallback(predicate, thisArg, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        var findIndex = createFindIndex();
        var findLastIndex = createFindIndex(true);
        function first(array) {
          return array ? array[0] : undefined;
        }
        function flatten(array, isDeep, guard) {
          var length = array ? array.length : 0;
          if (guard && isIterateeCall(array, isDeep, guard)) {
            isDeep = false;
          }
          return length ? baseFlatten(array, isDeep) : [];
        }
        function flattenDeep(array) {
          var length = array ? array.length : 0;
          return length ? baseFlatten(array, true) : [];
        }
        function indexOf(array, value, fromIndex) {
          var length = array ? array.length : 0;
          if (!length) {
            return -1;
          }
          if (typeof fromIndex == 'number') {
            fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
          } else if (fromIndex) {
            var index = binaryIndex(array, value);
            if (index < length && (value === value ? (value === array[index]) : (array[index] !== array[index]))) {
              return index;
            }
            return -1;
          }
          return baseIndexOf(array, value, fromIndex || 0);
        }
        function initial(array) {
          return dropRight(array, 1);
        }
        var intersection = restParam(function(arrays) {
          var othLength = arrays.length,
              othIndex = othLength,
              caches = Array(length),
              indexOf = getIndexOf(),
              isCommon = indexOf == baseIndexOf,
              result = [];
          while (othIndex--) {
            var value = arrays[othIndex] = isArrayLike(value = arrays[othIndex]) ? value : [];
            caches[othIndex] = (isCommon && value.length >= 120) ? createCache(othIndex && value) : null;
          }
          var array = arrays[0],
              index = -1,
              length = array ? array.length : 0,
              seen = caches[0];
          outer: while (++index < length) {
            value = array[index];
            if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
              var othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(value);
              }
              result.push(value);
            }
          }
          return result;
        });
        function last(array) {
          var length = array ? array.length : 0;
          return length ? array[length - 1] : undefined;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array ? array.length : 0;
          if (!length) {
            return -1;
          }
          var index = length;
          if (typeof fromIndex == 'number') {
            index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
          } else if (fromIndex) {
            index = binaryIndex(array, value, true) - 1;
            var other = array[index];
            if (value === value ? (value === other) : (other !== other)) {
              return index;
            }
            return -1;
          }
          if (value !== value) {
            return indexOfNaN(array, index, true);
          }
          while (index--) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }
        function pull() {
          var args = arguments,
              array = args[0];
          if (!(array && array.length)) {
            return array;
          }
          var index = 0,
              indexOf = getIndexOf(),
              length = args.length;
          while (++index < length) {
            var fromIndex = 0,
                value = args[index];
            while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        var pullAt = restParam(function(array, indexes) {
          indexes = baseFlatten(indexes);
          var result = baseAt(array, indexes);
          basePullAt(array, indexes.sort(baseCompareAscending));
          return result;
        });
        function remove(array, predicate, thisArg) {
          var result = [];
          if (!(array && array.length)) {
            return result;
          }
          var index = -1,
              indexes = [],
              length = array.length;
          predicate = getCallback(predicate, thisArg, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result;
        }
        function rest(array) {
          return drop(array, 1);
        }
        function slice(array, start, end) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          }
          return baseSlice(array, start, end);
        }
        var sortedIndex = createSortedIndex();
        var sortedLastIndex = createSortedIndex(true);
        function take(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          n = length - (+n || 0);
          return baseSlice(array, n < 0 ? 0 : n);
        }
        function takeRightWhile(array, predicate, thisArg) {
          return (array && array.length) ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true) : [];
        }
        function takeWhile(array, predicate, thisArg) {
          return (array && array.length) ? baseWhile(array, getCallback(predicate, thisArg, 3)) : [];
        }
        var union = restParam(function(arrays) {
          return baseUniq(baseFlatten(arrays, false, true));
        });
        function uniq(array, isSorted, iteratee, thisArg) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (isSorted != null && typeof isSorted != 'boolean') {
            thisArg = iteratee;
            iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;
            isSorted = false;
          }
          var callback = getCallback();
          if (!(iteratee == null && callback === baseCallback)) {
            iteratee = callback(iteratee, thisArg, 3);
          }
          return (isSorted && getIndexOf() == baseIndexOf) ? sortedUniq(array, iteratee) : baseUniq(array, iteratee);
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var index = -1,
              length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLike(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          var result = Array(length);
          while (++index < length) {
            result[index] = arrayMap(array, baseProperty(index));
          }
          return result;
        }
        function unzipWith(array, iteratee, thisArg) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          var result = unzip(array);
          if (iteratee == null) {
            return result;
          }
          iteratee = bindCallback(iteratee, thisArg, 4);
          return arrayMap(result, function(group) {
            return arrayReduce(group, iteratee, undefined, true);
          });
        }
        var without = restParam(function(array, values) {
          return isArrayLike(array) ? baseDifference(array, values) : [];
        });
        function xor() {
          var index = -1,
              length = arguments.length;
          while (++index < length) {
            var array = arguments[index];
            if (isArrayLike(array)) {
              var result = result ? arrayPush(baseDifference(result, array), baseDifference(array, result)) : array;
            }
          }
          return result ? baseUniq(result) : [];
        }
        var zip = restParam(unzip);
        function zipObject(props, values) {
          var index = -1,
              length = props ? props.length : 0,
              result = {};
          if (length && !values && !isArray(props[0])) {
            values = [];
          }
          while (++index < length) {
            var key = props[index];
            if (values) {
              result[key] = values[index];
            } else if (key) {
              result[key[0]] = key[1];
            }
          }
          return result;
        }
        var zipWith = restParam(function(arrays) {
          var length = arrays.length,
              iteratee = length > 2 ? arrays[length - 2] : undefined,
              thisArg = length > 1 ? arrays[length - 1] : undefined;
          if (length > 2 && typeof iteratee == 'function') {
            length -= 2;
          } else {
            iteratee = (length > 1 && typeof thisArg == 'function') ? (--length, thisArg) : undefined;
            thisArg = undefined;
          }
          arrays.length = length;
          return unzipWith(arrays, iteratee, thisArg);
        });
        function chain(value) {
          var result = lodash(value);
          result.__chain__ = true;
          return result;
        }
        function tap(value, interceptor, thisArg) {
          interceptor.call(thisArg, value);
          return value;
        }
        function thru(value, interceptor, thisArg) {
          return interceptor.call(thisArg, value);
        }
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        var wrapperConcat = restParam(function(values) {
          values = baseFlatten(values);
          return this.thru(function(array) {
            return arrayConcat(isArray(array) ? array : [toObject(array)], values);
          });
        });
        function wrapperPlant(value) {
          var result,
              parent = this;
          while (parent instanceof baseLodash) {
            var clone = wrapperClone(parent);
            if (result) {
              previous.__wrapped__ = clone;
            } else {
              result = clone;
            }
            var previous = clone;
            parent = parent.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          var interceptor = function(value) {
            return (wrapped && wrapped.__dir__ < 0) ? value : value.reverse();
          };
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              'func': thru,
              'args': [interceptor],
              'thisArg': undefined
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(interceptor);
        }
        function wrapperToString() {
          return (this.value() + '');
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var at = restParam(function(collection, props) {
          return baseAt(collection, baseFlatten(props));
        });
        var countBy = createAggregator(function(result, value, key) {
          hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
        });
        function every(collection, predicate, thisArg) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
            predicate = undefined;
          }
          if (typeof predicate != 'function' || thisArg !== undefined) {
            predicate = getCallback(predicate, thisArg, 3);
          }
          return func(collection, predicate);
        }
        function filter(collection, predicate, thisArg) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          predicate = getCallback(predicate, thisArg, 3);
          return func(collection, predicate);
        }
        var find = createFind(baseEach);
        var findLast = createFind(baseEachRight, true);
        function findWhere(collection, source) {
          return find(collection, baseMatches(source));
        }
        var forEach = createForEach(arrayEach, baseEach);
        var forEachRight = createForEach(arrayEachRight, baseEachRight);
        var groupBy = createAggregator(function(result, value, key) {
          if (hasOwnProperty.call(result, key)) {
            result[key].push(value);
          } else {
            result[key] = [value];
          }
        });
        function includes(collection, target, fromIndex, guard) {
          var length = collection ? getLength(collection) : 0;
          if (!isLength(length)) {
            collection = values(collection);
            length = collection.length;
          }
          if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {
            fromIndex = 0;
          } else {
            fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
          }
          return (typeof collection == 'string' || !isArray(collection) && isString(collection)) ? (fromIndex <= length && collection.indexOf(target, fromIndex) > -1) : (!!length && getIndexOf(collection, target, fromIndex) > -1);
        }
        var indexBy = createAggregator(function(result, value, key) {
          result[key] = value;
        });
        var invoke = restParam(function(collection, path, args) {
          var index = -1,
              isFunc = typeof path == 'function',
              isProp = isKey(path),
              result = isArrayLike(collection) ? Array(collection.length) : [];
          baseEach(collection, function(value) {
            var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);
            result[++index] = func ? func.apply(value, args) : invokePath(value, path, args);
          });
          return result;
        });
        function map(collection, iteratee, thisArg) {
          var func = isArray(collection) ? arrayMap : baseMap;
          iteratee = getCallback(iteratee, thisArg, 3);
          return func(collection, iteratee);
        }
        var partition = createAggregator(function(result, value, key) {
          result[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function pluck(collection, path) {
          return map(collection, property(path));
        }
        var reduce = createReduce(arrayReduce, baseEach);
        var reduceRight = createReduce(arrayReduceRight, baseEachRight);
        function reject(collection, predicate, thisArg) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          predicate = getCallback(predicate, thisArg, 3);
          return func(collection, function(value, index, collection) {
            return !predicate(value, index, collection);
          });
        }
        function sample(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n == null) {
            collection = toIterable(collection);
            var length = collection.length;
            return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
          }
          var index = -1,
              result = toArray(collection),
              length = result.length,
              lastIndex = length - 1;
          n = nativeMin(n < 0 ? 0 : (+n || 0), length);
          while (++index < n) {
            var rand = baseRandom(index, lastIndex),
                value = result[rand];
            result[rand] = result[index];
            result[index] = value;
          }
          result.length = n;
          return result;
        }
        function shuffle(collection) {
          return sample(collection, POSITIVE_INFINITY);
        }
        function size(collection) {
          var length = collection ? getLength(collection) : 0;
          return isLength(length) ? length : keys(collection).length;
        }
        function some(collection, predicate, thisArg) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
            predicate = undefined;
          }
          if (typeof predicate != 'function' || thisArg !== undefined) {
            predicate = getCallback(predicate, thisArg, 3);
          }
          return func(collection, predicate);
        }
        function sortBy(collection, iteratee, thisArg) {
          if (collection == null) {
            return [];
          }
          if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
            iteratee = undefined;
          }
          var index = -1;
          iteratee = getCallback(iteratee, thisArg, 3);
          var result = baseMap(collection, function(value, key, collection) {
            return {
              'criteria': iteratee(value, key, collection),
              'index': ++index,
              'value': value
            };
          });
          return baseSortBy(result, compareAscending);
        }
        var sortByAll = restParam(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var guard = iteratees[2];
          if (guard && isIterateeCall(iteratees[0], iteratees[1], guard)) {
            iteratees.length = 1;
          }
          return baseSortByOrder(collection, baseFlatten(iteratees), []);
        });
        function sortByOrder(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (guard && isIterateeCall(iteratees, orders, guard)) {
            orders = undefined;
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseSortByOrder(collection, iteratees, orders);
        }
        function where(collection, source) {
          return filter(collection, baseMatches(source));
        }
        var now = nativeNow || function() {
          return new Date().getTime();
        };
        function after(n, func) {
          if (typeof func != 'function') {
            if (typeof n == 'function') {
              var temp = n;
              n = func;
              func = temp;
            } else {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
          }
          n = nativeIsFinite(n = +n) ? n : 0;
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          if (guard && isIterateeCall(func, n, guard)) {
            n = undefined;
          }
          n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
          return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
        }
        function before(n, func) {
          var result;
          if (typeof func != 'function') {
            if (typeof n == 'function') {
              var temp = n;
              n = func;
              func = temp;
            } else {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
          }
          return function() {
            if (--n > 0) {
              result = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined;
            }
            return result;
          };
        }
        var bind = restParam(function(func, thisArg, partials) {
          var bitmask = BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, bind.placeholder);
            bitmask |= PARTIAL_FLAG;
          }
          return createWrapper(func, bitmask, thisArg, partials, holders);
        });
        var bindAll = restParam(function(object, methodNames) {
          methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);
          var index = -1,
              length = methodNames.length;
          while (++index < length) {
            var key = methodNames[index];
            object[key] = createWrapper(object[key], BIND_FLAG, object);
          }
          return object;
        });
        var bindKey = restParam(function(object, key, partials) {
          var bitmask = BIND_FLAG | BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, bindKey.placeholder);
            bitmask |= PARTIAL_FLAG;
          }
          return createWrapper(key, bitmask, object, partials, holders);
        });
        var curry = createCurry(CURRY_FLAG);
        var curryRight = createCurry(CURRY_RIGHT_FLAG);
        function debounce(func, wait, options) {
          var args,
              maxTimeoutId,
              result,
              stamp,
              thisArg,
              timeoutId,
              trailingCall,
              lastCalled = 0,
              maxWait = false,
              trailing = true;
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          wait = wait < 0 ? 0 : (+wait || 0);
          if (options === true) {
            var leading = true;
            trailing = false;
          } else if (isObject(options)) {
            leading = !!options.leading;
            maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }
          function cancel() {
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            if (maxTimeoutId) {
              clearTimeout(maxTimeoutId);
            }
            lastCalled = 0;
            maxTimeoutId = timeoutId = trailingCall = undefined;
          }
          function complete(isCalled, id) {
            if (id) {
              clearTimeout(id);
            }
            maxTimeoutId = timeoutId = trailingCall = undefined;
            if (isCalled) {
              lastCalled = now();
              result = func.apply(thisArg, args);
              if (!timeoutId && !maxTimeoutId) {
                args = thisArg = undefined;
              }
            }
          }
          function delayed() {
            var remaining = wait - (now() - stamp);
            if (remaining <= 0 || remaining > wait) {
              complete(trailingCall, maxTimeoutId);
            } else {
              timeoutId = setTimeout(delayed, remaining);
            }
          }
          function maxDelayed() {
            complete(trailing, timeoutId);
          }
          function debounced() {
            args = arguments;
            stamp = now();
            thisArg = this;
            trailingCall = trailing && (timeoutId || !leading);
            if (maxWait === false) {
              var leadingCall = leading && !timeoutId;
            } else {
              if (!maxTimeoutId && !leading) {
                lastCalled = stamp;
              }
              var remaining = maxWait - (stamp - lastCalled),
                  isCalled = remaining <= 0 || remaining > maxWait;
              if (isCalled) {
                if (maxTimeoutId) {
                  maxTimeoutId = clearTimeout(maxTimeoutId);
                }
                lastCalled = stamp;
                result = func.apply(thisArg, args);
              } else if (!maxTimeoutId) {
                maxTimeoutId = setTimeout(maxDelayed, remaining);
              }
            }
            if (isCalled && timeoutId) {
              timeoutId = clearTimeout(timeoutId);
            } else if (!timeoutId && wait !== maxWait) {
              timeoutId = setTimeout(delayed, wait);
            }
            if (leadingCall) {
              isCalled = true;
              result = func.apply(thisArg, args);
            }
            if (isCalled && !timeoutId && !maxTimeoutId) {
              args = thisArg = undefined;
            }
            return result;
          }
          debounced.cancel = cancel;
          return debounced;
        }
        var defer = restParam(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = restParam(function(func, wait, args) {
          return baseDelay(func, wait, args);
        });
        var flow = createFlow();
        var flowRight = createFlow(true);
        function memoize(func, resolver) {
          if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments,
                key = resolver ? resolver.apply(this, args) : args[0],
                cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result = func.apply(this, args);
            memoized.cache = cache.set(key, result);
            return result;
          };
          memoized.cache = new memoize.Cache;
          return memoized;
        }
        var modArgs = restParam(function(func, transforms) {
          transforms = baseFlatten(transforms);
          if (typeof func != 'function' || !arrayEvery(transforms, baseIsFunction)) {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var length = transforms.length;
          return restParam(function(args) {
            var index = nativeMin(args.length, length);
            while (index--) {
              args[index] = transforms[index](args[index]);
            }
            return func.apply(this, args);
          });
        });
        function negate(predicate) {
          if (typeof predicate != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return function() {
            return !predicate.apply(this, arguments);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var partial = createPartial(PARTIAL_FLAG);
        var partialRight = createPartial(PARTIAL_RIGHT_FLAG);
        var rearg = restParam(function(func, indexes) {
          return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes));
        });
        function restParam(func, start) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
          return function() {
            var args = arguments,
                index = -1,
                length = nativeMax(args.length - start, 0),
                rest = Array(length);
            while (++index < length) {
              rest[index] = args[start + index];
            }
            switch (start) {
              case 0:
                return func.call(this, rest);
              case 1:
                return func.call(this, args[0], rest);
              case 2:
                return func.call(this, args[0], args[1], rest);
            }
            var otherArgs = Array(start + 1);
            index = -1;
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = rest;
            return func.apply(this, otherArgs);
          };
        }
        function spread(func) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return function(array) {
            return func.apply(this, array);
          };
        }
        function throttle(func, wait, options) {
          var leading = true,
              trailing = true;
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (options === false) {
            leading = false;
          } else if (isObject(options)) {
            leading = 'leading' in options ? !!options.leading : leading;
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            'leading': leading,
            'maxWait': +wait,
            'trailing': trailing
          });
        }
        function wrap(value, wrapper) {
          wrapper = wrapper == null ? identity : wrapper;
          return createWrapper(wrapper, PARTIAL_FLAG, undefined, [value], []);
        }
        function clone(value, isDeep, customizer, thisArg) {
          if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
            isDeep = false;
          } else if (typeof isDeep == 'function') {
            thisArg = customizer;
            customizer = isDeep;
            isDeep = false;
          }
          return typeof customizer == 'function' ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 1)) : baseClone(value, isDeep);
        }
        function cloneDeep(value, customizer, thisArg) {
          return typeof customizer == 'function' ? baseClone(value, true, bindCallback(customizer, thisArg, 1)) : baseClone(value, true);
        }
        function gt(value, other) {
          return value > other;
        }
        function gte(value, other) {
          return value >= other;
        }
        function isArguments(value) {
          return isObjectLike(value) && isArrayLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
        }
        var isArray = nativeIsArray || function(value) {
          return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
        };
        function isBoolean(value) {
          return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);
        }
        function isDate(value) {
          return isObjectLike(value) && objToString.call(value) == dateTag;
        }
        function isElement(value) {
          return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) || (isObjectLike(value) && isFunction(value.splice)))) {
            return !value.length;
          }
          return !keys(value).length;
        }
        function isEqual(value, other, customizer, thisArg) {
          customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
          var result = customizer ? customizer(value, other) : undefined;
          return result === undefined ? baseIsEqual(value, other, customizer) : !!result;
        }
        function isError(value) {
          return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;
        }
        function isFinite(value) {
          return typeof value == 'number' && nativeIsFinite(value);
        }
        function isFunction(value) {
          return isObject(value) && objToString.call(value) == funcTag;
        }
        function isObject(value) {
          var type = typeof value;
          return !!value && (type == 'object' || type == 'function');
        }
        function isMatch(object, source, customizer, thisArg) {
          customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
          return baseIsMatch(object, getMatchData(source), customizer);
        }
        function isNaN(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (value == null) {
            return false;
          }
          if (isFunction(value)) {
            return reIsNative.test(fnToString.call(value));
          }
          return isObjectLike(value) && reIsHostCtor.test(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNumber(value) {
          return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);
        }
        function isPlainObject(value) {
          var Ctor;
          if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isArguments(value)) || (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
            return false;
          }
          var result;
          baseForIn(value, function(subValue, key) {
            result = key;
          });
          return result === undefined || hasOwnProperty.call(value, result);
        }
        function isRegExp(value) {
          return isObject(value) && objToString.call(value) == regexpTag;
        }
        function isString(value) {
          return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
        }
        function isTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
        }
        function isUndefined(value) {
          return value === undefined;
        }
        function lt(value, other) {
          return value < other;
        }
        function lte(value, other) {
          return value <= other;
        }
        function toArray(value) {
          var length = value ? getLength(value) : 0;
          if (!isLength(length)) {
            return values(value);
          }
          if (!length) {
            return [];
          }
          return arrayCopy(value);
        }
        function toPlainObject(value) {
          return baseCopy(value, keysIn(value));
        }
        var merge = createAssigner(baseMerge);
        var assign = createAssigner(function(object, source, customizer) {
          return customizer ? assignWith(object, source, customizer) : baseAssign(object, source);
        });
        function create(prototype, properties, guard) {
          var result = baseCreate(prototype);
          if (guard && isIterateeCall(prototype, properties, guard)) {
            properties = undefined;
          }
          return properties ? baseAssign(result, properties) : result;
        }
        var defaults = createDefaults(assign, assignDefaults);
        var defaultsDeep = createDefaults(merge, mergeDefaults);
        var findKey = createFindKey(baseForOwn);
        var findLastKey = createFindKey(baseForOwnRight);
        var forIn = createForIn(baseFor);
        var forInRight = createForIn(baseForRight);
        var forOwn = createForOwn(baseForOwn);
        var forOwnRight = createForOwn(baseForOwnRight);
        function functions(object) {
          return baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result = object == null ? undefined : baseGet(object, toPath(path), path + '');
          return result === undefined ? defaultValue : result;
        }
        function has(object, path) {
          if (object == null) {
            return false;
          }
          var result = hasOwnProperty.call(object, path);
          if (!result && !isKey(path)) {
            path = toPath(path);
            object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
            if (object == null) {
              return false;
            }
            path = last(path);
            result = hasOwnProperty.call(object, path);
          }
          return result || (isLength(object.length) && isIndex(path, object.length) && (isArray(object) || isArguments(object)));
        }
        function invert(object, multiValue, guard) {
          if (guard && isIterateeCall(object, multiValue, guard)) {
            multiValue = undefined;
          }
          var index = -1,
              props = keys(object),
              length = props.length,
              result = {};
          while (++index < length) {
            var key = props[index],
                value = object[key];
            if (multiValue) {
              if (hasOwnProperty.call(result, value)) {
                result[value].push(key);
              } else {
                result[value] = [key];
              }
            } else {
              result[value] = key;
            }
          }
          return result;
        }
        var keys = !nativeKeys ? shimKeys : function(object) {
          var Ctor = object == null ? undefined : object.constructor;
          if ((typeof Ctor == 'function' && Ctor.prototype === object) || (typeof object != 'function' && isArrayLike(object))) {
            return shimKeys(object);
          }
          return isObject(object) ? nativeKeys(object) : [];
        };
        function keysIn(object) {
          if (object == null) {
            return [];
          }
          if (!isObject(object)) {
            object = Object(object);
          }
          var length = object.length;
          length = (length && isLength(length) && (isArray(object) || isArguments(object)) && length) || 0;
          var Ctor = object.constructor,
              index = -1,
              isProto = typeof Ctor == 'function' && Ctor.prototype === object,
              result = Array(length),
              skipIndexes = length > 0;
          while (++index < length) {
            result[index] = (index + '');
          }
          for (var key in object) {
            if (!(skipIndexes && isIndex(key, length)) && !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
              result.push(key);
            }
          }
          return result;
        }
        var mapKeys = createObjectMapper(true);
        var mapValues = createObjectMapper();
        var omit = restParam(function(object, props) {
          if (object == null) {
            return {};
          }
          if (typeof props[0] != 'function') {
            var props = arrayMap(baseFlatten(props), String);
            return pickByArray(object, baseDifference(keysIn(object), props));
          }
          var predicate = bindCallback(props[0], props[1], 3);
          return pickByCallback(object, function(value, key, object) {
            return !predicate(value, key, object);
          });
        });
        function pairs(object) {
          object = toObject(object);
          var index = -1,
              props = keys(object),
              length = props.length,
              result = Array(length);
          while (++index < length) {
            var key = props[index];
            result[index] = [key, object[key]];
          }
          return result;
        }
        var pick = restParam(function(object, props) {
          if (object == null) {
            return {};
          }
          return typeof props[0] == 'function' ? pickByCallback(object, bindCallback(props[0], props[1], 3)) : pickByArray(object, baseFlatten(props));
        });
        function result(object, path, defaultValue) {
          var result = object == null ? undefined : object[path];
          if (result === undefined) {
            if (object != null && !isKey(path, object)) {
              path = toPath(path);
              object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
              result = object == null ? undefined : object[last(path)];
            }
            result = result === undefined ? defaultValue : result;
          }
          return isFunction(result) ? result.call(object) : result;
        }
        function set(object, path, value) {
          if (object == null) {
            return object;
          }
          var pathKey = (path + '');
          path = (object[pathKey] != null || isKey(path, object)) ? [pathKey] : toPath(path);
          var index = -1,
              length = path.length,
              lastIndex = length - 1,
              nested = object;
          while (nested != null && ++index < length) {
            var key = path[index];
            if (isObject(nested)) {
              if (index == lastIndex) {
                nested[key] = value;
              } else if (nested[key] == null) {
                nested[key] = isIndex(path[index + 1]) ? [] : {};
              }
            }
            nested = nested[key];
          }
          return object;
        }
        function transform(object, iteratee, accumulator, thisArg) {
          var isArr = isArray(object) || isTypedArray(object);
          iteratee = getCallback(iteratee, thisArg, 4);
          if (accumulator == null) {
            if (isArr || isObject(object)) {
              var Ctor = object.constructor;
              if (isArr) {
                accumulator = isArray(object) ? new Ctor : [];
              } else {
                accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);
              }
            } else {
              accumulator = {};
            }
          }
          (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
            return iteratee(accumulator, value, index, object);
          });
          return accumulator;
        }
        function values(object) {
          return baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return baseValues(object, keysIn(object));
        }
        function inRange(value, start, end) {
          start = +start || 0;
          if (end === undefined) {
            end = start;
            start = 0;
          } else {
            end = +end || 0;
          }
          return value >= nativeMin(start, end) && value < nativeMax(start, end);
        }
        function random(min, max, floating) {
          if (floating && isIterateeCall(min, max, floating)) {
            max = floating = undefined;
          }
          var noMin = min == null,
              noMax = max == null;
          if (floating == null) {
            if (noMax && typeof min == 'boolean') {
              floating = min;
              min = 1;
            } else if (typeof max == 'boolean') {
              floating = max;
              noMax = true;
            }
          }
          if (noMin && noMax) {
            max = 1;
            noMax = false;
          }
          min = +min || 0;
          if (noMax) {
            max = min;
            min = 0;
          } else {
            max = +max || 0;
          }
          if (floating || min % 1 || max % 1) {
            var rand = nativeRandom();
            return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
          }
          return baseRandom(min, max);
        }
        var camelCase = createCompounder(function(result, word, index) {
          word = word.toLowerCase();
          return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
        });
        function capitalize(string) {
          string = baseToString(string);
          return string && (string.charAt(0).toUpperCase() + string.slice(1));
        }
        function deburr(string) {
          string = baseToString(string);
          return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
        }
        function endsWith(string, target, position) {
          string = baseToString(string);
          target = (target + '');
          var length = string.length;
          position = position === undefined ? length : nativeMin(position < 0 ? 0 : (+position || 0), length);
          position -= target.length;
          return position >= 0 && string.indexOf(target, position) == position;
        }
        function escape(string) {
          string = baseToString(string);
          return (string && reHasUnescapedHtml.test(string)) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = baseToString(string);
          return (string && reHasRegExpChars.test(string)) ? string.replace(reRegExpChars, escapeRegExpChar) : (string || '(?:)');
        }
        var kebabCase = createCompounder(function(result, word, index) {
          return result + (index ? '-' : '') + word.toLowerCase();
        });
        function pad(string, length, chars) {
          string = baseToString(string);
          length = +length;
          var strLength = string.length;
          if (strLength >= length || !nativeIsFinite(length)) {
            return string;
          }
          var mid = (length - strLength) / 2,
              leftLength = nativeFloor(mid),
              rightLength = nativeCeil(mid);
          chars = createPadding('', rightLength, chars);
          return chars.slice(0, leftLength) + string + chars;
        }
        var padLeft = createPadDir();
        var padRight = createPadDir(true);
        function parseInt(string, radix, guard) {
          if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          string = trim(string);
          return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
        }
        function repeat(string, n) {
          var result = '';
          string = baseToString(string);
          n = +n;
          if (n < 1 || !string || !nativeIsFinite(n)) {
            return result;
          }
          do {
            if (n % 2) {
              result += string;
            }
            n = nativeFloor(n / 2);
            string += string;
          } while (n);
          return result;
        }
        var snakeCase = createCompounder(function(result, word, index) {
          return result + (index ? '_' : '') + word.toLowerCase();
        });
        var startCase = createCompounder(function(result, word, index) {
          return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
        });
        function startsWith(string, target, position) {
          string = baseToString(string);
          position = position == null ? 0 : nativeMin(position < 0 ? 0 : (+position || 0), string.length);
          return string.lastIndexOf(target, position) == position;
        }
        function template(string, options, otherOptions) {
          var settings = lodash.templateSettings;
          if (otherOptions && isIterateeCall(string, options, otherOptions)) {
            options = otherOptions = undefined;
          }
          string = baseToString(string);
          options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);
          var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
              importsKeys = keys(imports),
              importsValues = baseValues(imports, importsKeys);
          var isEscaping,
              isEvaluating,
              index = 0,
              interpolate = options.interpolate || reNoMatch,
              source = "__p += '";
          var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g');
          var sourceURL = '//# sourceURL=' + ('sourceURL' in options ? options.sourceURL : ('lodash.templateSources[' + (++templateCounter) + ']')) + '\n';
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = options.variable;
          if (!variable) {
            source = 'with (obj) {\n' + source + '\n}\n';
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;');
          source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';
          var result = attempt(function() {
            return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
          });
          result.source = source;
          if (isError(result)) {
            throw result;
          }
          return result;
        }
        function trim(string, chars, guard) {
          var value = string;
          string = baseToString(string);
          if (!string) {
            return string;
          }
          if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
            return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
          }
          chars = (chars + '');
          return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
        }
        function trimLeft(string, chars, guard) {
          var value = string;
          string = baseToString(string);
          if (!string) {
            return string;
          }
          if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
            return string.slice(trimmedLeftIndex(string));
          }
          return string.slice(charsLeftIndex(string, (chars + '')));
        }
        function trimRight(string, chars, guard) {
          var value = string;
          string = baseToString(string);
          if (!string) {
            return string;
          }
          if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
            return string.slice(0, trimmedRightIndex(string) + 1);
          }
          return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
        }
        function trunc(string, options, guard) {
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined;
          }
          var length = DEFAULT_TRUNC_LENGTH,
              omission = DEFAULT_TRUNC_OMISSION;
          if (options != null) {
            if (isObject(options)) {
              var separator = 'separator' in options ? options.separator : separator;
              length = 'length' in options ? (+options.length || 0) : length;
              omission = 'omission' in options ? baseToString(options.omission) : omission;
            } else {
              length = +options || 0;
            }
          }
          string = baseToString(string);
          if (length >= string.length) {
            return string;
          }
          var end = length - omission.length;
          if (end < 1) {
            return omission;
          }
          var result = string.slice(0, end);
          if (separator == null) {
            return result + omission;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match,
                  newEnd,
                  substring = string.slice(0, end);
              if (!separator.global) {
                separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
              }
              separator.lastIndex = 0;
              while ((match = separator.exec(substring))) {
                newEnd = match.index;
              }
              result = result.slice(0, newEnd == null ? end : newEnd);
            }
          } else if (string.indexOf(separator, end) != end) {
            var index = result.lastIndexOf(separator);
            if (index > -1) {
              result = result.slice(0, index);
            }
          }
          return result + omission;
        }
        function unescape(string) {
          string = baseToString(string);
          return (string && reHasEscapedHtml.test(string)) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        function words(string, pattern, guard) {
          if (guard && isIterateeCall(string, pattern, guard)) {
            pattern = undefined;
          }
          string = baseToString(string);
          return string.match(pattern || reWords) || [];
        }
        var attempt = restParam(function(func, args) {
          try {
            return func.apply(undefined, args);
          } catch (e) {
            return isError(e) ? e : new Error(e);
          }
        });
        function callback(func, thisArg, guard) {
          if (guard && isIterateeCall(func, thisArg, guard)) {
            thisArg = undefined;
          }
          return isObjectLike(func) ? matches(func) : baseCallback(func, thisArg);
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function identity(value) {
          return value;
        }
        function matches(source) {
          return baseMatches(baseClone(source, true));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, true));
        }
        var method = restParam(function(path, args) {
          return function(object) {
            return invokePath(object, path, args);
          };
        });
        var methodOf = restParam(function(object, args) {
          return function(path) {
            return invokePath(object, path, args);
          };
        });
        function mixin(object, source, options) {
          if (options == null) {
            var isObj = isObject(source),
                props = isObj ? keys(source) : undefined,
                methodNames = (props && props.length) ? baseFunctions(source, props) : undefined;
            if (!(methodNames ? methodNames.length : isObj)) {
              methodNames = false;
              options = source;
              source = object;
              object = this;
            }
          }
          if (!methodNames) {
            methodNames = baseFunctions(source, keys(source));
          }
          var chain = true,
              index = -1,
              isFunc = isFunction(object),
              length = methodNames.length;
          if (options === false) {
            chain = false;
          } else if (isObject(options) && 'chain' in options) {
            chain = options.chain;
          }
          while (++index < length) {
            var methodName = methodNames[index],
                func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = (function(func) {
                return function() {
                  var chainAll = this.__chain__;
                  if (chain || chainAll) {
                    var result = object(this.__wrapped__),
                        actions = result.__actions__ = arrayCopy(this.__actions__);
                    actions.push({
                      'func': func,
                      'args': arguments,
                      'thisArg': object
                    });
                    result.__chain__ = chainAll;
                    return result;
                  }
                  return func.apply(object, arrayPush([this.value()], arguments));
                };
              }(func));
            }
          }
          return object;
        }
        function noConflict() {
          root._ = oldDash;
          return this;
        }
        function noop() {}
        function property(path) {
          return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return baseGet(object, toPath(path), path + '');
          };
        }
        function range(start, end, step) {
          if (step && isIterateeCall(start, end, step)) {
            end = step = undefined;
          }
          start = +start || 0;
          step = step == null ? 1 : (+step || 0);
          if (end == null) {
            end = start;
            start = 0;
          } else {
            end = +end || 0;
          }
          var index = -1,
              length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
              result = Array(length);
          while (++index < length) {
            result[index] = start;
            start += step;
          }
          return result;
        }
        function times(n, iteratee, thisArg) {
          n = nativeFloor(n);
          if (n < 1 || !nativeIsFinite(n)) {
            return [];
          }
          var index = -1,
              result = Array(nativeMin(n, MAX_ARRAY_LENGTH));
          iteratee = bindCallback(iteratee, thisArg, 1);
          while (++index < n) {
            if (index < MAX_ARRAY_LENGTH) {
              result[index] = iteratee(index);
            } else {
              iteratee(index);
            }
          }
          return result;
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return baseToString(prefix) + id;
        }
        function add(augend, addend) {
          return (+augend || 0) + (+addend || 0);
        }
        var ceil = createRound('ceil');
        var floor = createRound('floor');
        var max = createExtremum(gt, NEGATIVE_INFINITY);
        var min = createExtremum(lt, POSITIVE_INFINITY);
        var round = createRound('round');
        function sum(collection, iteratee, thisArg) {
          if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
            iteratee = undefined;
          }
          iteratee = getCallback(iteratee, thisArg, 3);
          return iteratee.length == 1 ? arraySum(isArray(collection) ? collection : toIterable(collection), iteratee) : baseSum(collection, iteratee);
        }
        lodash.prototype = baseLodash.prototype;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        MapCache.prototype['delete'] = mapDelete;
        MapCache.prototype.get = mapGet;
        MapCache.prototype.has = mapHas;
        MapCache.prototype.set = mapSet;
        SetCache.prototype.push = cachePush;
        memoize.Cache = MapCache;
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.callback = callback;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.functions = functions;
        lodash.groupBy = groupBy;
        lodash.indexBy = indexBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.invert = invert;
        lodash.invoke = invoke;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.modArgs = modArgs;
        lodash.negate = negate;
        lodash.omit = omit;
        lodash.once = once;
        lodash.pairs = pairs;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pluck = pluck;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.restParam = restParam;
        lodash.set = set;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortByAll = sortByAll;
        lodash.sortByOrder = sortByOrder;
        lodash.spread = spread;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.times = times;
        lodash.toArray = toArray;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.union = union;
        lodash.uniq = uniq;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.where = where;
        lodash.without = without;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipWith = zipWith;
        lodash.backflow = flowRight;
        lodash.collect = map;
        lodash.compose = flowRight;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.extend = assign;
        lodash.iteratee = callback;
        lodash.methods = functions;
        lodash.object = zipObject;
        lodash.select = filter;
        lodash.tail = rest;
        lodash.unique = uniq;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.deburr = deburr;
        lodash.endsWith = endsWith;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.findWhere = findWhere;
        lodash.first = first;
        lodash.floor = floor;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isBoolean = isBoolean;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isError = isError;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isMatch = isMatch;
        lodash.isNaN = isNaN;
        lodash.isNative = isNative;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isString = isString;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.min = min;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padLeft = padLeft;
        lodash.padRight = padRight;
        lodash.parseInt = parseInt;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.sum = sum;
        lodash.template = template;
        lodash.trim = trim;
        lodash.trimLeft = trimLeft;
        lodash.trimRight = trimRight;
        lodash.trunc = trunc;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.words = words;
        lodash.all = every;
        lodash.any = some;
        lodash.contains = includes;
        lodash.eq = isEqual;
        lodash.detect = find;
        lodash.foldl = reduce;
        lodash.foldr = reduceRight;
        lodash.head = first;
        lodash.include = includes;
        lodash.inject = reduce;
        mixin(lodash, (function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!lodash.prototype[methodName]) {
              source[methodName] = func;
            }
          });
          return source;
        }()), false);
        lodash.sample = sample;
        lodash.prototype.sample = function(n) {
          if (!this.__chain__ && n == null) {
            return sample(this.value());
          }
          return this.thru(function(value) {
            return sample(value, n);
          });
        };
        lodash.VERSION = VERSION;
        arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(['drop', 'take'], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            var filtered = this.__filtered__;
            if (filtered && !index) {
              return new LazyWrapper(this);
            }
            n = n == null ? 1 : nativeMax(nativeFloor(n) || 0, 0);
            var result = this.clone();
            if (filtered) {
              result.__takeCount__ = nativeMin(result.__takeCount__, n);
            } else {
              result.__views__.push({
                'size': n,
                'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
              });
            }
            return result;
          };
          LazyWrapper.prototype[methodName + 'Right'] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
          var type = index + 1,
              isFilter = type != LAZY_MAP_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
            var result = this.clone();
            result.__iteratees__.push({
              'iteratee': getCallback(iteratee, thisArg, 1),
              'type': type
            });
            result.__filtered__ = result.__filtered__ || isFilter;
            return result;
          };
        });
        arrayEach(['first', 'last'], function(methodName, index) {
          var takeName = 'take' + (index ? 'Right' : '');
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(['initial', 'rest'], function(methodName, index) {
          var dropName = 'drop' + (index ? '' : 'Right');
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        arrayEach(['pluck', 'where'], function(methodName, index) {
          var operationName = index ? 'filter' : 'map',
              createCallback = index ? baseMatches : property;
          LazyWrapper.prototype[methodName] = function(value) {
            return this[operationName](createCallback(value));
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.reject = function(predicate, thisArg) {
          predicate = getCallback(predicate, thisArg, 1);
          return this.filter(function(value) {
            return !predicate(value);
          });
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = start == null ? 0 : (+start || 0);
          var result = this;
          if (result.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result);
          }
          if (start < 0) {
            result = result.takeRight(-start);
          } else if (start) {
            result = result.drop(start);
          }
          if (end !== undefined) {
            end = (+end || 0);
            result = end < 0 ? result.dropRight(-end) : result.take(end - start);
          }
          return result;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate, thisArg) {
          return this.reverse().takeWhile(predicate, thisArg).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(POSITIVE_INFINITY);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName),
              retUnwrapped = /^(?:first|last)$/.test(methodName),
              lodashFunc = lodash[retUnwrapped ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName];
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var args = retUnwrapped ? [1] : arguments,
                chainAll = this.__chain__,
                value = this.__wrapped__,
                isHybrid = !!this.__actions__.length,
                isLazy = value instanceof LazyWrapper,
                iteratee = args[0],
                useLazy = isLazy || isArray(value);
            if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
              isLazy = useLazy = false;
            }
            var interceptor = function(value) {
              return (retUnwrapped && chainAll) ? lodashFunc(value, 1)[0] : lodashFunc.apply(undefined, arrayPush([value], args));
            };
            var action = {
              'func': thru,
              'args': [interceptor],
              'thisArg': undefined
            },
                onlyLazy = isLazy && !isHybrid;
            if (retUnwrapped && !chainAll) {
              if (onlyLazy) {
                value = value.clone();
                value.__actions__.push(action);
                return func.call(value);
              }
              return lodashFunc.call(undefined, this.value())[0];
            }
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result = func.apply(value, args);
              result.__actions__.push(action);
              return new LodashWrapper(result, chainAll);
            }
            return this.thru(interceptor);
          };
        });
        arrayEach(['join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'], function(methodName) {
          var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName],
              chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
              retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              return func.apply(this.value(), args);
            }
            return this[chainName](function(value) {
              return func.apply(value, args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name,
                names = realNames[key] || (realNames[key] = []);
            names.push({
              'name': methodName,
              'func': lodashFunc
            });
          }
        });
        realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{
          'name': 'wrapper',
          'func': undefined
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.concat = wrapperConcat;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toString = wrapperToString;
        lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.collect = lodash.prototype.map;
        lodash.prototype.head = lodash.prototype.first;
        lodash.prototype.select = lodash.prototype.filter;
        lodash.prototype.tail = lodash.prototype.rest;
        return lodash;
      }
      var _ = runInContext();
      if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        root._ = _;
        define(function() {
          return _;
        });
      } else if (freeExports && freeModule) {
        if (moduleExports) {
          (freeModule.exports = _)._ = _;
        } else {
          freeExports._ = _;
        }
      } else {
        root._ = _;
      }
    }.call(this));
  })($__require('process'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:lodash@3.10.1", ["npm:lodash@3.10.1/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:lodash@3.10.1/index');
  global.define = __define;
  return module.exports;
});

System.register('controllers/warning.js', ['npm:babel-runtime@5.8.34/helpers/class-call-check', 'lodash'], function (_export) {
  var _classCallCheck, _, WarningController;

  return {
    setters: [function (_babelRuntimeHelpersClassCallCheck) {
      _classCallCheck = _babelRuntimeHelpersClassCallCheck['default'];
    }, function (_lodash) {
      _ = _lodash['default'];
    }],
    execute: function () {
      'use strict';

      WarningController =

      /*@ngInject*/
      function WarningController($scope, $stateParams, $http, uiGmapGoogleMapApi, uiGmapIsReady, warning) {
        _classCallCheck(this, WarningController);

        $scope.warning = warning.data;
        $scope.slug = $stateParams.slug;

        $scope.map = {
          center: {
            latitude: '51.500152',
            longitude: '-0.126236'
          },
          polygons: [],
          zoom: 15

        };

        uiGmapGoogleMapApi.then(function (maps) {
          $http.get($scope.warning.floodArea.polygon).then(function (polygon) {
            $scope.polygons = polygon.data.features[0].geometry;
            $scope.polygonMeta = polygon.data.features[0].properties;
            $scope.polygons.type = "Polygon";
            $scope.polygons.coordinates = $scope.polygons.coordinates[0];
            $scope.map.polygons.push({ id: 1, "geom": $scope.polygons });

            _.map($scope.polygons.coordinates[0], function (coord) {
              $scope.bounds = new maps.LatLngBounds();
              var latLng = new maps.LatLng(coord[1], coord[0]);
              $scope.bounds.extend(latLng);
            });

            uiGmapIsReady.promise(1).then(function (instances) {
              instances.forEach(function (inst) {
                var map = inst.map;
                console.log('setting center to: ' + $scope.bounds.getCenter());

                //$scope.map.center.latitude = $scope.bounds.getCenter().lat();
                //$scope.map.center.longitude = $scope.bounds.getCenter().lng();
              });
            });
          });
        });
      };

      _export('WarningController', WarningController);
    }
  };
});

System.register('app.js', ['babel/external-helpers', 'angular', 'jquery', 'lodash', 'angular-route', 'angular-simple-logger', 'angular-google-maps', 'angular-bootstrap', 'angular-ui-router', 'angular-slugify', 'controllers/home', 'controllers/header', 'controllers/warnings', 'controllers/search', 'controllers/warning'], function (_export) {
  'use strict';

  var angular, $, _, HomeController, HeaderController, WarningsController, SearchController, WarningController, app;

  return {
    setters: [function (_babelExternalHelpers) {}, function (_angular) {
      angular = _angular['default'];
    }, function (_jquery) {
      $ = _jquery['default'];
    }, function (_lodash) {
      _ = _lodash['default'];
    }, function (_angularRoute) {}, function (_angularSimpleLogger) {}, function (_angularGoogleMaps) {}, function (_angularBootstrap) {}, function (_angularUiRouter) {}, function (_angularSlugify) {}, function (_controllersHome) {
      HomeController = _controllersHome.HomeController;
    }, function (_controllersHeader) {
      HeaderController = _controllersHeader.HeaderController;
    }, function (_controllersWarnings) {
      WarningsController = _controllersWarnings.WarningsController;
    }, function (_controllersSearch) {
      SearchController = _controllersSearch.SearchController;
    }, function (_controllersWarning) {
      WarningController = _controllersWarning.WarningController;
    }],
    execute: function () {
      app = angular.module('floodChecker', ['ngRoute', 'ui.bootstrap', 'ui.bootstrap.tpls', 'uiGmapgoogle-maps', 'ui.router', 'slugifier']);

      app.config(['$locationProvider', '$stateProvider', 'uiGmapGoogleMapApiProvider', '$urlRouterProvider', function ($locationProvider, $stateProvider, uiGmapGoogleMapApiProvider, $urlRouterProvider) {

        $locationProvider.html5Mode(true).hashPrefix('!');

        $stateProvider.state('root', {
          abstract: true,
          views: {
            'header@': {
              controller: HeaderController,
              templateUrl: '/frontend/partials/header.html'
            }
          }
        }).state('root.home', {
          url: "/",
          views: {
            '@': {
              controller: HomeController,
              templateUrl: '/frontend/partials/home.html'
            }
          },
          resolve: {
            "currentWarnings": function currentWarnings($http) {
              return $http.get('/warnings/current/json');
            }
          }
        }).state('root.home.warning', {
          url: "^/warnings/:slug/",
          views: {
            '@': {
              templateUrl: "/frontend/partials/warning.html",
              controller: WarningController
            }
          },
          resolve: {
            warning: function warning($http, $stateParams) {
              return $http.get('/warnings/' + $stateParams.slug + '/json/');
            }
          }

        }).state('root.warnings', {
          url: "/warnings/",
          views: {
            '@': {
              templateUrl: "/frontend/partials/warnings.html",
              controller: WarningsController
            }
          },
          resolve: {
            warningsContext: function warningsContext($http) {
              return $http.get('/warnings/json/');
            }
          }
        }).state('root.search', {
          url: "/search/?q",
          views: {
            '@': {
              controller: SearchController
            }
          },
          resolve: {
            searchContext: function searchContext($http, $stateParams) {
              return $http.get('/search/json/?q=' + $stateParams.q);
            }
          }
        }).state('root.warnings.warning', {
          url: "^/warnings/:slug/",
          views: {
            '@': {
              templateUrl: "/frontend/partials/warning.html",
              controller: WarningController
            }
          },
          resolve: {
            warning: function warning($http, $stateParams) {
              return $http.get('/warnings/' + $stateParams.slug + '/json/');
            }
          }

        });

        // maps config
        uiGmapGoogleMapApiProvider.configure({
          key: 'AIzaSyCpz3aVqyXcPEp2lXGyDUfRSqyTliR4dSM',
          v: '3.18',
          libraries: 'geometry'
        });
      }]);

      _export('default', app);
    }
  };
});

System.register('main.js', ['lodash', 'app'], function (_export) {
  'use strict';

  var _;

  return {
    setters: [function (_lodash) {
      _ = _lodash['default'];
    }, function (_app) {}],
    execute: function () {
      //import 'services';
      //import 'controllers/header';
      //import 'controllers/warnings';
      //import 'controllers/warning';

      angular.element(document).ready(function ($ocLazyLoad) {
        angular.bootstrap(document.body, ['floodChecker'], {
          strictDi: false
        });
      });
    }
  };
});
